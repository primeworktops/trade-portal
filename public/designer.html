<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Worktop Drawing Tool v3</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    :root {
      --primary: #1e4d3a;
      --primary-light: #2d6b4f;
      --accent: #d4a843;
      --bg: #f5f5f5;
      --card: #ffffff;
      --text: #1a1a1a;
      --text-muted: #666;
      --border: #e0e0e0;
    }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: var(--bg); color: var(--text); height: 100vh; display: flex; flex-direction: column; overflow: hidden; }
    
    .header { background: var(--primary); color: white; padding: 10px 20px; display: flex; align-items: center; gap: 15px; }
    .header h1 { font-size: 16px; font-weight: 600; }
    
    .toolbar { background: white; border-bottom: 1px solid var(--border); padding: 8px 15px; display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    .tool-group { display: flex; gap: 4px; padding-right: 12px; border-right: 1px solid var(--border); margin-right: 4px; }
    .tool-group:last-child { border-right: none; }
    .tool-btn { padding: 6px 10px; border: 2px solid var(--border); background: white; border-radius: 5px; cursor: pointer; font-size: 12px; display: flex; align-items: center; gap: 4px; transition: all 0.15s; }
    .tool-btn:hover { border-color: var(--primary); background: #f0f7f4; }
    .tool-btn.active { border-color: var(--primary); background: #e0f2e9; color: var(--primary); font-weight: 600; }
    
    .preset-btn { padding: 4px 8px; border: 1px solid var(--border); background: white; border-radius: 4px; cursor: pointer; font-size: 11px; }
    .preset-btn:hover { border-color: var(--primary); background: #f0f7f4; }
    
    .view-tabs { display: flex; background: white; border-bottom: 1px solid var(--border); }
    .view-tab { padding: 8px 20px; cursor: pointer; font-size: 13px; border-bottom: 3px solid transparent; }
    .view-tab:hover { background: #f8f8f8; }
    .view-tab.active { border-bottom-color: var(--primary); color: var(--primary); font-weight: 600; }
    
    .main-area { flex: 1; display: flex; overflow: hidden; }
    
    .canvas-container { flex: 1; position: relative; background: #e8ecef; overflow: hidden; }
    #canvas2d, #canvas3d { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
    #canvas3d { display: none; }
    
    .sidebar { width: 260px; background: white; border-left: 1px solid var(--border); overflow-y: auto; padding: 12px; font-size: 12px; }
    .panel { margin-bottom: 15px; }
    .panel-title { font-size: 10px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.05em; color: var(--text-muted); margin-bottom: 8px; padding-bottom: 4px; border-bottom: 1px solid var(--border); }
    
    .item-row { display: flex; align-items: center; gap: 6px; padding: 6px 8px; border: 1px solid var(--border); border-radius: 5px; margin-bottom: 4px; cursor: pointer; }
    .item-row:hover { background: #f8f8f8; }
    .item-row.selected { border-color: var(--primary); background: #e8f5e9; }
    .item-icon { width: 18px; height: 18px; display: flex; align-items: center; justify-content: center; border-radius: 3px; font-size: 11px; }
    .item-icon.worktop { background: #e0e0e0; }
    .item-icon.upstand { background: #a5d6a7; }
    .item-info { flex: 1; min-width: 0; }
    .item-name { font-weight: 500; font-size: 11px; }
    .item-dims { font-size: 10px; color: var(--text-muted); }
    .item-delete { color: #dc3545; border: none; background: none; cursor: pointer; font-size: 14px; padding: 0 2px; }
    
    .form-row { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; margin-bottom: 8px; }
    .form-group { }
    .form-group.full { grid-column: 1 / -1; }
    .form-label { display: block; font-size: 10px; font-weight: 600; margin-bottom: 2px; color: var(--text-muted); }
    .form-input { width: 100%; padding: 4px 6px; border: 1px solid var(--border); border-radius: 4px; font-size: 11px; }
    .form-input:focus { outline: none; border-color: var(--primary); }
    
    .summary-box { background: linear-gradient(135deg, var(--primary), var(--primary-light)); color: white; border-radius: 8px; padding: 10px; }
    .summary-row { display: flex; justify-content: space-between; margin-bottom: 3px; font-size: 11px; }
    .summary-row.total { border-top: 1px solid rgba(255,255,255,0.3); padding-top: 5px; margin-top: 5px; font-size: 13px; font-weight: 700; }
    
    .status-bar { background: #333; color: white; padding: 5px 12px; font-size: 11px; display: flex; gap: 15px; }
    .status-item { display: flex; align-items: center; gap: 4px; }
    .status-item span { color: #aaa; }
    
    .legend { position: absolute; top: 10px; left: 10px; background: rgba(255,255,255,0.95); border-radius: 6px; padding: 8px 10px; font-size: 10px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
    .legend-item { display: flex; align-items: center; gap: 5px; margin-bottom: 2px; }
    .legend-color { width: 16px; height: 3px; border-radius: 1px; }
    
    .edge-menu { position: fixed; background: white; border-radius: 8px; box-shadow: 0 4px 20px rgba(0,0,0,0.2); padding: 6px 0; min-width: 180px; z-index: 9999; pointer-events: auto; }
    .edge-menu-item { padding: 8px 12px; cursor: pointer; display: flex; align-items: center; gap: 8px; font-size: 12px; }
    .edge-menu-item:hover { background: #f0f0f0; }
    .edge-menu-item .dot { width: 8px; height: 8px; border-radius: 50%; }
    
    /* Modal Dialog */
    .modal-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; z-index: 1000; }
    .modal-dialog { background: white; border-radius: 12px; padding: 20px; min-width: 300px; box-shadow: 0 10px 40px rgba(0,0,0,0.3); }
    .modal-title { font-size: 16px; font-weight: 600; margin-bottom: 15px; color: #333; }
    .modal-buttons { display: flex; gap: 10px; flex-wrap: wrap; }
    .modal-btn { flex: 1; min-width: 80px; padding: 12px 16px; border: 2px solid #1e4d3a; background: white; color: #1e4d3a; border-radius: 8px; font-size: 14px; font-weight: 500; cursor: pointer; transition: all 0.2s; }
    .modal-btn:hover { background: #1e4d3a; color: white; }
    .modal-btn.primary { background: #1e4d3a; color: white; }
    .modal-btn.primary:hover { background: #2d6b52; }
    .modal-btn.cancel { border-color: #999; color: #666; }
    .modal-btn.cancel:hover { background: #f5f5f5; color: #333; }
    
    /* Responsive modal for smaller screens */
    @media (max-width: 1000px) {
      #materialModal .modal-dialog {
        min-width: 95vw !important;
        max-width: 95vw !important;
        max-height: 95vh !important;
        margin: 10px;
        padding: 12px !important;
      }
      #materialModal #materialGrid {
        grid-template-columns: repeat(3, 1fr) !important;
        gap: 8px !important;
      }
      #materialModal #brandLogos {
        gap: 4px !important;
      }
      #materialModal #brandLogos > div {
        width: 60px !important;
        height: 60px !important;
      }
      /* Compact selected material bar on smaller screens */
      #materialModal #selectedMaterialBar {
        padding: 10px !important;
      }
      #materialModal #selectedMaterialBar > div {
        flex-wrap: wrap;
        gap: 10px !important;
      }
      #materialModal #selectedMatThumb {
        width: 50px !important;
        height: 50px !important;
      }
      #materialModal #selectedMatName {
        font-size: 14px !important;
      }
    }
    
    @media (max-height: 700px) {
      #materialModal .modal-dialog {
        max-height: 98vh !important;
        padding: 10px !important;
      }
      #materialModal #brandLogos > div {
        width: 50px !important;
        height: 50px !important;
      }
      #materialModal #brandLogos > div img {
        max-height: 30px !important;
      }
      #materialModal #selectedMaterialBar {
        padding: 8px !important;
        margin-top: 8px !important;
      }
      #materialModal #selectedMatThumb {
        width: 40px !important;
        height: 40px !important;
      }
      #materialModal #selectedMatName {
        font-size: 13px !important;
      }
      #materialModal #confirmMaterialBtn,
      #materialModal button[onclick="clearMaterialSelection()"] {
        padding: 8px 12px !important;
        font-size: 11px !important;
      }
    }
    
    /* Very small screens - stack buttons */
    @media (max-width: 800px) {
      #materialModal #materialGrid {
        grid-template-columns: repeat(2, 1fr) !important;
      }
      #materialModal #selectedMaterialBar > div {
        flex-direction: column;
        align-items: stretch !important;
        text-align: center;
      }
      #materialModal #selectedMaterialBar > div > div:last-child {
        margin-left: 0 !important;
        justify-content: center;
      }
      #materialModal #selectedMatThumb {
        display: none !important;
      }
      #materialModal #selectedMatTier {
        position: absolute;
        right: 10px;
        top: 10px;
      }
      /* Hide badges on small screens */
      #materialModal .brand-logo-btn span {
        display: none !important;
      }
    }
    
    /* Tier display styles */
    .tier-classic { font-weight: 700; font-size: 14px; letter-spacing: 1px; }
    .tier-classic.t1 { color: #4CAF50; }
    .tier-classic.t2 { color: #8BC34A; }
    .tier-classic.t3 { color: #FFC107; }
    .tier-classic.t4 { color: #FF9800; }
    .tier-classic.t5 { color: #f44336; }
    
    .tier-pill { font-weight: 600; font-size: 11px; padding: 4px 10px; border-radius: 12px; letter-spacing: 1px; display: inline-block; }
    .tier-pill.t1 { background: rgba(76,175,80,0.15); color: #4CAF50; }
    .tier-pill.t2 { background: rgba(139,195,74,0.15); color: #8BC34A; }
    .tier-pill.t3 { background: rgba(255,193,7,0.15); color: #FFC107; }
    .tier-pill.t4 { background: rgba(255,152,0,0.15); color: #FF9800; }
    .tier-pill.t5 { background: rgba(244,67,54,0.15); color: #f44336; }
    
    .tier-style-btn { padding: 4px 8px; border: 1px solid #ccc; background: white; border-radius: 4px; cursor: pointer; font-size: 10px; transition: all 0.2s; }
    .tier-style-btn:hover { border-color: #1e4d3a; }
    .tier-style-btn.active { background: #1e4d3a; color: white; border-color: #1e4d3a; }
  </style>
</head>
<body>
  <div class="header">
    <h1>üîß Worktop Designer</h1>
  </div>
  
  <div class="toolbar">
    <div class="tool-group">
      <button class="tool-btn active" data-tool="select" onclick="setTool('select')">‚Üñ Select</button>
      <button class="tool-btn" data-tool="worktop" onclick="setTool('worktop')">‚ñ≠ Worktop</button>
      <button class="tool-btn" data-tool="upstand" onclick="setTool('upstand')">‚ñ¨ Upstand/Splash</button>
    </div>
    <div class="tool-group">
      <span style="font-size:11px; color:#666;">Presets:</span>
      <button class="preset-btn" onclick="loadPreset('single')">Single</button>
      <button class="preset-btn" onclick="loadPreset('galley')">Galley</button>
      <button class="preset-btn" onclick="loadPreset('lshape')">L-Shape</button>
      <button class="preset-btn" onclick="loadPreset('ushape')">U-Shape</button>
      <button class="preset-btn" onclick="loadPreset('gshape')">G-Shape</button>
    </div>
    <div class="tool-group">
      <button class="tool-btn" onclick="undo()">‚Ü© Undo</button>
      <button class="tool-btn" onclick="rotateSelected()">‚Üª Rotate</button>
      <button class="tool-btn" onclick="deleteSelected()">üóë Delete</button>
    </div>
    <div class="tool-group" style="display:flex;align-items:center;gap:10px;">
      <button onclick="showMaterialModal()" style="padding:8px 16px;background:#ff9800;color:white;border:none;border-radius:6px;cursor:pointer;font-size:13px;font-weight:600;box-shadow:0 2px 4px rgba(0,0,0,0.2);" onmouseover="this.style.background='#f57c00'" onmouseout="this.style.background='#ff9800'">üé® Select Material</button>
      <div id="currentMaterialDisplay" style="display:flex;align-items:center;gap:8px;padding:6px 12px;background:#f5f5f5;border-radius:6px;border:1px solid #ddd;">
        <div id="currentMatSwatch" style="width:28px;height:28px;border-radius:4px;background:#ccc;border:1px solid #aaa;"></div>
        <div>
          <div id="currentMatName" style="font-size:12px;font-weight:600;color:#333;">No material selected</div>
          <div id="currentMatBrand" style="font-size:10px;color:#666;"></div>
        </div>
      </div>
    </div>
  </div>
  
  <div class="view-tabs">
    <div class="view-tab active" onclick="switchView('2d')">üìê 2D Layout</div>
    <div class="view-tab" onclick="switchView('3d')">üé¨ 3D Preview</div>
    <div class="view-tab" id="slabLayoutTab" onclick="tryOpenSlabLayout()" style="background:#fff3e0;display:none;">üì¶ Slab Layout</div>
    <button id="adminTabBtn" onclick="promptAdminUnlock()" style="padding:6px 12px;margin-left:8px;background:#f5f5f5;border:1px solid #ccc;border-radius:4px;cursor:pointer;font-size:12px;">üîí Admin</button>
    
    <div style="flex:1;"></div>
    
    <!-- 2D Navigation -->
    <div id="nav2d" style="display:flex; gap:3px; align-items:center; padding:0 10px;">
      <span style="font-size:10px;color:#666;margin-right:4px;">Pan:</span>
      <button class="tool-btn" onclick="panView(-150,0)" title="Pan Left (‚Üê)" style="padding:4px 8px;">‚Üê</button>
      <button class="tool-btn" onclick="panView(150,0)" title="Pan Right (‚Üí)" style="padding:4px 8px;">‚Üí</button>
      <button class="tool-btn" onclick="panView(0,-150)" title="Pan Up (‚Üë)" style="padding:4px 8px;">‚Üë</button>
      <button class="tool-btn" onclick="panView(0,150)" title="Pan Down (‚Üì)" style="padding:4px 8px;">‚Üì</button>
      <span style="margin:0 6px;color:#ddd;">|</span>
      <span style="font-size:10px;color:#666;margin-right:4px;">Zoom:</span>
      <button class="tool-btn" onclick="zoomIn()" title="Zoom In (+)" style="padding:4px 8px;">+</button>
      <button class="tool-btn" onclick="zoomOut()" title="Zoom Out (-)" style="padding:4px 8px;">‚àí</button>
      <button class="tool-btn" onclick="zoomFit()" title="Fit to View" style="padding:4px 8px;">‚äô Fit</button>
    </div>
    
    <!-- 3D Navigation -->
    <div id="nav3d" style="display:none; gap:3px; align-items:center; padding:0 10px;">
      <span style="font-size:10px;color:#666;margin-right:4px;">Rotate:</span>
      <button class="tool-btn" onclick="rotate3D(-1,0)" title="Rotate Left" style="padding:4px 8px;">‚Ü∂</button>
      <button class="tool-btn" onclick="rotate3D(1,0)" title="Rotate Right" style="padding:4px 8px;">‚Ü∑</button>
      <button class="tool-btn" onclick="rotate3D(0,1)" title="Tilt Up" style="padding:4px 8px;">‚Üë</button>
      <button class="tool-btn" onclick="rotate3D(0,-1)" title="Tilt Down" style="padding:4px 8px;">‚Üì</button>
      <span style="margin:0 6px;color:#ddd;">|</span>
      <button class="tool-btn" onclick="view3DTop()" title="Top View" style="padding:4px 8px;background:#e3f2fd;">‚¨á Top</button>
      <button class="tool-btn" onclick="view3DFront()" title="Front View" style="padding:4px 8px;background:#e8f5e9;">‚óØ Front</button>
      <span style="margin:0 6px;color:#ddd;">|</span>
      <button class="tool-btn" onclick="zoom3D(0.8)" title="Zoom In" style="padding:4px 8px;">+</button>
      <button class="tool-btn" onclick="zoom3D(1.25)" title="Zoom Out" style="padding:4px 8px;">‚àí</button>
      <button class="tool-btn" onclick="reset3DView()" title="Reset View" style="padding:4px 8px;">‚äô</button>
      <span style="margin:0 6px;color:#ddd;">|</span>
      <button class="tool-btn" onclick="captureCurrentView()" title="Capture this view for quote" style="padding:4px 10px;background:#fff3e0;border-color:#ff9800;">üì∏ Capture</button>
      <span id="captureCount" style="display:none;background:#ff9800;color:white;padding:2px 6px;border-radius:10px;font-size:10px;font-weight:600;margin-left:4px;">0</span>
      <button class="tool-btn" onclick="clearCaptures()" id="clearCapturesBtn" title="Clear all captured views" style="display:none;padding:4px 8px;background:#ffebee;border-color:#f44336;color:#c62828;">‚úï</button>
    </div>
  </div>
  
  <div class="main-area">
    <div class="canvas-container" id="canvasContainer">
      <canvas id="canvas2d"></canvas>
      <div id="canvas3d"></div>
      <!-- 3D Disclaimer -->
      <div id="disclaimer3d" style="display:none;position:absolute;bottom:10px;left:10px;background:rgba(0,0,0,0.7);color:white;padding:8px 12px;border-radius:6px;font-size:11px;max-width:300px;z-index:50;">
        ‚ö†Ô∏è <strong>Illustration Only</strong> - This 3D render is for visualisation purposes only. Actual colours, textures and finishes may vary. Please request a sample before ordering.
      </div>
      <!-- Generate Quote Button (2D view only) -->
      <button id="generateQuoteBtn" onclick="generateQuote()" style="position:absolute;bottom:20px;right:20px;padding:14px 28px;background:linear-gradient(135deg,#4CAF50,#2e7d32);color:white;border:none;border-radius:10px;font-size:16px;font-weight:700;cursor:pointer;box-shadow:0 4px 15px rgba(76,175,80,0.4);z-index:100;display:flex;align-items:center;gap:8px;transition:all 0.2s;" onmouseover="this.style.transform='translateY(-3px) scale(1.02)';this.style.boxShadow='0 6px 20px rgba(76,175,80,0.5)';" onmouseout="this.style.transform='translateY(0) scale(1)';this.style.boxShadow='0 4px 15px rgba(76,175,80,0.4)';">
        üìÑ Generate Quote
      </button>
      <!-- Clear Design Button - bottom left corner -->
      <button id="clearDesignBtn" onclick="clearDesignState()" style="position:absolute;bottom:20px;left:20px;padding:12px 20px;background:#fff;color:#666;border:1px solid #ddd;border-radius:8px;font-size:14px;cursor:pointer;z-index:100;transition:all 0.2s;" onmouseover="this.style.background='#ffebee';this.style.color='#c62828';this.style.borderColor='#ef9a9a';" onmouseout="this.style.background='#fff';this.style.color='#666';this.style.borderColor='#ddd';">
        üóëÔ∏è New Design
      </button>
      <canvas id="canvasSlab" style="display:none;"></canvas>
      <!-- Slab Size Configuration (Admin/Fabricator only) -->
      <div id="slabConfig" style="display:none;position:absolute;top:10px;right:10px;background:#fff;padding:12px;border-radius:8px;box-shadow:0 2px 8px rgba(0,0,0,0.15);z-index:100;max-width:300px;max-height:90vh;overflow-y:auto;">
        <div style="font-weight:600;font-size:12px;color:#1e4d3a;margin-bottom:8px;">‚öôÔ∏è Admin Settings</div>
        
        <!-- Custom Material Section -->
        <div style="margin-bottom:10px;padding-bottom:10px;border-bottom:1px solid #eee;background:#fff8e1;padding:10px;border-radius:6px;margin:-4px -4px 10px -4px;">
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px;">
            <div style="font-size:10px;font-weight:600;color:#f57c00;">üì¶ CUSTOM MATERIAL</div>
            <div id="customMaterialStatus" style="font-size:9px;padding:2px 6px;border-radius:10px;background:#eee;color:#666;">Inactive</div>
          </div>
          <div style="margin-bottom:6px;">
            <label style="font-size:10px;color:#666;">Material Name</label>
            <input type="text" id="customMaterialName" placeholder="e.g. Nero Marquina Marble" style="width:100%;padding:4px;border:1px solid #ccc;border-radius:4px;box-sizing:border-box;">
          </div>
          <div style="display:flex;gap:8px;margin-bottom:6px;">
            <div style="flex:1;">
              <label style="font-size:10px;color:#666;">Thickness</label>
              <select id="customMaterialThickness" style="width:100%;padding:4px;border:1px solid #ccc;border-radius:4px;">
                <option value="20">20mm</option>
                <option value="30" selected>30mm</option>
                <option value="40">40mm</option>
                <option value="50">50mm</option>
              </select>
            </div>
            <div style="flex:1;">
              <label style="font-size:10px;color:#666;">Type</label>
              <select id="customMaterialType" style="width:100%;padding:4px;border:1px solid #ccc;border-radius:4px;">
                <option value="quartz">Quartz</option>
                <option value="granite">Granite</option>
                <option value="marble">Marble</option>
                <option value="quartzite">Quartzite</option>
                <option value="porcelain">Porcelain</option>
                <option value="dekton">Dekton/Sintered</option>
                <option value="other">Other</option>
              </select>
            </div>
          </div>
          <div style="margin-bottom:6px;">
            <label style="font-size:10px;color:#666;">Slab Price (¬£) - Cost per slab</label>
            <input type="number" id="customSlabPrice" placeholder="e.g. 450" style="width:100%;padding:4px;border:1px solid #ccc;border-radius:4px;box-sizing:border-box;">
          </div>
          <div style="margin-bottom:6px;">
            <label style="font-size:10px;color:#666;">Material Image (for 3D preview & quote)</label>
            <input type="file" id="customMaterialImage" accept="image/*" onchange="loadCustomMaterialImage(this)" style="width:100%;font-size:10px;">
          </div>
          <div id="customMaterialPreview" style="display:none;margin-top:6px;text-align:center;">
            <img id="customMaterialPreviewImg" style="max-width:100%;max-height:60px;border-radius:4px;border:1px solid #ddd;">
            <div id="customMaterialPreviewName" style="font-size:10px;color:#666;margin-top:2px;"></div>
          </div>
          <div style="display:flex;gap:6px;margin-top:6px;">
            <button onclick="applyCustomMaterial()" style="flex:1;padding:6px;background:#f57c00;color:white;border:none;border-radius:4px;cursor:pointer;font-size:11px;">Apply Custom Material</button>
            <button onclick="clearCustomMaterial()" style="padding:6px 10px;background:#eee;color:#666;border:1px solid #ccc;border-radius:4px;cursor:pointer;font-size:11px;">Clear</button>
          </div>
        </div>
        
        <div style="margin-bottom:10px;padding-bottom:10px;border-bottom:1px solid #eee;">
          <div style="font-size:10px;font-weight:600;color:#666;margin-bottom:4px;">SLAB SIZE</div>
          <div style="display:flex;gap:8px;align-items:center;">
            <div>
              <label style="font-size:10px;color:#666;">Width (mm)</label>
              <input type="number" id="slabWidthInput" value="3200" style="width:70px;padding:4px;border:1px solid #ccc;border-radius:4px;" onchange="renderSlabLayout()">
            </div>
            <div style="font-size:14px;color:#999;">√ó</div>
            <div>
              <label style="font-size:10px;color:#666;">Height (mm)</label>
              <input type="number" id="slabHeightInput" value="1600" style="width:70px;padding:4px;border:1px solid #ccc;border-radius:4px;" onchange="renderSlabLayout()">
            </div>
          </div>
          <div style="margin-top:4px;font-size:9px;color:#999;">Default: 3200√ó1600mm (Natural Stone: 3200√ó1900, Indigo Porcelain: 3300√ó1840)</div>
        </div>
        
        <div style="margin-bottom:10px;padding-bottom:10px;border-bottom:1px solid #eee;">
          <div style="font-size:10px;font-weight:600;color:#666;margin-bottom:4px;">PROFIT SETTINGS</div>
          <div style="display:flex;gap:8px;margin-bottom:6px;">
            <div style="flex:1;">
              <label style="font-size:10px;color:#666;">1st Slab (¬£)</label>
              <input type="number" id="profit1stSlab" value="1300" style="width:100%;padding:4px;border:1px solid #ccc;border-radius:4px;" onchange="renderSlabLayout()">
            </div>
            <div style="flex:1;">
              <label style="font-size:10px;color:#666;">Add'l (¬£/sq ft)</label>
              <input type="number" id="profitAddSlab" value="12.50" step="0.01" style="width:100%;padding:4px;border:1px solid #ccc;border-radius:4px;" onchange="renderSlabLayout()">
            </div>
          </div>
          <div style="font-size:9px;color:#999;">1st slab fixed + ¬£/sq ft on additional slabs</div>
        </div>
        
        <div id="slabPriceEstimate" style="background:#e8f5e9;padding:8px;border-radius:4px;font-size:11px;color:#1e4d3a;">
          <strong>Estimated Profit:</strong> ¬£0.00
        </div>
        
        <div style="margin-top:10px;padding-top:10px;border-top:1px solid #eee;">
          <div style="font-size:10px;font-weight:600;color:#666;margin-bottom:6px;">PRICE TIER STYLE</div>
          <div style="display:flex;gap:6px;">
            <button onclick="setTierStyle('classic')" id="tierStyleClassic" class="tier-style-btn">¬£¬£¬£ Classic</button>
            <button onclick="setTierStyle('pill')" id="tierStylePill" class="tier-style-btn active">Soft Pill</button>
          </div>
          <div style="margin-top:8px;padding:6px;background:#f5f5f5;border-radius:4px;">
            <div style="font-size:9px;color:#666;margin-bottom:4px;">Preview:</div>
            <div id="tierStylePreview" style="display:flex;gap:8px;align-items:center;flex-wrap:wrap;"></div>
          </div>
        </div>
      </div>
      <div class="legend" id="legend2d">
        <div class="legend-item"><div class="legend-color" style="background:#999;"></div> Joined</div>
        <div class="legend-item"><div class="legend-color" style="background:#4CAF50;"></div> Free (click)</div>
        <div class="legend-item"><div class="legend-color" style="background:#9c27b0;"></div> Dropdown (Full)</div>
        <div class="legend-item"><div class="legend-color" style="background:#795548;"></div> Mitred Edge</div>
        <div class="legend-item"><div class="legend-color" style="background:#a5d6a7;"></div> Upstand</div>
        <div class="legend-item"><div class="legend-color" style="background:#80cbc4;"></div> Splashback</div>
        <div style="border-top:1px solid #ddd;margin:4px 0;padding-top:4px;font-size:9px;font-weight:600;color:#666;">Edge Profiles:</div>
        <div id="profileLegend"></div>
      </div>
    </div>
    
    <div class="sidebar">
      <div class="panel">
        <div class="panel-title">Worktops</div>
        <div id="worktopsList"></div>
      </div>
      <div class="panel">
        <div class="panel-title">Upstands & Splashbacks</div>
        <div id="upstandsList"></div>
      </div>
      <div class="panel">
        <div class="panel-title">Cutouts (Sinks, Hobs, Taps)</div>
        <div id="cutoutsList"></div>
      </div>
      <div class="panel" id="propsPanel" style="display:none;">
        <div class="panel-title">Properties</div>
        <div id="propsForm"></div>
      </div>
      <div class="panel">
        <div class="panel-title">Summary</div>
        <div class="summary-box">
          <div class="summary-row"><span>Worktop</span><span id="sumWorktop">0.00 m¬≤</span></div>
          <div class="summary-row"><span>Upstand/Splash</span><span id="sumUpstand">0.00 m¬≤</span></div>
          <div class="summary-row"><span>Dropdown</span><span id="sumDropdown">0.00 m¬≤</span></div>
          <div class="summary-row" style="border-top:1px solid #1e4d3a;padding-top:4px;margin-top:4px;font-weight:600;color:#2e7d32;background:#e8f5e9;padding:6px 4px;border-radius:4px;"><span>Total Material</span><span id="sumTotal">0.00 m¬≤</span></div>
          <div class="summary-row"><span>Profile Edges</span><span id="sumProfile">0.00 m</span></div>
          <div class="summary-row"><span>Profile Type(s)</span><span id="sumProfileType" style="font-size:10px;">None</span></div>
          <div class="summary-row"><span>Cutouts</span><span id="sumCutouts">None</span></div>
          <div class="summary-row"><span>Joints</span><span id="sumJoints">0</span></div>
          <div class="summary-row total"><span>Slabs Required</span><span id="sumSlabs">0</span></div>
          
          <!-- Slab Optimization Warning -->
          <div id="slabWarning" style="display:none;background:#fff3e0;border:1px solid #ffb74d;border-radius:6px;padding:8px;margin-top:8px;font-size:11px;">
            <div style="font-weight:600;color:#e65100;margin-bottom:4px;">üí° Optimization Tips:</div>
            <div id="slabWarningText" style="color:#bf360c;"></div>
          </div>
          
          <div class="summary-row" style="border-top:1px solid #eee;padding-top:6px;margin-top:6px;">
            <span>Thickness</span>
            <select id="thicknessSelect" onchange="setWorktopThickness(+this.value)" style="padding:2px 4px;border-radius:4px;border:1px solid #ccc;">
              <option value="20" selected>20mm</option>
              <option value="30">30mm</option>
            </select>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <div class="status-bar">
    <div class="status-item"><span>Tool:</span> <strong id="statusTool">Select</strong></div>
    <div class="status-item"><span>Zoom:</span> <strong id="statusZoom">100%</strong></div>
    <div class="status-item"><span>Hint:</span> <span id="statusHint">Click green edge for options. Hold Space to pan. Double-click to deselect.</span></div>
  </div>
  
  <div class="edge-menu" id="edgeMenu" style="display:none;max-height:70vh;overflow-y:auto;" onclick="event.stopPropagation();" onmousedown="event.stopPropagation();">
    <div style="font-size:10px;font-weight:600;color:#666;padding:6px 12px;border-bottom:1px solid #eee;">UPSTANDS & SPLASHBACKS</div>
    <div class="edge-menu-item" onclick="setEdgeType('upstand')"><div class="dot" style="background:#a5d6a7;"></div> Add Upstand (100mm)</div>
    <div class="edge-menu-item" onclick="setEdgeType('splashback')"><div class="dot" style="background:#80cbc4;"></div> Add Splashback</div>
    <div class="edge-menu-item" onclick="addPositionedSplashback()"><div class="dot" style="background:#26a69a;"></div> Splashback at position...</div>
    <div class="edge-menu-item" onclick="addWindowCill()"><div class="dot" style="background:#ffb74d;"></div> Window Cill at position...</div>
    <div class="edge-menu-item" onclick="addSocketCutout()"><div class="dot" style="background:#ff7043;"></div> Socket Cutout (on this edge)</div>
    
    <div style="font-size:10px;font-weight:600;color:#666;padding:6px 12px;border-bottom:1px solid #eee;border-top:1px solid #eee;margin-top:4px;">SINKS & CUTOUTS</div>
    <div class="edge-menu-item" onclick="addCutout('undermount_sink')"><img src="https://lh3.googleusercontent.com/d/1vKV4RkYHmwsVzlnEtXvH0woSjQ5FYcZ6=s40" style="width:24px;height:24px;border-radius:4px;object-fit:cover;"> Undermount Sink</div>
    <div class="edge-menu-item" onclick="addCutout('sink_with_drainers')"><img src="https://lh3.googleusercontent.com/d/1OkNW1HvAOABRG2XpeC6W379L4H0WZxIP=s40" style="width:24px;height:24px;border-radius:4px;object-fit:cover;"> Sink + Drainers</div>
    <div class="edge-menu-item" onclick="addCutout('overmount_sink')"><img src="https://lh3.googleusercontent.com/d/1vKV4RkYHmwsVzlnEtXvH0woSjQ5FYcZ6=s40" style="width:24px;height:24px;border-radius:4px;object-fit:cover;"> Overmount Sink</div>
    <div class="edge-menu-item" onclick="addCutout('hob')"><img src="https://lh3.googleusercontent.com/d/17sdiphAm7KDwJRH664cZcD-UWDSyHmxX=s40" style="width:24px;height:24px;border-radius:4px;object-fit:cover;"> Hob Cutout</div>
    <div class="edge-menu-item" onclick="addCutout('recess_hob')"><img src="https://lh3.googleusercontent.com/d/1V99gR1cZdTa2wvSU8vEEc_0GZ5ISaQaW=s40" style="width:24px;height:24px;border-radius:4px;object-fit:cover;"> Recess Hob</div>
    <div class="edge-menu-item" onclick="addCutout('tap')"><img src="https://lh3.googleusercontent.com/d/17-G19NoJACgypg3TUtDrUFb6pKdRDhF9=s40" style="width:24px;height:24px;border-radius:4px;object-fit:cover;"> Tap / Pop Up Socket</div>
    
    <div style="font-size:10px;font-weight:600;color:#666;padding:6px 12px;border-bottom:1px solid #eee;border-top:1px solid #eee;margin-top:4px;">EDGE TREATMENTS</div>
    <div class="edge-menu-item" onclick="setEdgeType('profile')"><div class="dot" style="background:#ff5722;"></div> Profile Edge</div>
    <div class="edge-menu-item" onclick="setEdgeType('dropdown')"><div class="dot" style="background:#9c27b0;"></div> Dropdown (Full)</div>
    <div class="edge-menu-item" onclick="setEdgeType('none')"><div class="dot" style="background:#ccc;"></div> Clear Edge</div>
    
    <div style="font-size:10px;font-weight:600;color:#666;padding:6px 12px;border-bottom:1px solid #eee;border-top:1px solid #eee;margin-top:4px;">WORKTOP SPLITS</div>
    <div class="edge-menu-item" onclick="addWorktopSplit()"><div class="dot" style="background:#ff9800;"></div> Add Split/Join Here</div>
    <div class="edge-menu-item" id="removeSplitOption" style="display:none;" onclick="removeWorktopSplit()"><div class="dot" style="background:#f44336;"></div> Remove Split</div>
  </div>
  
  <!-- Corner Menu for radius -->
  <div class="edge-menu" id="cornerMenu" style="display:none;" onclick="event.stopPropagation();" onmousedown="event.stopPropagation();">
    <div id="cornerMenuTitle" style="font-size:11px;padding:8px 12px;color:#333;background:#f5f5f5;border-bottom:1px solid #eee;"></div>
    <div class="edge-menu-item" id="cornerAddStepout" onclick="showStepoutModalFromCorner()"><div class="dot" style="background:#9c27b0;"></div> Add Stepout (L-Shape)...</div>
    <div class="edge-menu-item" id="cornerEditStepout" style="display:none;" onclick="editStepoutFromCorner()"><div class="dot" style="background:#ff9800;"></div> Edit Stepout...</div>
    <div class="edge-menu-item" id="cornerRemoveStepout" style="display:none;" onclick="removeStepoutFromCorner()"><div class="dot" style="background:#f44336;"></div> Remove Stepout</div>
    <div style="border-top:1px solid #eee;margin-top:4px;"></div>
    <div class="edge-menu-item" id="cornerAddRadius" onclick="addCornerRadius()"><div class="dot" style="background:#2196F3;"></div> Add Radius...</div>
    <div class="edge-menu-item" id="cornerEditRadius" style="display:none;" onclick="editCornerRadius()"><div class="dot" style="background:#ff9800;"></div> Edit Radius...</div>
    <div class="edge-menu-item" id="cornerRemoveRadius" style="display:none;" onclick="removeCornerRadius()"><div class="dot" style="background:#f44336;"></div> Remove Radius</div>
  </div>
  
  <!-- Modal Dialog for Drainer Selection -->
  <div class="modal-overlay" id="drainerModal" style="display:none;">
    <div class="modal-dialog">
      <div class="modal-title">Where do you want the drainer grooves?</div>
      <div class="modal-buttons">
        <button class="modal-btn" onclick="selectDrainerSide('left')">‚¨Ö Left</button>
        <button class="modal-btn" onclick="selectDrainerSide('right')">Right ‚û°</button>
        <button class="modal-btn primary" onclick="selectDrainerSide('both')">‚Üî Both Sides</button>
      </div>
      <div style="margin-top:12px;border-top:1px solid #eee;padding-top:12px;">
        <div style="font-size:12px;color:#666;margin-bottom:8px;">Or choose Recess Drainer (sunken area):</div>
        <div class="modal-buttons">
          <button class="modal-btn" onclick="selectDrainerSide('recess_left')" style="background:#e3f2fd;border-color:#1976d2;color:#1976d2;">‚¨Ö Recess Left</button>
          <button class="modal-btn" onclick="selectDrainerSide('recess_right')" style="background:#e3f2fd;border-color:#1976d2;color:#1976d2;">Recess Right ‚û°</button>
          <button class="modal-btn" onclick="selectDrainerSide('recess_both')" style="background:#e3f2fd;border-color:#1976d2;color:#1976d2;">‚Üî Recess Both</button>
        </div>
      </div>
      <div class="modal-buttons" style="margin-top:12px;">
        <button class="modal-btn" onclick="selectDrainerSide(null)" style="background:#ffebee;border-color:#c62828;color:#c62828;">Cancel</button>
      </div>
    </div>
  </div>
  
  <!-- Modal Dialog for Slab Optimization Warning -->
  <div class="modal-overlay" id="slabOptimizationModal" style="display:none;">
    <div class="modal-dialog" style="max-width:450px;">
      <div class="modal-title" style="background:#fff3e0;color:#e65100;margin:-20px -20px 15px -20px;padding:15px 20px;border-radius:8px 8px 0 0;">
        üí° Save Material Costs!
      </div>
      <div id="slabOptimizationContent" style="margin-bottom:15px;font-size:13px;line-height:1.5;">
        <!-- Content populated by JS -->
      </div>
      <div style="background:#f5f5f5;padding:12px;border-radius:6px;margin-bottom:15px;font-size:12px;">
        <strong>Tip:</strong> Click on the worktop edge and select "Add Split/Join Here" to divide a piece into smaller parts that fit better on the slab.
      </div>
      <div class="modal-buttons">
        <button class="modal-btn primary" onclick="closeSlabOptimizationModal()" style="background:#ff9800;border-color:#e65100;color:white;">Got it!</button>
      </div>
    </div>
  </div>
  
  <!-- Modal Dialog for Socket Size Selection -->
  <div class="modal-overlay" id="socketModal" style="display:none;">
    <div class="modal-dialog">
      <div class="modal-title">Select Socket Cutout Size</div>
      <div class="modal-buttons" style="flex-direction:column;gap:10px;">
        <button class="modal-btn" onclick="selectSocketSize('single')" style="width:100%;padding:12px;">
          <strong>Single Socket</strong><br><span style="font-size:11px;color:#666;">73mm √ó 73mm</span>
        </button>
        <button class="modal-btn" onclick="selectSocketSize('double')" style="width:100%;padding:12px;">
          <strong>Double Socket</strong><br><span style="font-size:11px;color:#666;">133mm √ó 73mm</span>
        </button>
        <button class="modal-btn" onclick="selectSocketSize('custom')" style="width:100%;padding:12px;background:#e3f2fd;border-color:#1976d2;">
          <strong>Custom Size</strong><br><span style="font-size:11px;color:#1976d2;">Enter dimensions</span>
        </button>
      </div>
      <div class="modal-buttons" style="margin-top:12px;">
        <button class="modal-btn" onclick="cancelSocketModal()" style="background:#ffebee;border-color:#c62828;color:#c62828;">Cancel</button>
      </div>
    </div>
  </div>
  
  <!-- Modal Dialog for Stepout Configuration -->
  <div class="modal-overlay" id="stepoutModal" style="display:none;">
    <div class="modal-dialog" style="min-width:340px;">
      <div class="modal-title">Add Stepout (L-Shape)</div>
      <p style="font-size:12px;color:#666;margin-bottom:15px;">Create an L-shaped extension on <strong id="stepoutCornerLabel">this corner</strong></p>
      <input type="hidden" id="stepoutCorner" value="front-left">
      <div style="display:flex;flex-direction:column;gap:12px;">
        <div>
          <label style="font-size:12px;color:#666;display:block;margin-bottom:4px;">Stepout Length (mm)</label>
          <input type="number" id="stepoutLength" value="620" min="100" max="2000" style="width:100%;padding:8px;border:1px solid #ddd;border-radius:4px;font-size:14px;box-sizing:border-box;">
          <span style="font-size:10px;color:#999;">How far along the edge</span>
        </div>
        <div>
          <label style="font-size:12px;color:#666;display:block;margin-bottom:4px;">Stepout Depth (mm)</label>
          <input type="number" id="stepoutDepth" value="100" min="50" max="600" style="width:100%;padding:8px;border:1px solid #ddd;border-radius:4px;font-size:14px;box-sizing:border-box;">
          <span style="font-size:10px;color:#999;">How far it extends outward</span>
        </div>
      </div>
      <div style="background:#e3f2fd;padding:10px;border-radius:6px;margin-top:15px;font-size:11px;color:#1565c0;">
        <strong>‚ÑπÔ∏è Result:</strong> One L-shaped piece with no joint line
      </div>
      <div class="modal-buttons" style="margin-top:15px;">
        <button class="modal-btn" onclick="cancelStepoutModal()" style="background:#ffebee;border-color:#c62828;color:#c62828;">Cancel</button>
        <button class="modal-btn" onclick="confirmStepout()" style="background:#4caf50;border-color:#388e3c;color:white;">Add Stepout</button>
      </div>
    </div>
  </div>
  
  <!-- Modal Dialog for Worktop Size Edit (Double-click) -->
  <div class="modal-overlay" id="worktopEditModal" style="display:none;">
    <div class="modal-dialog" style="min-width:300px;">
      <div class="modal-title" id="worktopEditTitle">Edit Worktop Size</div>
      <div style="padding:12px 0;">
        <div style="display:flex;gap:12px;margin-bottom:12px;">
          <div style="flex:1;">
            <label style="font-size:11px;color:#666;display:block;margin-bottom:4px;">Length ‚Üê ‚Üí (mm)</label>
            <input type="number" id="editWorktopLength" style="width:100%;padding:8px;border:1px solid #ccc;border-radius:4px;font-size:14px;">
          </div>
          <div style="flex:1;">
            <label style="font-size:11px;color:#666;display:block;margin-bottom:4px;">Depth ‚Üë ‚Üì (mm)</label>
            <input type="number" id="editWorktopDepth" style="width:100%;padding:8px;border:1px solid #ccc;border-radius:4px;font-size:14px;">
          </div>
        </div>
        <div style="margin-bottom:12px;">
          <label style="font-size:11px;color:#666;display:block;margin-bottom:4px;">Name</label>
          <input type="text" id="editWorktopName" style="width:100%;padding:8px;border:1px solid #ccc;border-radius:4px;font-size:14px;box-sizing:border-box;">
        </div>
      </div>
      <div class="modal-buttons">
        <button class="modal-btn" onclick="cancelWorktopEdit()" style="background:#ffebee;border-color:#c62828;color:#c62828;">Cancel</button>
        <button class="modal-btn primary" onclick="applyWorktopEdit()" style="background:#1e4d3a;color:white;border-color:#1e4d3a;">Apply</button>
      </div>
    </div>
  </div>

  <!-- Modal Dialog for Upstand Split -->
  <div class="modal-overlay" id="upstandSplitModal" style="display:none;">
    <div class="modal-dialog" style="min-width:350px;">
      <div class="modal-title">‚úÇÔ∏è Split Upstand</div>
      <div style="padding:12px 0;">
        <div style="font-size:12px;color:#666;margin-bottom:12px;" id="upstandSplitInfo">Split this upstand for better material utilization</div>
        
        <!-- Visual representation -->
        <div style="background:#f5f5f5;border-radius:8px;padding:16px;margin-bottom:16px;">
          <div style="position:relative;height:40px;background:linear-gradient(90deg, #a5d6a7 0%, #a5d6a7 100%);border-radius:4px;border:2px solid #4CAF50;" id="upstandSplitVisual">
            <!-- Arrow and split line will be inserted here -->
          </div>
          <div style="display:flex;justify-content:space-between;margin-top:4px;font-size:10px;color:#666;">
            <span>0mm</span>
            <span id="upstandSplitEnd">3000mm</span>
          </div>
        </div>
        
        <div style="display:flex;align-items:center;gap:8px;margin-bottom:12px;">
          <label style="font-size:12px;color:#333;white-space:nowrap;">Split at:</label>
          <input type="number" id="upstandSplitPosition" style="flex:1;padding:10px;border:2px solid #ff9800;border-radius:6px;font-size:16px;font-weight:bold;text-align:center;" oninput="updateSplitPreview()">
          <span style="font-size:12px;color:#666;">mm</span>
        </div>
        
        <div style="display:flex;gap:8px;font-size:11px;color:#666;">
          <div style="flex:1;background:#e8f5e9;padding:8px;border-radius:4px;text-align:center;">
            <div style="color:#2e7d32;font-weight:bold;" id="splitLeftSize">Left: 0mm</div>
          </div>
          <div style="flex:1;background:#e3f2fd;padding:8px;border-radius:4px;text-align:center;">
            <div style="color:#1565c0;font-weight:bold;" id="splitRightSize">Right: 0mm</div>
          </div>
        </div>
        
        <!-- Move Join buttons (shown when adjacent upstands exist) -->
        <div id="moveJoinButtonsContainer" style="display:none;margin-top:12px;padding-top:12px;border-top:1px solid #eee;">
          <div style="font-size:11px;color:#1976d2;margin-bottom:8px;font-weight:600;">üîó Or move existing join:</div>
          <div id="moveJoinButtons"></div>
        </div>
      </div>
      <div class="modal-buttons" style="flex-wrap:wrap;">
        <button class="modal-btn" onclick="deleteUpstandFromModal()" style="background:#ffebee;border-color:#c62828;color:#c62828;">üóëÔ∏è Delete</button>
        <button class="modal-btn" id="addSocketFromModalBtn" onclick="addSocketFromModal()" style="background:#fff3e0;border-color:#ff7043;color:#e64a19;display:none;">üîå Add Socket</button>
        <button class="modal-btn" onclick="cancelUpstandSplit()" style="border-color:#999;color:#666;">Cancel</button>
        <button class="modal-btn primary" onclick="applyUpstandSplit()" style="background:#ff9800;color:white;border-color:#ff9800;">‚úÇÔ∏è Split</button>
      </div>
    </div>
  </div>

  <!-- Modal Dialog for Cill Edit (simple - just size and delete) -->
  <div class="modal-overlay" id="cillEditModal" style="display:none;">
    <div class="modal-dialog" style="min-width:320px;">
      <div class="modal-title">ü™ü Edit Window Cill</div>
      <div style="padding:12px 0;">
        <div style="display:flex;gap:12px;margin-bottom:12px;">
          <div style="flex:1;">
            <label style="font-size:11px;color:#666;display:block;margin-bottom:4px;">Length (mm)</label>
            <input type="number" id="editCillLength" style="width:100%;padding:8px;border:1px solid #ccc;border-radius:4px;font-size:14px;">
          </div>
          <div style="flex:1;">
            <label style="font-size:11px;color:#666;display:block;margin-bottom:4px;">Depth (mm)</label>
            <input type="number" id="editCillDepth" style="width:100%;padding:8px;border:1px solid #ccc;border-radius:4px;font-size:14px;">
          </div>
        </div>
        <div style="margin-bottom:12px;">
          <label style="font-size:11px;color:#666;display:block;margin-bottom:4px;">Height from Worktop (mm)</label>
          <input type="number" id="editCillHeight" style="width:100%;padding:8px;border:1px solid #ccc;border-radius:4px;font-size:14px;">
        </div>
      </div>
      <div class="modal-buttons">
        <button class="modal-btn" onclick="deleteCillFromModal()" style="background:#ffebee;border-color:#c62828;color:#c62828;">üóëÔ∏è Delete</button>
        <button class="modal-btn" onclick="cancelCillEdit()" style="border-color:#999;color:#666;">Cancel</button>
        <button class="modal-btn primary" onclick="applyCillEdit()">Apply</button>
      </div>
    </div>
  </div>

  <!-- Modal Dialog for Edge Profile Selection -->
  <div class="modal-overlay" id="profileModal" style="display:none;">
    <div class="modal-dialog" style="min-width:400px;max-width:500px;">
      <div class="modal-title">Select Edge Profile</div>
      <div id="profileOptions" style="display:flex;flex-direction:column;gap:8px;max-height:400px;overflow-y:auto;padding:4px;">
        <!-- Options populated by JavaScript -->
      </div>
      <div style="margin-top:12px;padding-top:12px;border-top:1px solid #eee;font-size:11px;color:#666;">
        <span id="profileThicknessNote">Available profiles depend on worktop thickness (currently 30mm)</span>
      </div>
      <div class="modal-buttons" style="margin-top:12px;">
        <button class="modal-btn" onclick="cancelProfileSelection()" style="background:#ffebee;border-color:#c62828;color:#c62828;">Cancel</button>
      </div>
    </div>
  </div>

  <!-- Modal Dialog for Material Color Selection -->
  <div class="modal-overlay" id="materialModal" style="display:none;">
    <div class="modal-dialog" style="min-width:900px;max-width:1100px;max-height:90vh;display:flex;flex-direction:column;overflow:hidden;">
      <!-- Fixed Header -->
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;flex-shrink:0;">
        <div class="modal-title" style="margin:0;">Select Material</div>
        <button onclick="closeMaterialModal()" style="background:none;border:none;font-size:24px;cursor:pointer;color:#666;padding:0 8px;" title="Close">√ó</button>
      </div>
      
      <!-- Scrollable Content Area -->
      <div style="flex:1;overflow-y:auto;min-height:0;">
        <!-- Brand Logos with Badges -->
        <div style="margin-bottom:12px;">
          <label style="font-size:10px;color:#666;display:block;margin-bottom:6px;">Select Brand</label>
          <div id="brandLogos" style="display:flex;gap:6px;flex-wrap:wrap;align-items:stretch;">
            <div onclick="setBrandFilter('all')" class="brand-logo-btn" id="brandAll" data-brand="all" style="width:80px;height:80px;border:2px solid #1e4d3a;border-radius:8px;cursor:pointer;background:#e8f5e9;display:flex;align-items:center;justify-content:center;font-size:11px;font-weight:600;text-align:center;">All<br>Brands</div>
            <div onclick="setBrandFilter('MOD')" class="brand-logo-btn" data-brand="MOD" style="width:80px;height:80px;border:2px solid #ddd;border-radius:8px;cursor:pointer;background:white;display:flex;flex-direction:column;align-items:center;justify-content:center;position:relative;" title="Modern Quartz">
              <img src="https://lh3.googleusercontent.com/d/1XwYv2zR9YlAXFLaPe22Cz2WsX62sBjA0=s200" style="max-height:45px;max-width:70px;object-fit:contain;">
              <span style="position:absolute;top:-8px;right:-8px;background:#4CAF50;color:white;font-size:8px;padding:3px 6px;border-radius:4px;font-weight:700;">BEST VALUE</span>
            </div>
            <div onclick="setBrandFilter('SIL')" class="brand-logo-btn" data-brand="SIL" style="width:80px;height:80px;border:2px solid #ddd;border-radius:8px;cursor:pointer;background:white;display:flex;flex-direction:column;align-items:center;justify-content:center;position:relative;" title="Silestone">
              <img src="https://lh3.googleusercontent.com/d/127k2DZSGjdqXDF4W5KAyNgFAlB6NKj6M=s200" style="max-height:45px;max-width:70px;object-fit:contain;">
              <span style="position:absolute;top:-8px;right:-8px;background:#9c27b0;color:white;font-size:8px;padding:3px 6px;border-radius:4px;font-weight:700;">PREMIUM</span>
            </div>
            <div onclick="setBrandFilter('DEK')" class="brand-logo-btn" data-brand="DEK" style="width:80px;height:80px;border:2px solid #ddd;border-radius:8px;cursor:pointer;background:white;display:flex;flex-direction:column;align-items:center;justify-content:center;position:relative;" title="Dekton">
              <img src="https://lh3.googleusercontent.com/d/1EK1_qmmYeEAGPNFIKmXilJ99bTNrAhDl=s200" style="max-height:45px;max-width:70px;object-fit:contain;">
              <span style="position:absolute;top:-8px;right:-8px;background:#9c27b0;color:white;font-size:8px;padding:3px 6px;border-radius:4px;font-weight:700;">PREMIUM</span>
            </div>
            <div onclick="setBrandFilter('COS')" class="brand-logo-btn" data-brand="COS" style="width:80px;height:80px;border:2px solid #ddd;border-radius:8px;cursor:pointer;background:white;display:flex;flex-direction:column;align-items:center;justify-content:center;position:relative;" title="Cosy Stone">
              <img src="https://lh3.googleusercontent.com/d/1aFIsbX9EujOD8hiHql6DlIBNXKFl0cmy=s200" style="max-height:45px;max-width:70px;object-fit:contain;">
              <span style="position:absolute;top:-8px;right:-8px;background:#4CAF50;color:white;font-size:8px;padding:3px 6px;border-radius:4px;font-weight:700;">BEST VALUE</span>
            </div>
            <div onclick="setBrandFilter('GLO')" class="brand-logo-btn" data-brand="GLO" style="width:80px;height:80px;border:2px solid #ddd;border-radius:8px;cursor:pointer;background:white;display:flex;flex-direction:column;align-items:center;justify-content:center;" title="Global Granite">
              <img src="https://lh3.googleusercontent.com/d/14ZsCCuxLnjCcVaWM0LA5O0n9Pkva4cYq=s200" style="max-height:45px;max-width:70px;object-fit:contain;">
            </div>
            <div onclick="setBrandFilter('CQS')" class="brand-logo-btn" data-brand="CQS" style="width:80px;height:80px;border:2px solid #ddd;border-radius:8px;cursor:pointer;background:white;display:flex;flex-direction:column;align-items:center;justify-content:center;" title="Classic Quartz">
              <img src="https://lh3.googleusercontent.com/d/1q_3OAIMDWym_zBMhqwFtdaBhFKpihsKl=s200" style="max-height:45px;max-width:70px;object-fit:contain;">
            </div>
            <div onclick="setBrandFilter('ART')" class="brand-logo-btn" data-brand="ART" style="width:80px;height:80px;border:2px solid #ddd;border-radius:8px;cursor:pointer;background:white;display:flex;flex-direction:column;align-items:center;justify-content:center;" title="Artemis Stone">
              <img src="https://lh3.googleusercontent.com/d/1C9xFaHbZk5n0hcSxqFOk8SBxxCeTP1i_=s200" style="max-height:45px;max-width:70px;object-fit:contain;">
            </div>
            <div onclick="setBrandFilter('NLQ')" class="brand-logo-btn" data-brand="NLQ" style="width:80px;height:80px;border:2px solid #ddd;border-radius:8px;cursor:pointer;background:white;display:flex;flex-direction:column;align-items:center;justify-content:center;" title="Nile Quartz">
              <img src="https://lh3.googleusercontent.com/d/1IrrKv95yNFfcdymhXryhlzj1DKJzK5fG=s200" style="max-height:45px;max-width:70px;object-fit:contain;">
            </div>
            <div onclick="setBrandFilter('NAT')" class="brand-logo-btn" data-brand="NAT" style="width:80px;height:80px;border:2px solid #ddd;border-radius:8px;cursor:pointer;background:white;display:flex;flex-direction:column;align-items:center;justify-content:center;" title="Natural Stone">
              <img src="https://lh3.googleusercontent.com/d/1mdHLk0qRIDBt4EGneLpPLi3iA8vpk_Fw=s200" style="max-height:45px;max-width:70px;object-fit:contain;">
            </div>
            <div onclick="setBrandFilter('HOR')" class="brand-logo-btn" data-brand="HOR" style="width:80px;height:80px;border:2px solid #ddd;border-radius:8px;cursor:pointer;background:white;display:flex;flex-direction:column;align-items:center;justify-content:center;" title="Horizon Stone">
              <img src="https://lh3.googleusercontent.com/d/1J6p-NlkoyZ5WKS8nxF5Pgz4IQ6fQ0M1l=s200" style="max-height:45px;max-width:70px;object-fit:contain;">
            </div>
            <div onclick="setBrandFilter('HSP')" class="brand-logo-btn" data-brand="HSP" style="width:80px;height:80px;border:2px solid #ddd;border-radius:8px;cursor:pointer;background:white;display:flex;flex-direction:column;align-items:center;justify-content:center;" title="Horizon Porcelain">
              <img src="https://lh3.googleusercontent.com/d/1J6p-NlkoyZ5WKS8nxF5Pgz4IQ6fQ0M1l=s200" style="max-height:40px;max-width:65px;object-fit:contain;">
              <span style="font-size:8px;color:#666;margin-top:2px;">PORCELAIN</span>
            </div>
          </div>
        </div>
        
        <!-- Thickness AND Tier Filter - SIDE BY SIDE -->
        <div style="display:flex;gap:24px;margin-bottom:12px;flex-wrap:wrap;align-items:flex-start;">
          <!-- Thickness -->
          <div>
            <label style="font-size:10px;color:#666;display:block;margin-bottom:4px;">Thickness</label>
            <div style="display:flex;gap:4px;">
              <button id="thick20" onclick="setThickness(20)" class="thickness-btn" style="padding:8px 16px;border:2px solid #1e4d3a;border-radius:6px;background:#e8f5e9;cursor:pointer;font-size:13px;font-weight:600;">20mm</button>
              <button id="thick30" onclick="setThickness(30)" class="thickness-btn" style="padding:8px 16px;border:2px solid #ccc;border-radius:6px;background:white;cursor:pointer;font-size:13px;">30mm</button>
            </div>
          </div>
          
          <!-- Tier Filter - Color coded pills -->
          <div>
            <label style="font-size:10px;color:#666;display:block;margin-bottom:4px;">Filter by Price Tier</label>
            <div id="tierFilterButtons" style="display:flex;gap:4px;flex-wrap:wrap;">
              <!-- Populated by updateTierFilterButtons() -->
            </div>
          </div>
        </div>
        
        <!-- Search -->
        <div style="margin-bottom:12px;display:flex;gap:12px;align-items:center;">
          <input type="text" id="materialSearch" placeholder="Search materials..." style="flex:1;padding:8px 12px;border:1px solid #ccc;border-radius:6px;font-size:14px;box-sizing:border-box;" oninput="filterMaterialsNew()">
          <div style="display:flex;align-items:center;gap:8px;background:#e8f5e9;padding:6px 12px;border-radius:6px;border:1px solid #4CAF50;">
            <span id="pricingLoadStatus" style="font-size:11px;color:#2e7d32;font-weight:500;">Loading...</span>
            <input type="file" id="pricingJsonInput" accept=".json" onchange="loadPricingJSON(this)" style="font-size:10px;max-width:120px;" title="Override with different JSON">
          </div>
        </div>
        
        <div id="materialCount" style="font-size:11px;color:#666;margin-bottom:8px;">Showing 84 materials</div>
        
        <!-- Material Grid - 4 columns, bigger tiles -->
        <div id="materialGrid" style="display:grid;grid-template-columns:repeat(4,1fr);gap:12px;padding:10px 0;min-height:200px;">
          <!-- Populated by JavaScript -->
        </div>
      </div>
      
      <!-- Fixed Bottom Bar - Selected Material Preview with Buttons -->
      <div id="selectedMaterialBar" style="margin-top:12px;padding:14px;background:linear-gradient(135deg, #e8f5e9 0%, #f1f8e9 100%);border-radius:10px;display:none;border:2px solid #4CAF50;flex-shrink:0;position:relative;">
        <div style="display:flex;align-items:center;gap:16px;">
          <div id="selectedMatThumb" style="width:80px;height:80px;border-radius:8px;border:2px solid #4CAF50;background-size:cover;background-position:center;box-shadow:0 2px 8px rgba(0,0,0,0.15);"></div>
          <div style="flex:1;">
            <div style="font-size:10px;color:#666;text-transform:uppercase;margin-bottom:2px;">Selected Material</div>
            <div id="selectedMatName" style="font-weight:700;font-size:18px;color:#1e4d3a;"></div>
            <div style="display:flex;gap:12px;margin-top:4px;">
              <div id="selectedMatBrand" style="font-size:12px;color:#666;"></div>
              <div id="selectedMatThickness" style="font-size:12px;color:#666;font-weight:600;"></div>
              <div id="selectedMatPrice" style="font-size:12px;font-weight:600;"></div>
            </div>
          </div>
          <div id="selectedMatTier" style="font-size:24px;font-weight:700;"></div>
          <div style="display:flex;gap:8px;margin-left:16px;">
            <button onclick="clearMaterialSelection()" style="background:#ffebee;border:2px solid #c62828;color:#c62828;padding:10px 20px;border-radius:6px;cursor:pointer;font-size:13px;font-weight:600;">Clear Selection</button>
            <button id="confirmMaterialBtn" onclick="confirmMaterial()" style="background:#4CAF50;border:2px solid #388E3C;color:white;padding:10px 24px;border-radius:6px;cursor:pointer;font-size:13px;font-weight:600;">OK - Use This Material</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Modal Dialog for Cutout Edit (Sinks, Hobs, Drainers) -->
  <div class="modal-overlay" id="cutoutEditModal" style="display:none;">
    <div class="modal-dialog" style="min-width:350px;">
      <div class="modal-title" id="cutoutEditTitle">Edit Cutout</div>
      <div id="cutoutEditContent" style="padding:12px 0;">
        <!-- Populated by JavaScript -->
      </div>
      <div class="modal-buttons" style="margin-top:12px;">
        <button class="modal-btn" onclick="closeCutoutEditModal()" style="background:#f5f5f5;border-color:#999;color:#666;">Cancel</button>
        <button class="modal-btn primary" onclick="applyCutoutEdit()">Apply Changes</button>
      </div>
      <div style="margin-top:12px;border-top:1px solid #eee;padding-top:12px;">
        <button onclick="deleteCutoutFromModal()" style="width:100%;padding:10px;background:#ffebee;border:2px solid #c62828;color:#c62828;border-radius:6px;cursor:pointer;font-size:13px;font-weight:600;">üóëÔ∏è Delete This Cutout</button>
      </div>
    </div>
  </div>

<script>
// ========== CONSTANTS ==========
const SLAB_W = 3200, SLAB_H = 1600, EFFICIENCY = 0.70;
let worktopThickness = 20; // Default 20mm, can be 20mm or 30mm
const SNAP_DIST = 30;
const EDGE_CLICK_DIST = 30; // Edge clicking tolerance (mm)

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  PRICING CONFIGURATION - EASY TO UPDATE  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// FABRICATION PRICES BY MATERIAL TYPE
// These are the all-inclusive prices shown to customers
const FABRICATION_PRICES = {
  quartz: {
    firstSlab: 1300,           // First slab fixed profit
    additionalSlabPerSqFt: 12.50, // ¬£12.50 per sq ft of pieces on additional slabs
    brands: ['SIL', 'MOD', 'GLO', 'COS', 'CQS', 'ART', 'NLQ', 'HOR']  // Silestone, Modern, Global, Cosy, Classic, Artemis, Nile, Horizon
  },
  dekton: {
    firstSlab: 1700,           // First slab fixed profit (harder to work)
    additionalSlabPerSqFt: 12.50, // ¬£12.50 per sq ft of pieces on additional slabs
    brands: ['DEK']            // Dekton only
  },
  porcelain: {
    firstSlab: 1700,           // First slab fixed profit
    additionalSlabPerSqFt: 12.50, // ¬£12.50 per sq ft of pieces on additional slabs
    brands: ['HSP']            // Horizon Stone Porcelain
  },
  natural_stone: {
    firstSlab: 1800,           // First slab fixed profit (Granite & Quartzite)
    additionalSlabPerSqFt: 12.50, // ¬£12.50 per sq ft of pieces on additional slabs
    brands: ['NAT']            // Natural Stone
  }
};

// WHAT'S INCLUDED IN BASE PRICE
// These items are included - removing them gives credit, adding extras costs more
const INCLUDED_IN_BASE = {
  sinks: 1,           // 1 undermount sink included
  hobs: 1,            // 1 hob cutout included
  drainers: 1,        // 1 drainer grooves included
  taps: 1,            // 1 tap hole included
  edgeProfile: ['chamfer', 'pencil']  // Standard edges included free
};

// CUTOUT PRICING
// Base prices for cutouts - used for extras and credits
const CUTOUT_PRICES = {
  undermount_sink: { name: 'Undermount Sink Cutout', price: 110, credit: 55 },   // Full price to add, half back if removed
  overmount_sink: { name: 'Overmount Sink Cutout', price: 55, credit: 27.50 },
  hob: { name: 'Hob Cutout', price: 55, credit: 27.50 },
  recess_hob: { name: 'Recess Hob', price: 125, credit: 62.50 },
  tap: { name: 'Tap Hole', price: 9.17, credit: 4.58 },
  drainer: { name: 'Drainer Grooves', price: 110, credit: 55 },
  recess_drainer: { name: 'Recess Drainer', price: 330, credit: 165 },
  socket: { name: 'Socket Cutout', price: 35, credit: 17.50 }
};

// EDGE PROFILE PRICING
// Chamfer & Pencil are included free, others are upgrades
const EDGE_PROFILES = {
  chamfer: { name: 'Chamfer', price: 0, thickness: [20, 30], image: '1wHMJPsK5RJaRPHQnyP7nikWOrHoKUiz3', color: '#e91e63' },
  pencil: { name: 'Pencil', price: 0, thickness: [20, 30], image: '1WZUd1Bn5aw3zPSdZxaOQ-wghh0YyTKu-', color: '#9c27b0' },
  shark_nose: { name: 'Shark Nose', price: 55.83, thickness: [20], image: '1pzHGu-61-7fEgdu0DHrqctomL-Lh_Br5', color: '#673ab7' },
  demi_bullnose: { name: 'Demi Bullnose', price: 66.67, thickness: [30], image: '1pOX3py3Qd70E5vKZI_MvbXivYMP5hKii', color: '#2196f3' },
  bullnose: { name: 'Bullnose', price: 66.67, thickness: [30], image: '1OWkH3EO0kFuDlPnRRcK3hSOcGzfaPMmo', color: '#00bcd4' },
  ogee: { name: 'Ogee', price: 66.67, thickness: [30], image: '1AGE-4kN1wCRBQM97wiaf5val2sfqKlIq', color: '#ff9800' },
  mitred_edge: { name: 'Mitred Edge', price: 66.67, thickness: [20, 30], image: null, color: '#795548' }
};

// Helper function to get fabrication price based on material brand
function getFabricationPrices(brandCode) {
  // Check for admin overrides first
  const profit1stEl = document.getElementById('profit1stSlab');
  const profitAddEl = document.getElementById('profitAddSlab');
  
  // If admin has set custom values, use those
  if (profit1stEl && profitAddEl) {
    const customFirst = parseFloat(profit1stEl.value);
    const customAdd = parseFloat(profitAddEl.value);
    
    // Check if values differ from defaults (meaning admin changed them)
    // We'll use a flag to track if admin has manually edited
    if (profit1stEl.dataset.manuallySet === 'true' || profitAddEl.dataset.manuallySet === 'true') {
      return { firstSlab: customFirst || 1300, additionalSlabPerSqFt: customAdd || 12.50, type: 'custom' };
    }
  }
  
  for (const [type, config] of Object.entries(FABRICATION_PRICES)) {
    if (config.brands.includes(brandCode)) {
      return { firstSlab: config.firstSlab, additionalSlabPerSqFt: config.additionalSlabPerSqFt, type: type };
    }
  }
  // Default to quartz if brand not found
  return { firstSlab: FABRICATION_PRICES.quartz.firstSlab, additionalSlabPerSqFt: FABRICATION_PRICES.quartz.additionalSlabPerSqFt, type: 'quartz' };
}

// Track when admin manually edits profit settings
document.addEventListener('DOMContentLoaded', function() {
  setTimeout(() => {
    const profit1stEl = document.getElementById('profit1stSlab');
    const profitAddEl = document.getElementById('profitAddSlab');
    if (profit1stEl) {
      profit1stEl.addEventListener('input', function() {
        this.dataset.manuallySet = 'true';
        renderSlabLayout();
      });
    }
    if (profitAddEl) {
      profitAddEl.addEventListener('input', function() {
        this.dataset.manuallySet = 'true';
        renderSlabLayout();
      });
    }
  }, 100);
});

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// END OF PRICING CONFIGURATION
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// Cutout images from Google Drive
const CUTOUT_IMAGES = {
  drainer: '1OkNW1HvAOABRG2XpeC6W379L4H0WZxIP',
  hob: '17sdiphAm7KDwJRH664cZcD-UWDSyHmxX',
  recess_drainer: '1OSIPISfbNNVm14SIy1Z_bhc7tF3Bx0pO',
  recess_hob: '1V99gR1cZdTa2wvSU8vEEc_0GZ5ISaQaW',
  sink: '1vKV4RkYHmwsVzlnEtXvH0woSjQ5FYcZ6',
  tap: '17-G19NoJACgypg3TUtDrUFb6pKdRDhF9'
};

// ========== MATERIAL COLORS ==========
// Texture crop settings per brand (remove borders/text from images)
// 20% crop means: show center 60% of image (100% - 20% - 20%)
const TEXTURE_CROP_CONFIG = {
  'SIL': { crop: 0, offset: 0, repeat: 1 },       // Silestone - clean images, no crop
  'GLO': { crop: 0.20, offset: 0.20, repeat: 0.60 }, // Global - 20% crop
  'MOD': { crop: 0.20, offset: 0.20, repeat: 0.60 }, // Modern Quartz - 20% crop
  'ART': { crop: 0.20, offset: 0.20, repeat: 0.60 }, // Artemis - 20% crop (has border)
  'NAT': { crop: 0.20, offset: 0.20, repeat: 0.60 }, // Natural Stone - 20% crop (watermark)
  'CQS': { crop: 0.20, offset: 0.20, repeat: 0.60 }, // Classic Quartz - 20% crop (watermark)
  'COS': { crop: 0, offset: 0, repeat: 1 },       // Cosy Stone - clean images
  'DEK': { crop: 0, offset: 0, repeat: 1 },       // Dekton - clean images
  'default': { crop: 0, offset: 0, repeat: 1 }    // Default - no crop
};

// Material-specific crop overrides (for materials that need different zoom than their brand default)
const MATERIAL_CROP_OVERRIDE = {
  'mod_tajmahal_leather': { crop: 0.35, offset: 0.35, repeat: 0.30 },  // Taj Mahal Leather - zoom in more to hide border
  'mod_calacattaviola': { crop: 0.35, offset: 0.35, repeat: 0.30 }     // Calacatta Viola - zoom in more to hide border
};

const MATERIAL_COLORS = {
  // Silestone Collection - 84 materials (brand: 'SIL')
  ariel: { name: 'Ariel', color: 0xe8e8e8, css: '#e8e8e8', cssSelected: '#d0d0d0', roughness: 0.15, textureId: '1aKMbFb_Qmnfsy9K2zyK1SYbEIyp_XUi_' },
  biancocalacatta: { name: 'Bianco Calacatta', color: 0xf5f5f5, css: '#f5f5f5', cssSelected: '#e5e5e5', roughness: 0.12, textureId: '10zhx_h0upRB9IUNloQF1MrEpH5Cc6Zf3' },
  blanclyse: { name: 'Blanc Lys E', color: 0xfafafa, css: '#fafafa', cssSelected: '#eaeaea', roughness: 0.12, textureId: '1UliF8BRzgxZMNVWfYb_NPj1guUB30-P6' },
  blancocity: { name: 'Blanco City', color: 0xf0f0f0, css: '#f0f0f0', cssSelected: '#e0e0e0', roughness: 0.15, textureId: '1bZPIHudsFy2U7b70INKjOCo6Pwab2nRp' },
  blancomaple: { name: 'Blanco Maple', color: 0xf5f2e8, css: '#f5f2e8', cssSelected: '#e5e2d8', roughness: 0.15, textureId: '1HFjlPPEvEO4HJsHsbfgIr3FFD0geB5sl' },
  blanconorte14: { name: 'Blanco Norte', color: 0xf8f8f8, css: '#f8f8f8', cssSelected: '#e8e8e8', roughness: 0.12, textureId: '1EejWBH1RDvq337uClt1uPmggSSbrBOUp' },
  blancoorion: { name: 'Blanco Orion', color: 0xececec, css: '#ececec', cssSelected: '#dcdcdc', roughness: 0.15, textureId: '1AbqOn2AVIlytdaAuF0glkHuaBZZAlN73' },
  bohemianflame: { name: 'Bohemian Flame', color: 0x8b6e5a, css: '#8b6e5a', cssSelected: '#7b5e4a', roughness: 0.2, textureId: '1VL_aRDj-UNuBQ6Dfz4VOehS9WnUhiyyP' },
  brassrelish: { name: 'Brass Relish', color: 0xc9a867, css: '#c9a867', cssSelected: '#b99857', roughness: 0.18, textureId: '1HhLkA9IowFlWNKjNY48O2cFs7n94c8Kt' },
  bronzerivers: { name: 'Bronze Rivers', color: 0x8b7355, css: '#8b7355', cssSelected: '#7b6345', roughness: 0.2, textureId: '18F8qmeIKvBWF00_WJixtKq84Y1BWin4s' },
  calablue: { name: 'Cala Blue', color: 0x5a7a8a, css: '#5a7a8a', cssSelected: '#4a6a7a', roughness: 0.18, textureId: '1RlpqCWrJhmUw8V5FR-KjhAiwoklbn-YO' },
  calacattathemis: { name: 'Calacatta Themis', color: 0xf0ebe5, css: '#f0ebe5', cssSelected: '#e0dbd5', roughness: 0.12, textureId: '1KVXAxYY1faLcMfDotV65E51QytIgdsL_' },
  calacattatova: { name: 'Calacatta Tova', color: 0xf5f0e8, css: '#f5f0e8', cssSelected: '#e5e0d8', roughness: 0.12, textureId: '1XnvtzhpocaOS0g7o_FKX_5V9txY1IGzW' },
  calypso: { name: 'Calypso', color: 0xd0c8b8, css: '#d0c8b8', cssSelected: '#c0b8a8', roughness: 0.18, textureId: '1ij2P4kY_5rkhKJmti2hBiaredbyXj4Et' },
  camden: { name: 'Camden', color: 0x6a6a6a, css: '#6a6a6a', cssSelected: '#5a5a5a', roughness: 0.2, textureId: '1sMx4zf8G6GeXQ48X_SAPxTrFTL7zDCOC' },
  chteaubrown: { name: 'Ch√¢teau Brown', color: 0x5a4a3a, css: '#5a4a3a', cssSelected: '#4a3a2a', roughness: 0.22, textureId: '12UcJAiamFAssTVtZYak6Aczmlyj3AhXV' },
  charcoalsoapstone: { name: 'Charcoal Soapstone', color: 0x4a4a4a, css: '#6a6a6a', cssSelected: '#5a5a5a', roughness: 0.25, textureId: '1z8xXEetzll5_cCmnaHP-5kA3G3D6Kg8R' },
  cincelgrey: { name: 'Cincel Grey', color: 0x8a8a8a, css: '#8a8a8a', cssSelected: '#7a7a7a', roughness: 0.2, textureId: '13oRIXgqj4ksCNFTLYL1776sCQF_BXOAj' },
  cindercraze: { name: 'Cinder Craze', color: 0x7a7a7a, css: '#7a7a7a', cssSelected: '#6a6a6a', roughness: 0.22, textureId: '1i71Zq0AX8Jj6rVbmcbLZtwlLwBvYPZMU' },
  classiccalacatta: { name: 'Classic Calacatta', color: 0xfaf8f5, css: '#faf8f5', cssSelected: '#eae8e5', roughness: 0.1, textureId: '1NqF2wC-pcRo3_w4-T9mguC4Vj3DemLHU' },
  concretepulse: { name: 'Concrete Pulse', color: 0x9a9a9a, css: '#9a9a9a', cssSelected: '#8a8a8a', roughness: 0.25, textureId: '1zYxjfY7_2R0lJOY1lgJar9_VOXfGHQSK' },
  coppermist: { name: 'Copper Mist', color: 0xb88a6a, css: '#b88a6a', cssSelected: '#a87a5a', roughness: 0.2, textureId: '14dOK3EVn3dqeQ7PRkY1Y3BAnwHqin3NA' },
  coralclaycolour: { name: 'Coral Clay', color: 0xd4a88a, css: '#d4a88a', cssSelected: '#c4987a', roughness: 0.18, textureId: '1bQ6Uu5_kc5QVPNwlEJcZaQI2PG6k8W_q' },
  corktown: { name: 'Corktown', color: 0xa8a090, css: '#a8a090', cssSelected: '#989080', roughness: 0.2, textureId: '12DO4CLJcqPqPRSyUGzJgXFzy8zsjv1JA' },
  desertsilver: { name: 'Desert Silver', color: 0xb8b0a0, css: '#b8b0a0', cssSelected: '#a8a090', roughness: 0.18, textureId: '1hJvflDt90efgXhWem8zJtMMIX8diRD5p' },
  eclecticpearl: { name: 'Eclectic Pearl', color: 0xe8e0d8, css: '#e8e0d8', cssSelected: '#d8d0c8', roughness: 0.15, textureId: '12sxyqRhcCibWjeYZaRLwbhUAbUHI3Nba' },
  etbella: { name: 'Et. Bella', color: 0xf0e8e0, css: '#f0e8e0', cssSelected: '#e0d8d0', roughness: 0.12, textureId: '1QOxaKcUlC0goe_P87BLXOYN3mOhRgiex' },
  etcalacattagold: { name: 'Et. Calacatta Gold', color: 0xf5f0e5, css: '#f5f0e5', cssSelected: '#e5e0d5', roughness: 0.1, textureId: '1IrBJF4kpHbrcNqaWsb-hQuO9dpZXpcOF' },
  etdor: { name: 'Et. Dor', color: 0xe8dcc8, css: '#e8dcc8', cssSelected: '#d8ccb8', roughness: 0.12, textureId: '1nceHGTyy5Im6Vp9aShWz1xbkrS2xMoAX' },
  etmarfil: { name: 'Et. Marfil', color: 0xf0e8d8, css: '#f0e8d8', cssSelected: '#e0d8c8', roughness: 0.12, textureId: '1HNaMSulVyZSoWRXL6pVZxoinHUO2m4Rf' },
  etmarquina: { name: 'Et. Marquina', color: 0x2a2a2a, css: '#3a3a3a', cssSelected: '#2a2a2a', roughness: 0.1, textureId: '1Iw_XU4DBdACq4T0b1-dYjy3DGSgfnc0P' },
  etnoir: { name: 'Et. Noir', color: 0x1a1a1a, css: '#2a2a2a', cssSelected: '#1a1a1a', roughness: 0.1, textureId: '1bZm93JhVJtG3nJ1x5tTEtrGv8GX3XIAk' },
  etstatuario: { name: 'Et. Statuario', color: 0xfaf8f5, css: '#faf8f5', cssSelected: '#eae8e5', roughness: 0.1, textureId: '1xcQjgPMq7Oc701IqhhTk6ypOOAskjxte' },
  etherealdusk: { name: 'Ethereal Dusk', color: 0x7a6a5a, css: '#7a6a5a', cssSelected: '#6a5a4a', roughness: 0.18, textureId: '1AuncByujpuV1f56CkMshQDXAZ7Jx_WSu' },
  etherealglow: { name: 'Ethereal Glow', color: 0xf0e8e0, css: '#f0e8e0', cssSelected: '#e0d8d0', roughness: 0.12, textureId: '1gmrtRTcMxGGT8oUYFlq1tW6dcXs1pNxE' },
  etherealhaze: { name: 'Ethereal Haze', color: 0xd0c8c0, css: '#d0c8c0', cssSelected: '#c0b8b0', roughness: 0.15, textureId: '1IfdVpkv1JCMVjlHianWjeXfqzpkHuwtH' },
  etherealindigo: { name: 'Ethereal Indigo', color: 0x4a5a6a, css: '#4a5a6a', cssSelected: '#3a4a5a', roughness: 0.18, textureId: '17zvam8_wRLz7zVsGHT4FlxQ2uqHaGoAQ' },
  etherealnoctis: { name: 'Ethereal Noctis', color: 0x3a3a4a, css: '#3a3a4a', cssSelected: '#2a2a3a', roughness: 0.18, textureId: '17p7dKUd_wL6J32KDs3lBANGYmyQyDdO4' },
  farowhite: { name: 'Faro White', color: 0xf8f8f8, css: '#f8f8f8', cssSelected: '#e8e8e8', roughness: 0.12, textureId: '1szThkGOWeIP0lvMPYgQaQcFMQFA5SUNw' },
  ffrom01: { name: 'Ffrom 01', color: 0xe0d8d0, css: '#e0d8d0', cssSelected: '#d0c8c0', roughness: 0.18, textureId: '1xr81KvKURoCLmmPDCL6rZYvafgnc0vHk' },
  ffrom02: { name: 'Ffrom 02', color: 0xd8d0c8, css: '#d8d0c8', cssSelected: '#c8c0b8', roughness: 0.18, textureId: '1-v0fyU72StM1LVHuw8Z58M4sFG7k0xR3' },
  ffrom03: { name: 'Ffrom 03', color: 0xd0c8c0, css: '#d0c8c0', cssSelected: '#c0b8b0', roughness: 0.18, textureId: '1p0YSWYlQP63jcF6aRtQlWtLzddJjNMQM' },
  grisexpo: { name: 'Gris Expo', color: 0x8a8a8a, css: '#8a8a8a', cssSelected: '#7a7a7a', roughness: 0.2, textureId: '1C6Xn4T14N0AxoL2yRAWP0kLhZMk85uDZ' },
  halcyon: { name: 'Halcyon', color: 0x5a6a7a, css: '#5a6a7a', cssSelected: '#4a5a6a', roughness: 0.18, textureId: '197B0eRpAQrP_tGS4ltwYQtsG6s-UNkKD' },
  helix: { name: 'Helix', color: 0xa0a0a0, css: '#a0a0a0', cssSelected: '#909090', roughness: 0.2, textureId: '1jYGJnAkcsnTJnd7bbwjogfT0vYX-Iiy6' },
  jardinemerald: { name: 'Jardin Emerald', color: 0x3a5a4a, css: '#3a5a4a', cssSelected: '#2a4a3a', roughness: 0.2, textureId: '1S00gLT5UhlomACw1Jk1Q2qUGEq4wd2PV' },
  lagoon: { name: 'Lagoon', color: 0x4a7a8a, css: '#4a7a8a', cssSelected: '#3a6a7a', roughness: 0.18, textureId: '12RPxEtdZ3-S8-MN-vcapKXb8ReLXaX8g' },
  limedelight: { name: 'Lime Delight', color: 0xc8d8a0, css: '#c8d8a0', cssSelected: '#b8c890', roughness: 0.18, textureId: '1A4fF0RnvQ_vncXFuG59ct38D8dciS6gH' },
  linencream: { name: 'Linen Cream', color: 0xf0e8d8, css: '#f0e8d8', cssSelected: '#e0d8c8', roughness: 0.15, textureId: '1s_gzFZU0AgQkRFug6689-0d0dwi6Shqu' },
  lusso: { name: 'Lusso', color: 0xf0ebe5, css: '#f0ebe5', cssSelected: '#e0dbd5', roughness: 0.12, textureId: '1ApT8Ufh__rB69ev94JyGEUCHCxNbIXbR' },
  lyra: { name: 'Lyra', color: 0xd0c0a8, css: '#d0c0a8', cssSelected: '#c0b098', roughness: 0.2, textureId: '155lYUIa6k3M5orPsAoRPw_vICKhecNdN' },
  marengo: { name: 'Marengo', color: 0x5a5a5a, css: '#5a5a5a', cssSelected: '#4a4a4a', roughness: 0.22, textureId: '1r2m9sjHr4rcfFbCrNlTYgPe4vn6rObTC' },
  miamioro: { name: 'Miami Oro', color: 0xd8c8a8, css: '#d8c8a8', cssSelected: '#c8b898', roughness: 0.15, textureId: '1cnJv_E_s6hdwTRrXRMEuYbM4--TqmxA9' },
  miamivena: { name: 'Miami Vena', color: 0xe8e0d8, css: '#e8e0d8', cssSelected: '#d8d0c8', roughness: 0.12, textureId: '1E5H7PJQ2hqMgR_Cwz2d0d3qbraIf7V2-' },
  miamiwhite: { name: 'Miami White', color: 0xf8f5f0, css: '#f8f5f0', cssSelected: '#e8e5e0', roughness: 0.1, textureId: '1mRwdzd4So8vmjTWA1AiXCd3CEtPDIhGU' },
  motiongrey: { name: 'Motion Grey', color: 0x9a9a9a, css: '#9a9a9a', cssSelected: '#8a8a8a', roughness: 0.2, textureId: '1CcHPiDKWIuJRPapR_-XD_8BlG5jgU91U' },
  nighttebas18: { name: 'Night Tebas', color: 0x3a3a3a, css: '#3a3a3a', cssSelected: '#2a2a2a', roughness: 0.22, textureId: '1yOI-N6F8CAC1rPAdqv1WmfJ8GWNwjDx1' },
  nolita: { name: 'Nolita', color: 0xb0a090, css: '#b0a090', cssSelected: '#a09080', roughness: 0.2, textureId: '1ia1x5mrfbBVKyjx3_FpxprtOMVyS8Cou' },
  oceanjasperf: { name: 'Ocean Jasper F', color: 0x5a7a6a, css: '#5a7a6a', cssSelected: '#4a6a5a', roughness: 0.2, textureId: '1p6VNmtKd32L1-vymnU57SuwJpNWQT5Ln' },
  oceanstorm: { name: 'Ocean Storm', color: 0x4a6a7a, css: '#4a6a7a', cssSelected: '#3a5a6a', roughness: 0.2, textureId: '1L00aEuLk-0iQ9-SMLu3wRHXDPNRjYARN' },
  parisienbleu: { name: 'Parisien Bleu', color: 0x3a4a6a, css: '#3a4a6a', cssSelected: '#2a3a5a', roughness: 0.18, textureId: '1GuimddHfQgNpQw8y-KrbajyVsoN2iQIc' },
  pearljasmine: { name: 'Pearl Jasmine', color: 0xf0e8e0, css: '#f0e8e0', cssSelected: '#e0d8d0', roughness: 0.12, textureId: '1OKm_2rICWvvZs8mhLRbjNWTbGPy47TZC' },
  persianwhite: { name: 'Persian White', color: 0xf8f5f0, css: '#f8f5f0', cssSelected: '#e8e5e0', roughness: 0.1, textureId: '1EwRmIqPMaV_yVBfIC5belV2o4zEjImrQ' },
  pietra: { name: 'Pietra', color: 0xc0b8a8, css: '#c0b8a8', cssSelected: '#b0a898', roughness: 0.2, textureId: '1BHlHEorkuNFft7EE_Ryu3_eIQrzd6qIb' },
  poblenou: { name: 'Poblenou', color: 0x7a7a7a, css: '#7a7a7a', cssSelected: '#6a6a6a', roughness: 0.22, textureId: '17O2iOzVpJ5akuM7eeU1-YLmq_ZiqFQkR' },
  posidoniagreen: { name: 'Posidonia Green', color: 0x3a5a3a, css: '#3a5a3a', cssSelected: '#2a4a2a', roughness: 0.2, textureId: '1G_PJHDyTHj6XHpFPS9SW2xWAZ-Vobq4d' },
  rawa: { name: 'Raw A', color: 0xa8a0a0, css: '#a8a0a0', cssSelected: '#989090', roughness: 0.25, textureId: '1b7sIU7wk2SWzWKDerspOELtCbh_OHSDC' },
  rawd: { name: 'Raw D', color: 0x8a8a8a, css: '#8a8a8a', cssSelected: '#7a7a7a', roughness: 0.25, textureId: '1WrJKM4mksM63rDyVc5cJF0M_ZArkVVAA' },
  rawg: { name: 'Raw G', color: 0x6a6a6a, css: '#6a6a6a', cssSelected: '#5a5a5a', roughness: 0.25, textureId: '177QT72f35CVCWqRJ98nFmNxn2I8TaWsc' },
  rivirerose: { name: 'Rivi√®re Rose', color: 0xd8b8a8, css: '#d8b8a8', cssSelected: '#c8a898', roughness: 0.18, textureId: '1f6cLHK8W8ZY-SJK4hDTNqrpRM1S4nWgL' },
  romanticash: { name: 'Romantic Ash', color: 0xc0b8b0, css: '#c0b8b0', cssSelected: '#b0a8a0', roughness: 0.18, textureId: '1ryHmPfq6JdJutihupePeL0edSfDGFxlz' },
  rougui: { name: 'Rougui', color: 0xa88878, css: '#a88878', cssSelected: '#987868', roughness: 0.2, textureId: '1a8nBWOyPauzWUMmWyppOh0HMgZWKvo-U' },
  siberian: { name: 'Siberian', color: 0xc8c0b8, css: '#c8c0b8', cssSelected: '#b8b0a8', roughness: 0.18, textureId: '1dH83KTRHvyLBCChBLCvKp9i8mXI-RiwQ' },
  siennaridge12: { name: 'Sienna Ridge', color: 0xb08868, css: '#b08868', cssSelected: '#a07858', roughness: 0.2, textureId: '1c0yd9-cHHKYL7FTL1W5JuyWCqkfoi8W5' },
  snowyibiza: { name: 'Snowy Ibiza', color: 0xf8f8f8, css: '#f8f8f8', cssSelected: '#e8e8e8', roughness: 0.1, textureId: '1ujl_Y2G8Qq8inbnp-GnIRUgwwrZ5KfeX' },
  stellarblanco13: { name: 'Stellar Blanco', color: 0xf0f0f0, css: '#f0f0f0', cssSelected: '#e0e0e0', roughness: 0.15, textureId: '1y--bdGZpuDzjijCLFtbr860yY5cdZKtd' },
  stellarnight: { name: 'Stellar Night', color: 0x2a2a2a, css: '#3a3a3a', cssSelected: '#2a2a2a', roughness: 0.15, textureId: '1E6lBctOvq7gnCApdZ5SzVtZwvxsklgJ8' },
  toscanacream: { name: 'Toscana Cream', color: 0xf0e8d8, css: '#f0e8d8', cssSelected: '#e0d8c8', roughness: 0.15, textureId: '1Lnp3XCxzE6n9JlW9RCD-3NyP8mOizAlF' },
  versaillesivory: { name: 'Versailles Ivory', color: 0xf5f0e5, css: '#f5f0e5', cssSelected: '#e5e0d5', roughness: 0.12, textureId: '10-OZGeG5ygPlgCtFLlCxIyUiH3gXNebZ' },
  victoriansilver: { name: 'Victorian Silver', color: 0xc8c8c8, css: '#c8c8c8', cssSelected: '#b8b8b8', roughness: 0.18, textureId: '1pWhLjnETI4AtUHdtlEJAh4KkrylTz92t' },
  whitearabesque: { name: 'White Arabesque', color: 0xf8f5f0, css: '#f8f5f0', cssSelected: '#e8e5e0', roughness: 0.1, textureId: '1ubY1aFcsmSE6LeETOmGMxRYnTOFoi-iQ' },
  whitestorm14: { name: 'White Storm', color: 0xe8e8e8, css: '#e8e8e8', cssSelected: '#d0d0d0', roughness: 0.15, textureId: '1zdk9JySY82_HH-DiIgDj4_1EJtlBieAt' },
  whitezeus: { name: 'White Zeus', color: 0xf0f0f0, css: '#f0f0f0', cssSelected: '#e0e0e0', roughness: 0.15, textureId: '12Ye6tv4INt-jMij6QWjZcZh5H3FRxfVz' },
  yukon: { name: 'Yukon', color: 0xa09888, css: '#a09888', cssSelected: '#908878', roughness: 0.2, textureId: '1-dO_F5WmyQW6GNCwlvxS47Au_GxIxb5w' },
  
  // Global Granite TEST materials (brand: 'GLO' = 18% auto-crop)
  glo_alaska: { name: 'Alaska (Global)', color: 0xe8e8e8, css: '#e8e8e8', cssSelected: '#d0d0d0', roughness: 0.15, textureId: '1MvlLhyIyzmtwaBJq99yOMButxlbI1iov', brand: 'GLO' },
  glo_apollo: { name: 'Apollo (Global)', color: 0xf5f5f5, css: '#f5f5f5', cssSelected: '#e5e5e5', roughness: 0.12, textureId: '1aKsM34hsMVklbkTAoKBivkI-h9OqDwcX', brand: 'GLO' },
  glo_blackmirror: { name: 'Black Mirror (Global)', color: 0x1a1a1a, css: '#2a2a2a', cssSelected: '#1a1a1a', roughness: 0.1, textureId: '1kVHOVpmaZA-KzOi0tuQC94Q1s56mJmZl', brand: 'GLO' },
  glo_calacattagold: { name: 'Calacatta Gold (Global)', color: 0xf5f0e5, css: '#f5f0e5', cssSelected: '#e5e0d5', roughness: 0.1, textureId: '1lKEs4bVJ-R4R__sQs9fgAxnhhZ8tf0cp', brand: 'GLO' },
  glo_michelangelo: { name: 'Michelangelo (Global)', color: 0xf0ebe5, css: '#f0ebe5', cssSelected: '#e0dbd5', roughness: 0.12, textureId: '1evH3sAt5uj_QPm1CN85mHnWz-HGBx8SB', brand: 'GLO' },
  
  // Modern Quartz TEST materials (brand: 'MOD' = 18% auto-crop)
  mod_alaskabianca: { name: 'Alaska Bianca (Modern)', color: 0xf0f0f0, css: '#f0f0f0', cssSelected: '#e0e0e0', roughness: 0.15, textureId: '1eMykB1slcOPPhqsSlGVBR4vg_-gsSGEp', brand: 'MOD' },
  mod_alaskagrey: { name: 'Alaska Grey (Modern)', color: 0xc0c0c0, css: '#c0c0c0', cssSelected: '#b0b0b0', roughness: 0.15, textureId: '1vAqUBEQBEicQAU01wPgSTIHZQxqpd6b0', brand: 'MOD' },
  mod_arabescato: { name: 'Arabescato (Modern)', color: 0xf5f5f5, css: '#f5f5f5', cssSelected: '#e5e5e5', roughness: 0.12, textureId: '1aYIsFwS0M59K2j3Z_QQmgLwnZVWTZVLT', brand: 'MOD' },
  mod_biancocarrara: { name: 'Bianco Carrara (Modern)', color: 0xf8f8f8, css: '#f8f8f8', cssSelected: '#e8e8e8', roughness: 0.12, textureId: '1ma13KUIWhxSamU1bf5HidKzD1l_UUBNt', brand: 'MOD' },
  mod_calacattaoro: { name: 'Calacatta Oro (Modern)', color: 0xfaf8f0, css: '#faf8f0', cssSelected: '#eae8e0', roughness: 0.1, textureId: '1H1ljkUTlrQ4IoI2lvFqeNUyUUFkbl3kb', brand: 'MOD' },
  
  // ========== HORIZON PORCELAIN (brand: 'HSP' = Porcelain pricing) ==========
  // COSMOS RANGE (¬£450)
  prcs001_tajmahalpolished: { name: 'Taj Mahal Polished', brand: 'HSP', textureId: '1_6SzAg-ReKTzKIgReeh8ZbuyOaV0zJIE', roughness: 0.2 },
  prcs002_tajmahalhoned: { name: 'Taj Mahal Honed', brand: 'HSP', textureId: '10vp2VQ9URzm1eaLRYzzbY8YhH0vxngzq', roughness: 0.4 },
  prcs003_statuariopolished: { name: 'Statuario Polished', brand: 'HSP', textureId: '1Swa0OJiMOZjVQ8QMgvFhDC8M53YCIc66', roughness: 0.2 },
  prcs004_statuariohoned: { name: 'Statuario Honed', brand: 'HSP', textureId: '1iIT01qfeCWHVRe1RI0VgVuoltqNAVsna', roughness: 0.4 },
  prcs005_neroportoro: { name: 'Nero Portoro Matte', brand: 'HSP', textureId: '1_EfPEt-nbVewMVz4X9PCwuVT9i5agpR1', roughness: 0.4 },
  prcs006_riverwhitehoned: { name: 'River White Honed', brand: 'HSP', textureId: '1QD9EyaerqfftQe6YZeIqAvE1UgHxCoM0', roughness: 0.4 },
  prcs007_whitetravertinehoned: { name: 'White Travertine Honed', brand: 'HSP', textureId: '1kBhQNYOahYtn-nO2uUlT_KLTDRSA8D-B', roughness: 0.4 },
  prcs008_rosegoldpolished: { name: 'Rose Gold Polished', brand: 'HSP', textureId: '1IswrI5rDvnSJrPxMbTCed3mBaF3ULwUQ', roughness: 0.2 },
  prcs009_rosegoldhoned: { name: 'Rose Gold Honed', brand: 'HSP', textureId: '12dSImiv_ajQ-C8w213qzBsgmuV_b8_1T', roughness: 0.4 },
  prcs010_laurentmatte: { name: 'Laurent Matte', brand: 'HSP', textureId: '1185ouSVWwKtIxrYtVSm3A-13lANKKb2B', roughness: 0.4 },
  // INDIGO RANGE - Super Jumbo 3300x1840 (¬£800)
  prid021_calacattaveneresofttouch: { name: 'Calacatta Venere Soft Touch', brand: 'HSP', textureId: '1-AksvJAFz9Wospu_Zxc2EZbqyFKmIe4F', roughness: 0.4 },
  prid022_calacattavenerepolished: { name: 'Calacatta Venere Polished', brand: 'HSP', textureId: '1NE7Grxxq3BtklOj3BZIH2_sSFRpsyXLE', roughness: 0.2 },
  prid023_tajmahalpolished: { name: 'Taj Mahal Polished (Indigo)', brand: 'HSP', textureId: '1AbjMMw9wu0zZtMOrt0eeHx5iU8WGsNHj', roughness: 0.2 },
  prid024_travertluminasofttouch: { name: 'Travert Lumina Soft Touch', brand: 'HSP', textureId: '1vdybZMOQ1WWjWpVXCP4CWaJwUNcQJRYY', roughness: 0.4 },
  prid025_blacktempestnatural: { name: 'Black Tempest Natural', brand: 'HSP', textureId: '1Wi2QZYJZoH5LSRg6larGK7RMGR1rvKOe', roughness: 0.4 },
  prid026_calacattasupremepolished: { name: 'Calacatta Supreme Polished', brand: 'HSP', textureId: '1zc6eDpS1HAIstfngXDg5wY4TUfDpbeEE', roughness: 0.2 },
  prid027_goldlaurentnatural: { name: 'Gold Laurent Natural', brand: 'HSP', textureId: '1eDnt4h2G_FW8tKqwwHrv3xrGgchqL9Tf', roughness: 0.4 },
  prid028_goldlaurentpolished: { name: 'Gold Laurent Polished', brand: 'HSP', textureId: '1wKkeT7TRX6soZ87TmYakSGYbvgM0JryH', roughness: 0.2 },
  prid029_macchiavecchiapolished: { name: 'Macchia Vecchia Polished', brand: 'HSP', textureId: '1JiLAXg4WoNUe89BePkQr3jYdHXfH-SFn', roughness: 0.2 },
  // INSPIRE RANGE (¬£650)
  prin101_arabescatoviolapolished: { name: 'Arabescato Viola Polished', brand: 'HSP', textureId: '1BJfIT7ceFBuGnKXGa2bHbLYffhz_2-h8', roughness: 0.2 },
  prin102_arabescatoviolaleather: { name: 'Arabescato Viola Leather', brand: 'HSP', textureId: '1DhqS6_IHL33RpTI89ne0Z4YVsNfSDYlh', roughness: 0.5 },
  prin103_arabescatopolished: { name: 'Arabescato Polished', brand: 'HSP', textureId: '1S7BtGMMVB7XU10zuByad5k8HYUygej0w', roughness: 0.2 },
  prin104_arabescatoleather: { name: 'Arabescato Leather', brand: 'HSP', textureId: '1rsNCyvmFcWj7N1mVza8LzoKdRFNpuOhR', roughness: 0.5 },
  prin105_calacattaoropolished: { name: 'Calacatta Oro Polished', brand: 'HSP', textureId: '1NYBa7fI08TtsyiPJkj_fuvcmd-gwQXsI', roughness: 0.2 },
  prin106_calacattaoroleather: { name: 'Calacatta Oro Leather', brand: 'HSP', textureId: '1qJ1ggSRa2aKfy_8IYdIlhQFR3XTYtz9H', roughness: 0.5 },
  prin107_calacattadoratopolished: { name: 'Calacatta Dorato Polished', brand: 'HSP', textureId: '1fLXZjag-wT2JPGJ7C6lZg49TUlJKByxl', roughness: 0.2 },
  prin108_calacattadoratoleather: { name: 'Calacatta Dorato Leather', brand: 'HSP', textureId: '1kXhaG1q2fv7LCTroigfZP1euT03a-I22', roughness: 0.5 },
  prin109_borghettopolished: { name: 'Borghetto Polished', brand: 'HSP', textureId: '15P81Qrak8R9duwiiJoPu4Y6kueGCia01', roughness: 0.2 },
  prin110_borghettoleather: { name: 'Borghetto Leather', brand: 'HSP', textureId: '1nwLTh1-Ufu-JKjnbO0Vlgksps_jeQP1F', roughness: 0.5 },
  prin111_caravaggioiogoldleather: { name: 'Caravaggio Gold Leather', brand: 'HSP', textureId: '1YFQVfdwVhroTSVIVCITXmTlIARwBMgdK', roughness: 0.5 },
  prin112_fiordiboscoleather: { name: 'Fior Di Bosco Leather', brand: 'HSP', textureId: '1RXi0KrrOCwWb7mmt1y17reuvlDLIqbIZ', roughness: 0.5 },
  prin113_hermitagepolished: { name: 'Hermitage Polished', brand: 'HSP', textureId: '1vcDE-uQtElmfmAB6142yX9UGjZiWRt4v', roughness: 0.2 },
  prin114_hermitageleather: { name: 'Hermitage Leather', brand: 'HSP', textureId: '1UURf7jG9bTSmTzQ-YxbCX1rLe_AGxn8u', roughness: 0.5 },
  prin115_lasawhitepolished: { name: 'Lasa White Polished', brand: 'HSP', textureId: '1LyXisnIb2CHQvfkRsqGwxoB9u0B4mNgm', roughness: 0.2 },
  prin116_lasawhiteleather: { name: 'Lasa White Leather', brand: 'HSP', textureId: '1oTSZjfOnx03yy32xi2xVzkyJxXrFmrup', roughness: 0.5 },
  prin117_lightredcalacattapolished: { name: 'Light Red Calacatta Polished', brand: 'HSP', textureId: '1NHye6GwKxWJzdMCah8u9DneK63fJ3GbQ', roughness: 0.2 },
  prin118_lightredcalacattaleather: { name: 'Light Red Calacatta Leather', brand: 'HSP', textureId: '1EcNrgKAiEAVzV16DEsTz-GyseoOp-9AG', roughness: 0.5 },
  prin119_lincolndoratopolished: { name: 'Lincoln Dorato Polished', brand: 'HSP', textureId: '1PrLJnyzykYull6VNuA47rNlz4q3jQD2x', roughness: 0.2 },
  prin120_lincolndoratoleather: { name: 'Lincoln Dorato Leather', brand: 'HSP', textureId: '1eRBq3PnidCK7LnogZOjfnp-fu1j3fdOA', roughness: 0.5 },
  prin121_marmoanticopolished: { name: 'Marmo Antico Polished', brand: 'HSP', textureId: '1_-hgepEnOrWrs4mHUP9P33Ws2Cwtq50G', roughness: 0.2 },
  prin122_marmoanticoleather: { name: 'Marmo Antico Leather', brand: 'HSP', textureId: '1WZfgvU80Q5UNZfnNT3C0PDgf9C9IWKxk', roughness: 0.5 },
  prin123_negevpolished: { name: 'Negev Polished', brand: 'HSP', textureId: '1HcVVMMX1uAnSJUrGi2Ajz7gDNWDkFzAl', roughness: 0.2 },
  prin124_negevleather: { name: 'Negev Leather', brand: 'HSP', textureId: '1IV7UOelqgSXnz4hdfeZks2ghG00OBKRT', roughness: 0.5 },
  prin125_portoroleather: { name: 'Portoro Leather', brand: 'HSP', textureId: '1_hGiL29xEXilTjNWSi777BV7TTlFuI3D', roughness: 0.5 },
  prin126_preciousstonepolished: { name: 'Precious Stone Polished', brand: 'HSP', textureId: '1sWt1Bj4aBzjhtLu8WWxpMVsW8kyawoa_', roughness: 0.2 },
  prin127_statuarioleonardopolished: { name: 'Statuario Leonardo Polished', brand: 'HSP', textureId: '17Pc-rbw4pp7NGpaeQ3cVfoU1K9Kumr16', roughness: 0.2 },
  prin128_statuarioleonardoleather: { name: 'Statuario Leonardo Leather', brand: 'HSP', textureId: '1UtbbM_IbiTU1AWGllpaSfqK9StQJf0ri', roughness: 0.5 },
  prin129_superwhiteleather: { name: 'Super White Leather', brand: 'HSP', textureId: '1BPadDQ4RDp6HjL0qXKL5586f1Jg2Fxh8', roughness: 0.5 },
  prin130_tajmahalpolished: { name: 'Taj Mahal Polished (Inspire)', brand: 'HSP', textureId: '1yCXara2KHXIGLW7CUdKLBb-A8oCrUP0x', roughness: 0.2 },
  prin131_tajmahalleather: { name: 'Taj Mahal Leather', brand: 'HSP', textureId: '1mOyE1JJjNu9TYhQErko-U7SjhPQ3smrZ', roughness: 0.5 },
  prin132_blackgoldleather: { name: 'Black Gold Leather', brand: 'HSP', textureId: '13QGjmHSeAdutKVVDVlsrO19BxDGQIk29', roughness: 0.5 },
  prin133_balletpolished: { name: 'Ballet Polished', brand: 'HSP', textureId: '1Y6A8VhxVpmrkprEIh2AySyC1DD8Afa28', roughness: 0.2 },
  prin134_balletleather: { name: 'Ballet Leather', brand: 'HSP', textureId: '1eEQ9ueFb0_ax3JAB_pQh_1iqUXuj0e5D', roughness: 0.5 },
  prin135_doratinopolished: { name: 'Doratino Polished', brand: 'HSP', textureId: '16D5zj5FBIm3G5W6uRov_LKBinux2kmn7', roughness: 0.2 },
  prin136_doratinoleather: { name: 'Doratino Leather', brand: 'HSP', textureId: '1qlf94TyrHFkAj74spRPoVbT6dQjiHMry', roughness: 0.5 },
  prin137_travertinowhitepolished: { name: 'Travertino White Polished', brand: 'HSP', textureId: '1-M2jDRDu9Yi5t4xrSEidMxeYM9Mrt836', roughness: 0.2 },
  prin138_travertinowhiteleather: { name: 'Travertino White Leather', brand: 'HSP', textureId: '1E4X0KkMTJsKc0-xDkipwNdrmTDsUQErn', roughness: 0.5 },
  prin139_travertinobeigebeather: { name: 'Travertino Beige Leather', brand: 'HSP', textureId: '1inlwhwAW-8gqwp7wS2prPAIBqx8zHYTC', roughness: 0.5 },
  prin140_midnightleather: { name: 'Midnight Leather', brand: 'HSP', textureId: '161PQN-wRIIWwdBJ193Dyh8MqimCqIv-z', roughness: 0.5 },
  prin141_tintaunitaneropolished: { name: 'Tinta Unita Nero Polished', brand: 'HSP', textureId: '17Lb1tVROWm6B6NgJpB_mTb3l-ixMqjO3', roughness: 0.2 }
};

// Material pricing data (from Silestone price list)
// tier: 1-5 (¬£ to ¬£¬£¬£¬£¬£), prices in GBP
const MATERIAL_PRICING = {
  jardinemerald: { tier: 5, price20sqm: 288.71, price20slab: 1478.20, price30sqm: 444.46, price30slab: 2275.64 },
  stellarnight: { tier: 2, price20sqm: 134.27, price20slab: 687.46, price30sqm: 181.24, price30slab: 927.95 },
  versaillesivory: { tier: 4, price20sqm: 225.46, price20slab: 1154.36, price30sqm: 315.54, price30slab: 1615.56 },
  calacattatova: { tier: 2, price20sqm: 134.26, price20slab: 687.41, price30sqm: null, price30slab: null },
  romanticash: { tier: 5, price20sqm: 317.51, price20slab: 1625.65, price30sqm: 444.46, price30slab: 2275.64 },
  lyra: { tier: 2, price20sqm: 122.06, price20slab: 624.95, price30sqm: 164.79, price30slab: 843.73 },
  coralclaycolour: { tier: 1, price20sqm: 101.43, price20slab: 519.32, price30sqm: 124.94, price30slab: 639.69 },
  ariel: { tier: 2, price20sqm: 147.69, price20slab: 756.17, price30sqm: 181.24, price30slab: 927.95 },
  motiongrey: { tier: 1, price20sqm: 89.21, price20slab: 456.75, price30sqm: 120.94, price30slab: 619.21 },
  etmarquina: { tier: 4, price20sqm: 211.67, price20slab: 1083.75, price30sqm: 296.31, price30slab: 1517.11 },
  cindercraze: { tier: 2, price20sqm: 134.27, price20slab: 687.46, price30sqm: 181.27, price30slab: 928.10 },
  farowhite: { tier: 4, price20sqm: 211.68, price20slab: 1083.80, price30sqm: 296.32, price30slab: 1517.16 },
  etherealnoctis: { tier: 4, price20sqm: 256.62, price20slab: 1313.89, price30sqm: 359.16, price30slab: 1838.90 },
  nolita: { tier: 4, price20sqm: 211.68, price20slab: 1083.80, price30sqm: 296.32, price30slab: 1517.16 },
  blanclyse: { tier: 5, price20sqm: 288.71, price20slab: 1478.20, price30sqm: 404.06, price30slab: 2068.79 },
  halcyon: { tier: 2, price20sqm: 134.26, price20slab: 687.41, price30sqm: 181.24, price30slab: 927.95 },
  biancocalacatta: { tier: 2, price20sqm: 134.26, price20slab: 687.41, price30sqm: 181.24, price30slab: 927.95 },
  chteaubrown: { tier: 5, price20sqm: 288.71, price20slab: 1478.20, price30sqm: null, price30slab: null },
  rougui: { tier: 1, price20sqm: null, price20slab: null, price30sqm: 141.36, price30slab: 723.76 },
  etnoir: { tier: 4, price20sqm: 200.40, price20slab: 1026.05, price30sqm: 308.53, price30slab: 1579.67 },
  brassrelish: { tier: 2, price20sqm: 134.27, price20slab: 687.46, price30sqm: 181.27, price30slab: 928.10 },
  lusso: { tier: 2, price20sqm: 134.26, price20slab: 687.41, price30sqm: 181.24, price30slab: 927.95 },
  rawd: { tier: 4, price20sqm: 211.68, price20slab: 1083.80, price30sqm: 296.32, price30slab: 1517.16 },
  etcalacattagold: { tier: 4, price20sqm: 200.40, price20slab: 1026.05, price30sqm: 280.48, price30slab: 1436.06 },
  whitearabesque: { tier: 1, price20sqm: 99.45, price20slab: 509.18, price30sqm: 134.69, price30slab: 689.61 },
  whitestorm14: { tier: 1, price20sqm: 104.67, price20slab: 535.91, price30sqm: 141.36, price30slab: 723.76 },
  blancoorion: { tier: 3, price20sqm: 192.44, price20slab: 985.29, price30sqm: null, price30slab: null },
  miamivena: { tier: 1, price20sqm: 99.45, price20slab: 509.18, price30sqm: 134.69, price30slab: 689.61 },
  blanconorte14: { tier: 1, price20sqm: 104.67, price20slab: 535.91, price30sqm: 141.36, price30slab: 723.76 },
  classiccalacatta: { tier: 2, price20sqm: 134.26, price20slab: 687.41, price30sqm: 181.24, price30slab: 927.95 },
  grisexpo: { tier: 1, price20sqm: 104.67, price20slab: 535.91, price30sqm: 141.36, price30slab: 723.76 },
  etstatuario: { tier: 3, price20sqm: 150.28, price20slab: 769.43, price30sqm: 231.41, price30slab: 1184.82 },
  charcoalsoapstone: { tier: 2, price20sqm: 134.26, price20slab: 687.41, price30sqm: 181.26, price30slab: 928.05 },
  blancomaple: { tier: 1, price20sqm: 104.67, price20slab: 535.91, price30sqm: 141.36, price30slab: 723.76 },
  linencream: { tier: 1, price20sqm: 81.10, price20slab: 415.23, price30sqm: 120.94, price30slab: 619.21 },
  persianwhite: { tier: 1, price20sqm: 92.20, price20slab: 472.06, price30sqm: 137.43, price30slab: 703.64 },
  miamiwhite: { tier: 2, price20sqm: 122.06, price20slab: 624.95, price30sqm: 164.79, price30slab: 843.73 },
  poblenou: { tier: 4, price20sqm: 211.68, price20slab: 1083.80, price30sqm: 296.32, price30slab: 1517.16 },
  whitezeus: { tier: 3, price20sqm: 192.44, price20slab: 985.29, price30sqm: 296.32, price30slab: 1517.16 },
  desertsilver: { tier: 1, price20sqm: 99.45, price20slab: 509.18, price30sqm: 134.69, price30slab: 689.61 },
  snowyibiza: { tier: 1, price20sqm: 109.39, price20slab: 560.08, price30sqm: 134.69, price30slab: 689.61 },
  stellarblanco13: { tier: 2, price20sqm: null, price20slab: null, price30sqm: 181.24, price30slab: 927.95 },
  siberian: { tier: 1, price20sqm: 92.20, price20slab: 472.06, price30sqm: 137.43, price30slab: 703.64 },
  etherealhaze: { tier: 4, price20sqm: 256.62, price20slab: 1313.89, price30sqm: 359.16, price30slab: 1838.90 },
  bronzerivers: { tier: 1, price20sqm: 99.45, price20slab: 509.18, price30sqm: 134.69, price30slab: 689.61 },
  lagoon: { tier: 1, price20sqm: 92.20, price20slab: 472.06, price30sqm: 124.94, price30slab: 639.69 },
  nighttebas18: { tier: 1, price20sqm: 104.86, price20slab: 536.88, price30sqm: 141.56, price30slab: 724.79 },
  eclecticpearl: { tier: 5, price20sqm: 288.71, price20slab: 1478.20, price30sqm: 404.06, price30slab: 2068.79 },
  marengo: { tier: 1, price20sqm: 104.67, price20slab: 535.91, price30sqm: 141.36, price30slab: 723.76 },
  etherealglow: { tier: 4, price20sqm: 200.40, price20slab: 1026.05, price30sqm: 308.53, price30slab: 1579.67 },
  pearljasmine: { tier: 4, price20sqm: 232.84, price20slab: 1192.14, price30sqm: 296.31, price30slab: 1517.11 },
  limedelight: { tier: 2, price20sqm: 134.27, price20slab: 687.46, price30sqm: 181.27, price30slab: 928.10 },
  posidoniagreen: { tier: 4, price20sqm: null, price20slab: null, price30sqm: 296.32, price30slab: 1517.16 },
  etherealdusk: { tier: 4, price20sqm: 256.62, price20slab: 1313.89, price30sqm: 359.16, price30slab: 1838.90 },
  victoriansilver: { tier: 5, price20sqm: 288.71, price20slab: 1478.20, price30sqm: 404.06, price30slab: 2068.79 },
  concretepulse: { tier: 2, price20sqm: 134.27, price20slab: 687.46, price30sqm: 181.27, price30slab: 928.10 },
  rivirerose: { tier: 5, price20sqm: 288.71, price20slab: 1478.20, price30sqm: 444.46, price30slab: 2275.64 },
  bohemianflame: { tier: 4, price20sqm: 248.01, price20slab: 1269.81, price30sqm: 347.09, price30slab: 1777.10 },
  rawa: { tier: 4, price20sqm: 211.68, price20slab: 1083.80, price30sqm: 296.32, price30slab: 1517.16 },
  parisienbleu: { tier: 5, price20sqm: 288.71, price20slab: 1478.20, price30sqm: 404.06, price30slab: 2068.79 },
  corktown: { tier: 4, price20sqm: 211.68, price20slab: 1083.80, price30sqm: 296.32, price30slab: 1517.16 },
  rawg: { tier: 4, price20sqm: 211.68, price20slab: 1083.80, price30sqm: 296.32, price30slab: 1517.16 },
  blancocity: { tier: 1, price20sqm: 104.67, price20slab: 535.91, price30sqm: null, price30slab: null },
  // Additional materials with estimated tiers (no CSV pricing yet)
  calacattathemis: { tier: 3, price20sqm: null, price20slab: null, price30sqm: null, price30slab: null },
  calypso: { tier: 2, price20sqm: null, price20slab: null, price30sqm: null, price30slab: null },
  camden: { tier: 2, price20sqm: null, price20slab: null, price30sqm: null, price30slab: null },
  cincelgrey: { tier: 2, price20sqm: null, price20slab: null, price30sqm: null, price30slab: null },
  coppermist: { tier: 3, price20sqm: null, price20slab: null, price30sqm: null, price30slab: null },
  etbella: { tier: 3, price20sqm: null, price20slab: null, price30sqm: null, price30slab: null },
  etdor: { tier: 3, price20sqm: null, price20slab: null, price30sqm: null, price30slab: null },
  etmarfil: { tier: 3, price20sqm: null, price20slab: null, price30sqm: null, price30slab: null },
  etherealindigo: { tier: 4, price20sqm: null, price20slab: null, price30sqm: null, price30slab: null },
  ffrom01: { tier: 3, price20sqm: null, price20slab: null, price30sqm: null, price30slab: null },
  ffrom02: { tier: 3, price20sqm: null, price20slab: null, price30sqm: null, price30slab: null },
  ffrom03: { tier: 3, price20sqm: null, price20slab: null, price30sqm: null, price30slab: null },
  helix: { tier: 2, price20sqm: null, price20slab: null, price30sqm: null, price30slab: null },
  miamioro: { tier: 3, price20sqm: null, price20slab: null, price30sqm: null, price30slab: null },
  oceanjasperf: { tier: 4, price20sqm: null, price20slab: null, price30sqm: null, price30slab: null },
  oceanstorm: { tier: 3, price20sqm: null, price20slab: null, price30sqm: null, price30slab: null },
  pietra: { tier: 2, price20sqm: null, price20slab: null, price30sqm: null, price30slab: null },
  calablue: { tier: 3, price20sqm: null, price20slab: null, price30sqm: null, price30slab: null },
  toscanacream: { tier: 2, price20sqm: null, price20slab: null, price30sqm: null, price30slab: null },
  yukon: { tier: 2, price20sqm: null, price20slab: null, price30sqm: null, price30slab: null }
};

// Selected thickness for pricing (20 or 30mm)
let selectedThickness = 20;
let pendingMaterial = null; // Material being previewed before confirmation
let selectedMaterial = null; // Currently confirmed material

// Material filter state
let currentBrandFilter = 'all';
let adminUnlocked = sessionStorage.getItem('adminUnlocked') === 'true';
const ADMIN_PIN = '1414';
let currentTierFilter = 'all';
let currentThicknessFilter = '20';
let tierStyle = 'pill'; // 'classic' or 'pill'

// ========== PRESET LAYOUTS ==========
const PRESETS = {
  single: {
    worktops: [{ name: 'Worktop 1', x: 0, y: 0, length: 3000, depth: 620 }],
    connections: []
  },
  galley: {
    worktops: [
      { name: 'Run 1', x: 0, y: 0, length: 3000, depth: 620 },
      { name: 'Run 2', x: 0, y: 1500, length: 3000, depth: 620 }
    ],
    connections: []
  },
  lshape: {
    worktops: [
      { name: 'Long Run', x: 0, y: 0, length: 3000, depth: 620 },
      { name: 'Return', x: 0, y: 620, length: 620, depth: 1500 }
    ],
    connections: []
  },
  ushape: {
    worktops: [
      { name: 'Left', x: 0, y: 0, length: 620, depth: 2000 },
      { name: 'Back', x: 620, y: 0, length: 2000, depth: 620 },
      { name: 'Right', x: 2620, y: 0, length: 620, depth: 2000 }
    ],
    connections: []
  },
  gshape: {
    worktops: [
      { name: 'Left', x: 0, y: 0, length: 620, depth: 2400 },
      { name: 'Back', x: 620, y: 0, length: 2000, depth: 620 },
      { name: 'Right', x: 2620, y: 0, length: 620, depth: 1800 },
      { name: 'Peninsula', x: 1520, y: 1800, length: 1720, depth: 620 }
    ],
    connections: []
  }
};

// ========== STATE ==========
let worktops = [];
let upstands = [];
let cutouts = [];
let customCaptures = [];  // Custom 3D view captures for quote
let selectedId = null;
let selectedType = null;
let tool = 'select';
let scale = 0.2;
let offset = { x: 0, y: 0 };
let isPanning = false;
let isDrawing = false;
let isDragging = false;
let spaceHeld = false;
let drawStart = null;
let dragStart = null;
let panStart = null;
let activeSnap = null;
let nextId = 1;
let history = [];
let edgeMenuTarget = null;
let currentView = '2d';

// Slab optimization warning state
let slabOptimizationSuggestions = [];
let hasShownSlabWarning = sessionStorage.getItem('hasShownSlabWarning') === 'true';
let isPageLoading = true;  // Skip popup during initial load
let lastKnownSlabCount = parseInt(sessionStorage.getItem('lastKnownSlabCount')) || 0;
let isMaterialChanging = false; // Skip popup during material selection

// Custom material for granite/marble quotes
let customMaterial = {
  name: '',
  type: 'quartz',
  thickness: 30,
  slabPrice: 0,
  imageData: null,
  texture: null,
  active: false  // Track if custom material is being used
};

// ========== CUSTOM MATERIAL FUNCTIONS ==========
function loadCustomMaterialImage(input) {
  if (input.files && input.files[0]) {
    const reader = new FileReader();
    reader.onload = function(e) {
      customMaterial.imageData = e.target.result;
      customMaterial.imageName = input.files[0].name;
      
      // Show preview
      const preview = document.getElementById('customMaterialPreview');
      const previewImg = document.getElementById('customMaterialPreviewImg');
      const previewName = document.getElementById('customMaterialPreviewName');
      
      preview.style.display = 'block';
      previewImg.src = e.target.result;
      previewName.textContent = input.files[0].name;
      
      // Save to sessionStorage
      saveCustomMaterial();
    };
    reader.readAsDataURL(input.files[0]);
  }
}

function saveCustomMaterial() {
  try {
    const data = {
      name: customMaterial.name,
      type: customMaterial.type,
      thickness: customMaterial.thickness,
      slabPrice: customMaterial.slabPrice,
      imageData: customMaterial.imageData,
      imageName: customMaterial.imageName,
      active: customMaterial.active
    };
    sessionStorage.setItem('customMaterial', JSON.stringify(data));
    console.log('Custom material saved');
  } catch (e) {
    console.warn('Could not save custom material:', e);
  }
}

function clearCustomMaterial() {
  customMaterial = {
    name: '',
    type: 'quartz',
    thickness: 30,
    slabPrice: 0,
    imageData: null,
    imageName: '',
    texture: null,
    active: false
  };
  
  // Clear form fields
  document.getElementById('customMaterialName').value = '';
  document.getElementById('customMaterialType').value = 'quartz';
  document.getElementById('customMaterialThickness').value = '30';
  document.getElementById('customSlabPrice').value = '';
  document.getElementById('customMaterialImage').value = '';
  document.getElementById('customMaterialPreview').style.display = 'none';
  
  // Clear sessionStorage
  sessionStorage.removeItem('customMaterial');
  
  // Update status
  updateCustomMaterialStatus();
  
  // Re-render
  if (currentView === '3d') render3D();
  if (currentView === 'slab') renderSlabLayout();
  
  console.log('Custom material cleared');
}

function updateCustomMaterialStatus() {
  const statusEl = document.getElementById('customMaterialStatus');
  if (statusEl) {
    if (customMaterial.active && customMaterial.name) {
      statusEl.textContent = '‚úì Active';
      statusEl.style.background = '#c8e6c9';
      statusEl.style.color = '#2e7d32';
    } else {
      statusEl.textContent = 'Inactive';
      statusEl.style.background = '#eee';
      statusEl.style.color = '#666';
    }
  }
}

function restoreCustomMaterial() {
  try {
    const stored = sessionStorage.getItem('customMaterial');
    if (stored) {
      const data = JSON.parse(stored);
      customMaterial.name = data.name || '';
      customMaterial.type = data.type || 'quartz';
      customMaterial.thickness = data.thickness || 30;
      customMaterial.slabPrice = data.slabPrice || 0;
      customMaterial.imageData = data.imageData || null;
      customMaterial.imageName = data.imageName || '';
      customMaterial.active = data.active || false;
      
      // Restore form fields
      const nameEl = document.getElementById('customMaterialName');
      const typeEl = document.getElementById('customMaterialType');
      const thicknessEl = document.getElementById('customMaterialThickness');
      const slabPriceEl = document.getElementById('customSlabPrice');
      
      if (nameEl) nameEl.value = customMaterial.name;
      if (typeEl) typeEl.value = customMaterial.type;
      if (thicknessEl) thicknessEl.value = customMaterial.thickness;
      if (slabPriceEl) slabPriceEl.value = customMaterial.slabPrice || '';
      
      // Restore image preview
      if (customMaterial.imageData) {
        const preview = document.getElementById('customMaterialPreview');
        const previewImg = document.getElementById('customMaterialPreviewImg');
        const previewName = document.getElementById('customMaterialPreviewName');
        
        if (preview) preview.style.display = 'block';
        if (previewImg) previewImg.src = customMaterial.imageData;
        if (previewName) previewName.textContent = customMaterial.imageName || 'Restored image';
      }
      
      // Restore texture for 3D if active
      if (customMaterial.active && customMaterial.imageData && renderer) {
        const loader = new THREE.TextureLoader();
        loader.load(customMaterial.imageData, function(texture) {
          customMaterial.texture = texture;
          texture.wrapS = THREE.RepeatWrapping;
          texture.wrapT = THREE.RepeatWrapping;
        });
      }
      
      console.log('Custom material restored:', customMaterial.name, customMaterial.active ? '(active)' : '(inactive)');
      
      // Update status indicator
      updateCustomMaterialStatus();
    }
  } catch (e) {
    console.warn('Could not restore custom material:', e);
  }
}

function applyCustomMaterial() {
  const name = document.getElementById('customMaterialName').value;
  const type = document.getElementById('customMaterialType').value;
  const thickness = parseInt(document.getElementById('customMaterialThickness').value) || 30;
  const slabPrice = parseFloat(document.getElementById('customSlabPrice').value) || 0;
  
  if (!name) {
    alert('Please enter a material name');
    return;
  }
  
  customMaterial.name = name;
  customMaterial.type = type;
  customMaterial.thickness = thickness;
  customMaterial.slabPrice = slabPrice;
  customMaterial.active = true;  // Mark as active
  worktopThickness = thickness;
  
  // Save to sessionStorage for persistence
  saveCustomMaterial();
  
  // Update status indicator
  updateCustomMaterialStatus();
  
  // Update thickness dropdown
  const thicknessSelect = document.getElementById('thicknessSelect');
  if (thicknessSelect) {
    // Add custom option if not exists
    let customOption = thicknessSelect.querySelector(`option[value="${thickness}"]`);
    if (!customOption && thickness !== 20 && thickness !== 30) {
      customOption = document.createElement('option');
      customOption.value = thickness;
      customOption.textContent = thickness + 'mm';
      thicknessSelect.appendChild(customOption);
    }
    thicknessSelect.value = thickness;
  }
  
  // Create texture for 3D if image loaded
  if (customMaterial.imageData) {
    const loader = new THREE.TextureLoader();
    loader.load(customMaterial.imageData, function(texture) {
      console.log('Custom material texture loaded successfully');
      customMaterial.texture = texture;
      texture.wrapS = THREE.RepeatWrapping;
      texture.wrapT = THREE.RepeatWrapping;
      // Render 3D after texture is loaded
      if (currentView === '3d') render3D();
    }, undefined, function(err) {
      console.error('Failed to load custom material texture:', err);
    });
  }
  
  const priceMsg = slabPrice > 0 ? `\nSlab price: ¬£${slabPrice}` : '';
  const imageMsg = customMaterial.imageData ? '\n‚úì Image uploaded for 3D view' : '\n(No image - using solid color)';
  alert(`Custom material applied:\n${name}\n${type}, ${thickness}mm${priceMsg}${imageMsg}\n\nThis will be used for this quote.`);
  
  // Re-render views (3D will re-render again when texture loads)
  if (currentView === 'slab') renderSlabLayout();
  // Don't render 3D here - wait for texture to load
}

// ========== 2D CANVAS ==========
const container = document.getElementById('canvasContainer');
const canvas = document.getElementById('canvas2d');
const ctx = canvas.getContext('2d');

function resizeCanvas() {
  canvas.width = container.clientWidth;
  canvas.height = container.clientHeight;
  if (offset.x === 0 && offset.y === 0) {
    offset.x = canvas.width / 2;
    offset.y = canvas.height / 2;
  }
  render();
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// Re-center canvas when returning from summary page (browser back button)
window.addEventListener('pageshow', function(event) {
  // event.persisted is true when page is loaded from bfcache (back/forward navigation)
  if (event.persisted) {
    resizeCanvas();
    // Small delay to ensure canvas is ready
    setTimeout(() => {
      zoomFit();
    }, 100);
  }
});

function mmToScreen(x, y) { return { x: x * scale + offset.x, y: y * scale + offset.y }; }
function screenToMm(x, y) { return { x: (x - offset.x) / scale, y: (y - offset.y) / scale }; }

// ========== HISTORY ==========
function saveHistory() {
  history.push(JSON.stringify({ worktops, upstands, cutouts }));
  if (history.length > 50) history.shift();
}
function undo() {
  if (history.length > 0) {
    const prev = JSON.parse(history.pop());
    worktops = prev.worktops;
    upstands = prev.upstands;
    cutouts = prev.cutouts || [];
    selectedId = null;
    detectAllJoints();
    renderLists();
    render();
    updateSummary();
  }
}

// ========== PRESETS ==========
function loadPreset(name) {
  saveHistory();
  const preset = PRESETS[name];
  worktops = preset.worktops.map((w, i) => ({
    ...w,
    name: `Worktop ${i + 1}`,
    id: nextId++,
    joints: { back: [], front: [], left: [], right: [] },
    edgeTypes: {}
  }));
  upstands = [];
  cutouts = [];
  detectAllJoints();
  renderLists();
  zoomFit();
  updateSummary();
}

// ========== TOOL ==========
function setTool(t) {
  tool = t;
  document.querySelectorAll('.tool-btn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.tool === t);
  });
  document.getElementById('statusTool').textContent = t === 'upstand' ? 'Upstand/Splash' : t.charAt(0).toUpperCase() + t.slice(1);
  
  const hints = {
    select: 'Click green edge for options. Double-click to deselect. Right-click or Space to pan.',
    worktop: 'Click corners to draw. Right-click drag to pan.',
    upstand: 'Click to draw. Snaps to worktop edges. Enter height when done.'
  };
  document.getElementById('statusHint').textContent = hints[t] || '';
}

// ========== ZOOM/PAN ==========
function zoomIn() { scale *= 1.2; updateZoom(); render(); }
function zoomOut() { scale /= 1.2; updateZoom(); render(); }
function updateZoom() { document.getElementById('statusZoom').textContent = Math.round(scale * 500) + '%'; }

function panView(dx, dy) {
  offset.x += dx;
  offset.y += dy;
  render();
}

function zoomFit() {
  if (worktops.length === 0 && upstands.length === 0) {
    offset.x = canvas.width / 2;
    offset.y = canvas.height / 2;
    scale = 0.2;
  } else {
    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
    const VISUAL_DEPTH = 80;
    
    worktops.forEach(w => {
      minX = Math.min(minX, w.x);
      maxX = Math.max(maxX, w.x + w.length);
      minY = Math.min(minY, w.y);
      maxY = Math.max(maxY, w.y + w.depth);
    });
    
    upstands.forEach(u => {
      const parent = worktops.find(w => w.id === u.parentId);
      if (parent && u.parentEdge) {
        // Use parent-based positioning
        if (u.parentEdge === 'back') {
          minX = Math.min(minX, parent.x);
          maxX = Math.max(maxX, parent.x + u.length);
          minY = Math.min(minY, parent.y - VISUAL_DEPTH);
        } else if (u.parentEdge === 'front') {
          minX = Math.min(minX, parent.x);
          maxX = Math.max(maxX, parent.x + u.length);
          maxY = Math.max(maxY, parent.y + parent.depth + VISUAL_DEPTH);
        }
      }
    });
    
    // Ensure valid bounds
    const width = maxX - minX;
    const height = maxY - minY;
    
    if (width <= 0 || height <= 0 || !isFinite(width) || !isFinite(height)) {
      offset.x = canvas.width / 2;
      offset.y = canvas.height / 2;
      scale = 0.2;
    } else {
      const pad = 150;
      scale = Math.min((canvas.width - pad) / (width + pad), (canvas.height - pad) / (height + pad), 0.3);
      scale = Math.max(0.05, Math.min(0.8, scale)); // Clamp scale
      offset.x = canvas.width / 2 - (minX + maxX) / 2 * scale;
      offset.y = canvas.height / 2 - (minY + maxY) / 2 * scale;
    }
  }
  updateZoom();
  render();
}

// ========== JOINT DETECTION ==========
function detectAllJoints() {
  worktops.forEach(w => w.joints = { back: [], front: [], left: [], right: [] });
  for (let i = 0; i < worktops.length; i++) {
    for (let j = i + 1; j < worktops.length; j++) {
      detectJointBetween(worktops[i], worktops[j]);
    }
  }
}

function detectJointBetween(w1, w2) {
  const tol = 20;
  
  // W1 right - W2 left
  if (Math.abs((w1.x + w1.length) - w2.x) < tol) {
    const os = Math.max(w1.y, w2.y);
    const oe = Math.min(w1.y + w1.depth, w2.y + w2.depth);
    if (oe > os) {
      w1.joints.right.push({ start: os - w1.y, end: oe - w1.y, partnerId: w2.id });
      w2.joints.left.push({ start: os - w2.y, end: oe - w2.y, partnerId: w1.id });
    }
  }
  // W1 left - W2 right
  if (Math.abs(w1.x - (w2.x + w2.length)) < tol) {
    const os = Math.max(w1.y, w2.y);
    const oe = Math.min(w1.y + w1.depth, w2.y + w2.depth);
    if (oe > os) {
      w1.joints.left.push({ start: os - w1.y, end: oe - w1.y, partnerId: w2.id });
      w2.joints.right.push({ start: os - w2.y, end: oe - w2.y, partnerId: w1.id });
    }
  }
  // W1 front - W2 back
  if (Math.abs((w1.y + w1.depth) - w2.y) < tol) {
    const os = Math.max(w1.x, w2.x);
    const oe = Math.min(w1.x + w1.length, w2.x + w2.length);
    if (oe > os) {
      w1.joints.front.push({ start: os - w1.x, end: oe - w1.x, partnerId: w2.id });
      w2.joints.back.push({ start: os - w2.x, end: oe - w2.x, partnerId: w1.id });
    }
  }
  // W1 back - W2 front
  if (Math.abs(w1.y - (w2.y + w2.depth)) < tol) {
    const os = Math.max(w1.x, w2.x);
    const oe = Math.min(w1.x + w1.length, w2.x + w2.length);
    if (oe > os) {
      w1.joints.back.push({ start: os - w1.x, end: oe - w1.x, partnerId: w2.id });
      w2.joints.front.push({ start: os - w2.x, end: oe - w2.x, partnerId: w1.id });
    }
  }
}

function getFreeSegments(w, edge) {
  let len = (edge === 'back' || edge === 'front') ? w.length : w.depth;
  
  // Safety check - ensure joints exists
  if (!w.joints) {
    w.joints = { back: [], front: [], left: [], right: [] };
  }
  
  const joints = w.joints[edge] || [];
  
  // Adjust for stepout - the main edge is shortened where stepout exists
  let stepoutOffset = 0;
  let stepoutEnd = len;
  
  if (w.stepout) {
    const s = w.stepout;
    const isVertical = w.depth > w.length;
    
    if (isVertical) {
      // Vertical worktop - stepout affects left/right edges
      if ((s.corner === 'front-left' && edge === 'left') ||
          (s.corner === 'front-right' && edge === 'right')) {
        // Edge ends before stepout starts
        stepoutEnd = w.depth - s.length;
      } else if ((s.corner === 'back-left' && edge === 'left') ||
                 (s.corner === 'back-right' && edge === 'right')) {
        // Edge starts after stepout ends
        stepoutOffset = s.length;
      }
    } else {
      // Horizontal worktop - stepout affects front/back edges
      if ((s.corner === 'front-left' && edge === 'front') ||
          (s.corner === 'back-left' && edge === 'back')) {
        // Edge starts after stepout (stepout.length from left)
        stepoutOffset = s.length;
      } else if ((s.corner === 'front-right' && edge === 'front') ||
                 (s.corner === 'back-right' && edge === 'back')) {
        // Edge ends before stepout (stepout.length from right)
        stepoutEnd = w.length - s.length;
      }
    }
  }
  
  // Start with base segment (adjusted for stepout)
  if (joints.length === 0) {
    return [{ start: stepoutOffset, end: stepoutEnd }];
  }
  
  const sorted = [...joints].sort((a, b) => a.start - b.start);
  const free = [];
  let pos = stepoutOffset;
  
  sorted.forEach(j => {
    // Clamp joint to valid range
    const jStart = Math.max(stepoutOffset, Math.min(stepoutEnd, j.start));
    const jEnd = Math.max(stepoutOffset, Math.min(stepoutEnd, j.end));
    
    if (jStart > pos) free.push({ start: pos, end: jStart });
    pos = Math.max(pos, jEnd);
  });
  
  if (pos < stepoutEnd) free.push({ start: pos, end: stepoutEnd });
  return free.filter(seg => seg.end > seg.start);
}

// ========== SNAPPING ==========
function findSnapPoint(mx, my, excludeId = null, excludeType = null) {
  let best = null, bestDist = SNAP_DIST;
  
  // Snap to worktop corners and edges
  worktops.forEach(w => {
    if (excludeType === 'worktop' && w.id === excludeId) return;
    
    // Corners
    const corners = [
      { x: w.x, y: w.y }, { x: w.x + w.length, y: w.y },
      { x: w.x, y: w.y + w.depth }, { x: w.x + w.length, y: w.y + w.depth }
    ];
    corners.forEach(c => {
      const d = Math.sqrt((mx - c.x) ** 2 + (my - c.y) ** 2);
      if (d < bestDist) { best = { ...c, type: 'corner' }; bestDist = d; }
    });
    
    // Edge alignment (X) - both edges
    [w.x, w.x + w.length].forEach(ex => {
      if (Math.abs(mx - ex) < bestDist) { 
        best = { x: ex, y: my, type: 'edge-x' }; 
        bestDist = Math.abs(mx - ex); 
      }
    });
    
    // Edge alignment (Y) - all 4 edges including back edge for upstands
    [w.y, w.y + w.depth].forEach(ey => {
      if (Math.abs(my - ey) < bestDist) { 
        best = { x: mx, y: ey, type: 'edge-y', worktopId: w.id }; 
        bestDist = Math.abs(my - ey); 
      }
    });
    
    // Also snap to just behind back edge (where upstands typically sit)
    const backEdgeY = w.y - 5; // Just behind worktop
    if (Math.abs(my - backEdgeY) < bestDist) {
      best = { x: mx, y: backEdgeY, type: 'back-edge', worktopId: w.id };
      bestDist = Math.abs(my - backEdgeY);
    }
  });
  
  // Snap to upstand corners and edges
  upstands.forEach(u => {
    if (excludeType === 'upstand' && u.id === excludeId) return;
    
    const uw = u.vertical ? u.thickness : u.length;
    const uh = u.vertical ? u.length : u.thickness;
    
    // All 4 corners
    const corners = [
      { x: u.x, y: u.y }, { x: u.x + uw, y: u.y },
      { x: u.x, y: u.y + uh }, { x: u.x + uw, y: u.y + uh }
    ];
    corners.forEach(c => {
      const d = Math.sqrt((mx - c.x) ** 2 + (my - c.y) ** 2);
      if (d < bestDist) { best = { ...c, type: 'upstand-corner', upstandId: u.id }; bestDist = d; }
    });
    
    // Edge alignment for connecting upstands
    [u.x, u.x + uw].forEach(ex => {
      if (Math.abs(mx - ex) < bestDist) { 
        best = { x: ex, y: my, type: 'upstand-edge-x', upstandId: u.id }; 
        bestDist = Math.abs(mx - ex); 
      }
    });
    [u.y, u.y + uh].forEach(ey => {
      if (Math.abs(my - ey) < bestDist) { 
        best = { x: mx, y: ey, type: 'upstand-edge-y', upstandId: u.id }; 
        bestDist = Math.abs(my - ey); 
      }
    });
  });
  
  return best;
}

// Find snap for dragging an item (snap item edges to other edges)
function findDragSnap(item, itemType) {
  let best = null, bestDist = SNAP_DIST;
  
  if (itemType === 'worktop') {
    const corners = [
      { x: item.x, y: item.y },
      { x: item.x + item.length, y: item.y },
      { x: item.x, y: item.y + item.depth },
      { x: item.x + item.length, y: item.y + item.depth }
    ];
    
    worktops.forEach(w => {
      if (w.id === item.id) return;
      const targets = [
        { x: w.x, y: w.y }, { x: w.x + w.length, y: w.y },
        { x: w.x, y: w.y + w.depth }, { x: w.x + w.length, y: w.y + w.depth }
      ];
      
      corners.forEach(c => {
        targets.forEach(t => {
          const d = Math.sqrt((c.x - t.x) ** 2 + (c.y - t.y) ** 2);
          if (d < bestDist) {
            best = { dx: t.x - c.x, dy: t.y - c.y, x: t.x, y: t.y };
            bestDist = d;
          }
        });
      });
    });
  } else if (itemType === 'upstand') {
    // For upstands, snap is handled differently since they're attached to worktops
    // This is for free-dragging which we don't support for attached upstands
  }
  
  return best;
}

// ========== EDGE DETECTION ==========
function findClickedEdge(mx, my) {
  for (const w of worktops) {
    const edges = [
      { name: 'back', x1: w.x, y1: w.y, x2: w.x + w.length, y2: w.y },
      { name: 'front', x1: w.x, y1: w.y + w.depth, x2: w.x + w.length, y2: w.y + w.depth },
      { name: 'left', x1: w.x, y1: w.y, x2: w.x, y2: w.y + w.depth },
      { name: 'right', x1: w.x + w.length, y1: w.y, x2: w.x + w.length, y2: w.y + w.depth }
    ];
    
    // Add stepout edges if present
    if (w.stepout) {
      const s = w.stepout;
      const isVert = w.depth > w.length; // Vertical if taller than wide
      
      if (isVert) {
        // VERTICAL WORKTOP - stepout extends LEFT/RIGHT
        if (s.corner === 'front-left') {
          // Stepout extends LEFT from bottom-left
          edges.push({ name: 'stepout_outer', x1: w.x - s.depth, y1: w.y + w.depth - s.length, x2: w.x - s.depth, y2: w.y + w.depth, stepoutEdge: true, len: s.length });
          edges.push({ name: 'stepout_bottom', x1: w.x - s.depth, y1: w.y + w.depth, x2: w.x, y2: w.y + w.depth, stepoutEdge: true, len: s.depth });
          edges.push({ name: 'stepout_inner', x1: w.x - s.depth, y1: w.y + w.depth - s.length, x2: w.x, y2: w.y + w.depth - s.length, stepoutEdge: true, len: s.depth });
        } else if (s.corner === 'front-right') {
          // Stepout extends RIGHT from bottom-right
          edges.push({ name: 'stepout_outer', x1: w.x + w.length + s.depth, y1: w.y + w.depth - s.length, x2: w.x + w.length + s.depth, y2: w.y + w.depth, stepoutEdge: true, len: s.length });
          edges.push({ name: 'stepout_bottom', x1: w.x + w.length, y1: w.y + w.depth, x2: w.x + w.length + s.depth, y2: w.y + w.depth, stepoutEdge: true, len: s.depth });
          edges.push({ name: 'stepout_inner', x1: w.x + w.length, y1: w.y + w.depth - s.length, x2: w.x + w.length + s.depth, y2: w.y + w.depth - s.length, stepoutEdge: true, len: s.depth });
        } else if (s.corner === 'back-left') {
          // Stepout extends LEFT from top-left
          edges.push({ name: 'stepout_outer', x1: w.x - s.depth, y1: w.y, x2: w.x - s.depth, y2: w.y + s.length, stepoutEdge: true, len: s.length });
          edges.push({ name: 'stepout_top', x1: w.x - s.depth, y1: w.y, x2: w.x, y2: w.y, stepoutEdge: true, len: s.depth });
          edges.push({ name: 'stepout_inner', x1: w.x - s.depth, y1: w.y + s.length, x2: w.x, y2: w.y + s.length, stepoutEdge: true, len: s.depth });
        } else if (s.corner === 'back-right') {
          // Stepout extends RIGHT from top-right
          edges.push({ name: 'stepout_outer', x1: w.x + w.length + s.depth, y1: w.y, x2: w.x + w.length + s.depth, y2: w.y + s.length, stepoutEdge: true, len: s.length });
          edges.push({ name: 'stepout_top', x1: w.x + w.length, y1: w.y, x2: w.x + w.length + s.depth, y2: w.y, stepoutEdge: true, len: s.depth });
          edges.push({ name: 'stepout_inner', x1: w.x + w.length, y1: w.y + s.length, x2: w.x + w.length + s.depth, y2: w.y + s.length, stepoutEdge: true, len: s.depth });
        }
      } else {
        // HORIZONTAL WORKTOP - stepout extends DOWN/UP
        if (s.corner === 'front-left') {
          // Stepout extends DOWN from front-left
          edges.push({ name: 'stepout_left', x1: w.x, y1: w.y + w.depth, x2: w.x, y2: w.y + w.depth + s.depth, stepoutEdge: true, len: s.depth });
          edges.push({ name: 'stepout_bottom', x1: w.x, y1: w.y + w.depth + s.depth, x2: w.x + s.length, y2: w.y + w.depth + s.depth, stepoutEdge: true, len: s.length });
          edges.push({ name: 'stepout_right', x1: w.x + s.length, y1: w.y + w.depth, x2: w.x + s.length, y2: w.y + w.depth + s.depth, stepoutEdge: true, len: s.depth });
        } else if (s.corner === 'front-right') {
          // Stepout extends DOWN from front-right
          edges.push({ name: 'stepout_right', x1: w.x + w.length, y1: w.y + w.depth, x2: w.x + w.length, y2: w.y + w.depth + s.depth, stepoutEdge: true, len: s.depth });
          edges.push({ name: 'stepout_bottom', x1: w.x + w.length - s.length, y1: w.y + w.depth + s.depth, x2: w.x + w.length, y2: w.y + w.depth + s.depth, stepoutEdge: true, len: s.length });
          edges.push({ name: 'stepout_left', x1: w.x + w.length - s.length, y1: w.y + w.depth, x2: w.x + w.length - s.length, y2: w.y + w.depth + s.depth, stepoutEdge: true, len: s.depth });
        } else if (s.corner === 'back-left') {
          // Stepout extends UP from back-left
          edges.push({ name: 'stepout_left', x1: w.x, y1: w.y - s.depth, x2: w.x, y2: w.y, stepoutEdge: true, len: s.depth });
          edges.push({ name: 'stepout_top', x1: w.x, y1: w.y - s.depth, x2: w.x + s.length, y2: w.y - s.depth, stepoutEdge: true, len: s.length });
          edges.push({ name: 'stepout_right', x1: w.x + s.length, y1: w.y - s.depth, x2: w.x + s.length, y2: w.y, stepoutEdge: true, len: s.depth });
        } else if (s.corner === 'back-right') {
          // Stepout extends UP from back-right
          edges.push({ name: 'stepout_right', x1: w.x + w.length, y1: w.y - s.depth, x2: w.x + w.length, y2: w.y, stepoutEdge: true, len: s.depth });
          edges.push({ name: 'stepout_top', x1: w.x + w.length - s.length, y1: w.y - s.depth, x2: w.x + w.length, y2: w.y - s.depth, stepoutEdge: true, len: s.length });
          edges.push({ name: 'stepout_left', x1: w.x + w.length - s.length, y1: w.y - s.depth, x2: w.x + w.length - s.length, y2: w.y, stepoutEdge: true, len: s.depth });
        }
      }
    }
    
    for (const edge of edges) {
      const dist = pointToLineDist(mx, my, edge.x1, edge.y1, edge.x2, edge.y2);
      if (dist < EDGE_CLICK_DIST) {
        // For stepout edges, return full edge as segment
        if (edge.stepoutEdge) {
          return { worktop: w, edge: edge.name, segment: { start: 0, end: edge.len }, isJoined: false, isStepout: true };
        }
        
        const edgeLen = (edge.name === 'back' || edge.name === 'front') ? w.length : w.depth;
        const posAlong = (edge.name === 'back' || edge.name === 'front') ? mx - w.x : my - w.y;
        
        // First check free segments
        const freeSegs = getFreeSegments(w, edge.name);
        for (const seg of freeSegs) {
          if (posAlong >= seg.start - 20 && posAlong <= seg.end + 20) {
            return { worktop: w, edge: edge.name, segment: seg, isJoined: false };
          }
        }
        
        // Also allow clicking on joined segments (for upstands that span joints)
        const joints = w.joints[edge.name] || [];
        for (const j of joints) {
          if (posAlong >= j.start - 20 && posAlong <= j.end + 20) {
            // Return full edge as segment for joined areas
            return { worktop: w, edge: edge.name, segment: { start: 0, end: edgeLen }, isJoined: true };
          }
        }
      }
    }
  }
  return null;
}

function pointToLineDist(px, py, x1, y1, x2, y2) {
  const A = px - x1, B = py - y1, C = x2 - x1, D = y2 - y1;
  const dot = A * C + B * D, lenSq = C * C + D * D;
  let t = lenSq ? Math.max(0, Math.min(1, dot / lenSq)) : 0;
  return Math.sqrt((px - (x1 + t * C)) ** 2 + (py - (y1 + t * D)) ** 2);
}

// Detect if click is near a worktop corner
const CORNER_CLICK_DIST = 50; // mm tolerance for corner click (reduced from 80)
let cornerMenuTarget = null; // { wId, corner }

function findClickedCorner(mx, my) {
  for (const w of worktops) {
    // Define the four corners: tl=back-left, tr=back-right, br=front-right, bl=front-left
    const corners = [
      { name: 'tl', x: w.x, y: w.y, label: 'Back-Left' },
      { name: 'tr', x: w.x + w.length, y: w.y, label: 'Back-Right' },
      { name: 'br', x: w.x + w.length, y: w.y + w.depth, label: 'Front-Right' },
      { name: 'bl', x: w.x, y: w.y + w.depth, label: 'Front-Left' }
    ];
    
    for (const corner of corners) {
      const dist = Math.sqrt((mx - corner.x) ** 2 + (my - corner.y) ** 2);
      if (dist < CORNER_CLICK_DIST) {
        return { worktop: w, corner: corner.name, label: corner.label, x: corner.x, y: corner.y };
      }
    }
  }
  return null;
}

// ========== EDGE MENU ==========
let edgeMenuJustOpened = false;
let edgeMenuOpenTime = 0;

function showEdgeMenu(sx, sy, wId, edge, seg) {
  edgeMenuTarget = { wId, edge, seg };
  const menu = document.getElementById('edgeMenu');
  
  // Log which edge was clicked for debugging
  const w = worktops.find(wt => wt.id === wId);
  const edgeDesc = edge === 'back' ? 'BACK (wall side)' : 
                   edge === 'front' ? 'FRONT (room side)' :
                   edge === 'left' ? 'LEFT' : 'RIGHT';
  
  console.log('EDGE MENU OPENED:', {
    edge: edge,
    edgeDescription: edgeDesc,
    worktop: w ? w.name : 'unknown',
    worktopBounds: w ? { x: w.x, y: w.y, length: w.length, depth: w.depth } : null
  });
  
  // Update status bar to show which edge
  document.getElementById('statusHint').textContent = `Selected ${edgeDesc} edge of ${w ? w.name : 'worktop'}`;
  
  // Show/hide remove split option based on whether worktop has splits
  const removeSplitOption = document.getElementById('removeSplitOption');
  if (removeSplitOption) {
    removeSplitOption.style.display = (w && w.splits && w.splits.length > 0) ? 'flex' : 'none';
  }
  
  // Set initial position before showing (will be adjusted after)
  menu.style.left = sx + 'px';
  menu.style.top = sy + 'px';
  menu.style.display = 'block';
  
  edgeMenuOpenTime = Date.now();
  edgeMenuJustOpened = true;
  
  // Reposition after rendering if needed
  requestAnimationFrame(() => {
    const menuRect = menu.getBoundingClientRect();
    const viewportHeight = window.innerHeight;
    const viewportWidth = window.innerWidth;
    
    // Adjust if menu would go off bottom
    let finalY = sy;
    if (sy + menuRect.height > viewportHeight - 10) {
      finalY = Math.max(10, viewportHeight - menuRect.height - 10);
    }
    
    // Adjust if menu would go off right
    let finalX = sx;
    if (sx + menuRect.width > viewportWidth - 10) {
      finalX = Math.max(10, viewportWidth - menuRect.width - 10);
    }
    
    menu.style.left = finalX + 'px';
    menu.style.top = finalY + 'px';
  });
  
  // Prevent immediate closing for 500ms
  setTimeout(() => { edgeMenuJustOpened = false; }, 500);
}

function hideEdgeMenu() {
  // Don't hide if just opened (within 300ms)
  if (edgeMenuJustOpened || (Date.now() - edgeMenuOpenTime < 300)) return;
  document.getElementById('edgeMenu').style.display = 'none';
  edgeMenuTarget = null;
}

// ========== CORNER MENU ==========
let cornerMenuJustOpened = false;
let cornerMenuOpenTime = 0;

function showCornerMenu(sx, sy, wId, corner, label) {
  cornerMenuTarget = { wId, corner, label };
  const menu = document.getElementById('cornerMenu');
  const w = worktops.find(wt => wt.id === wId);
  
  // Update menu title
  document.getElementById('cornerMenuTitle').textContent = `${w ? w.name : 'Worktop'} - ${label} Corner`;
  
  // Check if this corner already has a radius
  const radii = w?.cornerRadii || {};
  const hasRadius = radii[corner] > 0;
  
  // Show/hide appropriate menu items for radius
  document.getElementById('cornerAddRadius').style.display = hasRadius ? 'none' : 'flex';
  document.getElementById('cornerEditRadius').style.display = hasRadius ? 'flex' : 'none';
  document.getElementById('cornerRemoveRadius').style.display = hasRadius ? 'flex' : 'none';
  
  // Update edit text with current value
  if (hasRadius) {
    document.getElementById('cornerEditRadius').innerHTML = `<div class="dot" style="background:#ff9800;"></div> Edit Radius (${radii[corner]}mm)`;
  }
  
  // Check if this worktop has a stepout at this corner
  const hasStepout = w?.stepout && w.stepout.corner === corner;
  const hasAnyStepout = w?.stepout;
  
  // Show/hide stepout options
  // Can only add stepout if worktop doesn't have one, or edit/remove if this corner has one
  document.getElementById('cornerAddStepout').style.display = hasAnyStepout ? 'none' : 'flex';
  document.getElementById('cornerEditStepout').style.display = hasStepout ? 'flex' : 'none';
  document.getElementById('cornerRemoveStepout').style.display = hasStepout ? 'flex' : 'none';
  
  // Update edit text with current stepout values
  if (hasStepout) {
    document.getElementById('cornerEditStepout').innerHTML = `<div class="dot" style="background:#ff9800;"></div> Edit Stepout (${w.stepout.length}√ó${w.stepout.depth}mm)`;
  }
  
  // Position menu
  menu.style.left = sx + 'px';
  menu.style.top = sy + 'px';
  menu.style.display = 'block';
  
  cornerMenuOpenTime = Date.now();
  cornerMenuJustOpened = true;
  
  // Reposition after rendering if needed
  requestAnimationFrame(() => {
    const menuRect = menu.getBoundingClientRect();
    const viewportHeight = window.innerHeight;
    const viewportWidth = window.innerWidth;
    
    let finalY = sy;
    if (sy + menuRect.height > viewportHeight - 10) {
      finalY = Math.max(10, viewportHeight - menuRect.height - 10);
    }
    
    let finalX = sx;
    if (sx + menuRect.width > viewportWidth - 10) {
      finalX = Math.max(10, viewportWidth - menuRect.width - 10);
    }
    
    menu.style.left = finalX + 'px';
    menu.style.top = finalY + 'px';
  });
  
  setTimeout(() => { cornerMenuJustOpened = false; }, 500);
}

function hideCornerMenu() {
  if (cornerMenuJustOpened || (Date.now() - cornerMenuOpenTime < 300)) return;
  document.getElementById('cornerMenu').style.display = 'none';
  cornerMenuTarget = null;
}

function addCornerRadius() {
  if (!cornerMenuTarget) return;
  
  const radiusStr = prompt('Enter corner radius (mm):\n\nCommon sizes: 50, 100, 150', '100');
  if (!radiusStr) {
    hideCornerMenu();
    return;
  }
  
  const radius = parseInt(radiusStr) || 0;
  if (radius > 0) {
    updateCornerRadius(cornerMenuTarget.wId, cornerMenuTarget.corner, radius);
  }
  
  document.getElementById('cornerMenu').style.display = 'none';
  cornerMenuTarget = null;
}

function editCornerRadius() {
  if (!cornerMenuTarget) return;
  
  const w = worktops.find(wt => wt.id === cornerMenuTarget.wId);
  const currentRadius = w?.cornerRadii?.[cornerMenuTarget.corner] || 0;
  
  const radiusStr = prompt('Edit corner radius (mm):', currentRadius.toString());
  if (radiusStr === null) {
    hideCornerMenu();
    return;
  }
  
  const radius = parseInt(radiusStr) || 0;
  updateCornerRadius(cornerMenuTarget.wId, cornerMenuTarget.corner, radius);
  
  document.getElementById('cornerMenu').style.display = 'none';
  cornerMenuTarget = null;
}

function removeCornerRadius() {
  if (!cornerMenuTarget) return;
  
  updateCornerRadius(cornerMenuTarget.wId, cornerMenuTarget.corner, 0);
  
  document.getElementById('cornerMenu').style.display = 'none';
  cornerMenuTarget = null;
}

function addUpstandToAllBackEdges() {
  saveHistory();
  const height = prompt('Upstand height (mm) - 100 for upstand, 300+ for splash:', '100');
  if (!height) return;
  
  const h = parseInt(height) || 100;
  const isSplash = h > 150;
  const MAX_LENGTH = 3200;
  
  // Remove ALL existing back edge upstands first
  upstands = upstands.filter(u => u.parentEdge !== 'back');
  
  // Collect all back edge segments with their X ranges
  const segments = [];
  worktops.forEach(w => {
    segments.push({
      y: w.y,  // Back edge Y position
      xStart: w.x,
      xEnd: w.x + w.length,
      worktop: w
    });
  });
  
  // Sort by Y then by X
  segments.sort((a, b) => a.y - b.y || a.xStart - b.xStart);
  
  // Merge segments that are on the same Y level (within tolerance)
  const merged = [];
  segments.forEach(seg => {
    // Find existing group at same Y level
    let found = null;
    for (let m of merged) {
      if (Math.abs(m.y - seg.y) < 30) {
        found = m;
        break;
      }
    }
    
    if (found) {
      // Extend the existing group
      found.xStart = Math.min(found.xStart, seg.xStart);
      found.xEnd = Math.max(found.xEnd, seg.xEnd);
      found.worktops.push(seg.worktop);
    } else {
      // Create new group
      merged.push({
        y: seg.y,
        xStart: seg.xStart,
        xEnd: seg.xEnd,
        worktops: [seg.worktop]
      });
    }
  });
  
  console.log('Merged back edge groups:', merged);
  
  // Create upstands per merged group - split at ONE seam if > 3200mm
  merged.forEach(group => {
    const totalLength = group.xEnd - group.xStart;
    
    // Sort worktops by X and store joint positions
    group.worktops.sort((a, b) => a.x - b.x);
    const joints = [];
    let cumulative = 0;
    for (let i = 0; i < group.worktops.length - 1; i++) {
      cumulative += group.worktops[i].length;
      joints.push(group.xStart + cumulative); // Absolute position
    }
    
    if (totalLength > MAX_LENGTH) {
      // Find first valid joint to split at
      let splitAt = null;
      for (const j of joints) {
        const relJ = j - group.xStart;
        if (relJ <= MAX_LENGTH && (totalLength - relJ) <= MAX_LENGTH) {
          splitAt = relJ;
          break;
        }
      }
      
      if (splitAt !== null) {
        upstands.push({
          id: nextId++,
          absoluteX: group.xStart,
          absoluteY: group.y,
          x: group.xStart,
          y: group.y,
          length: splitAt,
          height: h,
          vertical: false,
          isSplash,
          isContinuous: true,
          parentEdge: 'back',
          parentId: group.worktops[0].id,
          edgeStart: 0,
          joints: joints
        });
        
        upstands.push({
          id: nextId++,
          absoluteX: group.xStart + splitAt,
          absoluteY: group.y,
          x: group.xStart + splitAt,
          y: group.y,
          length: totalLength - splitAt,
          height: h,
          vertical: false,
          isSplash,
          isContinuous: true,
          parentEdge: 'back',
          parentId: group.worktops[0].id,
          edgeStart: splitAt,
          joints: joints
        });
        console.log('Split at seam:', splitAt + 'mm + ' + (totalLength - splitAt) + 'mm');
      } else {
        // No valid seam
        upstands.push({
          id: nextId++,
          absoluteX: group.xStart,
          absoluteY: group.y,
          x: group.xStart,
          y: group.y,
          length: totalLength,
          height: h,
          vertical: false,
          isSplash,
          isContinuous: true,
          parentEdge: 'back',
          parentId: group.worktops[0].id,
          edgeStart: 0,
          joints: joints
        });
      }
    } else {
      // <= 3200mm - one piece
      upstands.push({
        id: nextId++,
        absoluteX: group.xStart,
        absoluteY: group.y,
        x: group.xStart,
        y: group.y,
        length: totalLength,
        height: h,
        vertical: false,
        isSplash,
        isContinuous: true,
        parentEdge: 'back',
        parentId: group.worktops[0].id,
        edgeStart: 0,
        joints: joints
      });
      console.log('Created one piece:', totalLength + 'mm');
    }
  });
  
  hideEdgeMenu();
  renderLists();
  render();
  updateSummary();
}

// Add a splashback at a specific position (for splitting upstands)
function addPositionedSplashback() {
  if (!edgeMenuTarget) return;
  
  const w = worktops.find(w => w.id === edgeMenuTarget.wId);
  if (!w) return;
  
  const { edge } = edgeMenuTarget;
  const edgeLen = (edge === 'back' || edge === 'front') ? w.length : w.depth;
  
  const length = prompt('Splashback length (mm):', '600');
  if (!length) return;
  
  const centerPos = prompt(`Centre position (mm from left, 0-${edgeLen}):`, Math.round(edgeLen / 2).toString());
  if (!centerPos) return;
  
  const height = prompt('Splashback height (mm):', '300');
  if (!height) return;
  
  const len = Math.min(parseInt(length) || 600, edgeLen);
  const center = Math.max(len/2, Math.min(parseInt(centerPos) || edgeLen/2, edgeLen - len/2));
  const start = Math.round(center - len/2);
  const h = parseInt(height) || 300;
  
  saveHistory();
  
  // Calculate absolute position
  let absX, absY;
  if (edge === 'back') {
    absX = w.x + start;
    absY = w.y;
  } else if (edge === 'front') {
    absX = w.x + start;
    absY = w.y + w.depth;
  } else if (edge === 'left') {
    absX = w.x;
    absY = w.y + start;
  } else {
    absX = w.x + w.length;
    absY = w.y + start;
  }
  
  upstands.push({
    id: nextId++,
    absoluteX: absX,
    absoluteY: absY,
    x: absX,
    y: absY,
    length: len,
    height: h,
    vertical: (edge === 'left' || edge === 'right'),
    isSplash: true,
    parentId: w.id,
    parentEdge: edge,
    edgeStart: start
  });
  
  hideEdgeMenu();
  renderLists();
  
  // This splashback should split any existing upstand
  checkAndSplitUpstands();
  
  render();
  updateSummary();
}

// Add a window cill - horizontal shelf that sits ON TOP of splashback
function addWindowCill() {
  if (!edgeMenuTarget) return;
  
  const w = worktops.find(w => w.id === edgeMenuTarget.wId);
  if (!w) return;
  
  const { edge } = edgeMenuTarget;
  const edgeLen = (edge === 'back' || edge === 'front') ? w.length : w.depth;
  
  // Auto-detect existing upstand/splashback height on this edge
  let detectedHeight = null; // Start with null to know if we found one
  const edgeY = (edge === 'back') ? w.y : (edge === 'front') ? w.y + w.depth : null;
  const edgeX = (edge === 'left') ? w.x : (edge === 'right') ? w.x + w.length : null;
  
  console.log('Looking for upstands on edge:', edge, 'edgeY:', edgeY, 'edgeX:', edgeX);
  console.log('All upstands:', upstands);
  
  // Check all upstands (both regular and splashbacks)
  upstands.forEach(u => {
    if (u.isWindowCill) return; // Skip cills
    
    console.log('Checking upstand:', u.id, 'parentEdge:', u.parentEdge, 'height:', u.height, 'absoluteY:', u.absoluteY, 'y:', u.y);
    
    // Method 1: Same parent and edge
    if (u.parentEdge === edge && u.parentId === w.id) {
      detectedHeight = u.height;
      console.log('MATCH: Same parent and edge, height:', u.height);
      return;
    }
    
    // Method 2: Same edge type (back/front/left/right)
    if (u.parentEdge === edge) {
      detectedHeight = u.height;
      console.log('MATCH: Same edge type, height:', u.height);
      return;
    }
    
    // Method 3: Check by position
    if (edge === 'back' || edge === 'front') {
      // Get the Y position of this upstand's edge
      let uEdgeY = null;
      if (u.absoluteY !== undefined) {
        uEdgeY = u.absoluteY;
      } else if (u.parentEdge === 'back') {
        const uParent = worktops.find(wt => wt.id === u.parentId);
        if (uParent) uEdgeY = uParent.y;
      } else if (u.parentEdge === 'front') {
        const uParent = worktops.find(wt => wt.id === u.parentId);
        if (uParent) uEdgeY = uParent.y + uParent.depth;
      }
      
      if (uEdgeY !== null && edgeY !== null && Math.abs(uEdgeY - edgeY) < 50) {
        detectedHeight = u.height;
        console.log('MATCH: Position match Y, height:', u.height);
      }
    } else if (edge === 'left' || edge === 'right') {
      let uEdgeX = null;
      if (u.absoluteX !== undefined) {
        uEdgeX = u.absoluteX;
      } else if (u.parentEdge === 'left') {
        const uParent = worktops.find(wt => wt.id === u.parentId);
        if (uParent) uEdgeX = uParent.x;
      } else if (u.parentEdge === 'right') {
        const uParent = worktops.find(wt => wt.id === u.parentId);
        if (uParent) uEdgeX = uParent.x + uParent.length;
      }
      
      if (uEdgeX !== null && edgeX !== null && Math.abs(uEdgeX - edgeX) < 50) {
        detectedHeight = u.height;
        console.log('MATCH: Position match X, height:', u.height);
      }
    }
  });
  
  // Use detected height or default to 100 (standard upstand)
  const finalHeight = detectedHeight || 100;
  console.log('Final detected height:', finalHeight);
  
  const length = prompt('Window cill length (mm):', '1000');
  if (!length) return;
  
  const centerPos = prompt(`Centre position (mm from left, 0-${edgeLen}):`, Math.round(edgeLen / 2).toString());
  if (!centerPos) return;
  
  const depth = prompt('Window cill depth/projection (mm):', '200');
  if (!depth) return;
  
  const heightPrompt = detectedHeight 
    ? `Height from worktop to cill (mm):\n(Detected: ${detectedHeight}mm upstand/splashback)`
    : 'Height from worktop to cill (mm):';
  const cillHeight = prompt(heightPrompt, finalHeight.toString());
  if (!cillHeight) return;
  
  const len = parseInt(length) || 1000;  // Don't limit cill length by worktop edge - cills can span joints
  const center = parseInt(centerPos) || edgeLen/2;
  const start = Math.round(center - len/2);
  const d = parseInt(depth) || 200;
  const h = parseInt(cillHeight) || 300;
  
  saveHistory();
  
  // Calculate absolute position
  let absX, absY;
  if (edge === 'back') {
    absX = w.x + start;
    absY = w.y;
  } else if (edge === 'front') {
    absX = w.x + start;
    absY = w.y + w.depth;
  } else if (edge === 'left') {
    absX = w.x;
    absY = w.y + start;
  } else {
    absX = w.x + w.length;
    absY = w.y + start;
  }
  
  // Window cill is a horizontal piece that sits ON TOP of splashback
  // It has: length, depth (projection), and is at a certain height
  upstands.push({
    id: nextId++,
    absoluteX: absX,
    absoluteY: absY,
    x: absX,
    y: absY,
    length: len,           // Length along the window
    height: h,             // Height from worktop (where it sits)
    depth: d,              // How far it projects out (into room)
    overhang: 20,          // How much it overhangs the splashback
    vertical: (edge === 'left' || edge === 'right'),
    isSplash: false,
    isWindowCill: true,
    parentId: w.id,
    parentEdge: edge,
    edgeStart: start
  });
  
  hideEdgeMenu();
  renderLists();
  render();
  updateSummary();
}

// Socket cutout for upstands and splashbacks
let pendingSocketData = null;

function addSocketCutout() {
  // First check if an upstand/splashback is selected - use that one
  if (selectedType === 'upstand' && selectedId) {
    const selectedUpstand = upstands.find(u => u.id === selectedId);
    if (selectedUpstand) {
      console.log('Adding socket to SELECTED upstand/splashback:', selectedUpstand.id);
      pendingSocketData = { targetUpstand: selectedUpstand };
      hideEdgeMenu();
      document.getElementById('socketModal').style.display = 'flex';
      return;
    }
  }
  
  // Fallback: use edge menu target
  if (!edgeMenuTarget) {
    alert('Please select an upstand/splashback or click on an edge first.');
    hideEdgeMenu();
    return;
  }
  
  const { wId, edge } = edgeMenuTarget;
  const w = worktops.find(wt => wt.id === wId);
  if (!w) { hideEdgeMenu(); return; }
  
  // Find upstands/splashbacks on THIS edge - if multiple, warn user to select one
  const edgeUpstands = upstands.filter(u => 
    u.parentId === wId && 
    u.parentEdge === edge
  );
  
  if (edgeUpstands.length === 0) {
    alert(`No upstand/splashback on the ${edge} edge of ${w.name || 'this worktop'}.\n\nPlease add an upstand or splashback first, then add socket cutouts to it.`);
    hideEdgeMenu();
    return;
  }
  
  if (edgeUpstands.length > 1) {
    alert(`Multiple pieces on this edge.\n\nPlease double-click the specific upstand/splashback you want to add the socket to, then use the "Add Socket" button.`);
    hideEdgeMenu();
    return;
  }
  
  const targetUpstand = edgeUpstands[0];
  console.log('Adding socket to upstand/splashback:', targetUpstand.id, 'on', edge, 'edge');
  
  // Store target for the modal
  pendingSocketData = { targetUpstand: targetUpstand };
  hideEdgeMenu();
  document.getElementById('socketModal').style.display = 'flex';
}

function selectSocketSize(size) {
  document.getElementById('socketModal').style.display = 'none';
  
  if (!pendingSocketData || !pendingSocketData.targetUpstand) {
    console.warn('No target upstand for socket');
    pendingSocketData = null;
    return;
  }
  
  // Re-fetch the upstand in case it was recreated
  let targetUpstand = upstands.find(u => u.id === pendingSocketData.targetUpstand.id);
  if (!targetUpstand) {
    // Upstand was deleted/recreated - try to find by position
    const orig = pendingSocketData.targetUpstand;
    targetUpstand = upstands.find(u => 
      u.parentEdge === orig.parentEdge && 
      u.absoluteX === orig.absoluteX && 
      u.absoluteY === orig.absoluteY
    );
  }
  
  if (!targetUpstand) {
    alert('The upstand was modified. Please select it again and add the socket.');
    pendingSocketData = null;
    return;
  }
  
  let sw, sh;
  if (size === 'single') {
    sw = 73; sh = 73;
  } else if (size === 'double') {
    sw = 133; sh = 73;
  } else {
    // Custom size
    const width = prompt('Socket cutout WIDTH (mm):', '133');
    if (!width) { pendingSocketData = null; return; }
    const height = prompt('Socket cutout HEIGHT (mm):', '73');
    if (!height) { pendingSocketData = null; return; }
    sw = parseInt(width) || 133;
    sh = parseInt(height) || 73;
  }
  
  // Default position: center of upstand/splashback
  const centerX = targetUpstand.length / 2;
  const centerY = targetUpstand.height / 2;
  
  saveHistory();
  
  // Add socket cutout to cutouts array - positioned at center, user can drag
  cutouts.push({
    id: nextId++,
    type: 'socket',
    parentId: targetUpstand.id,
    parentType: targetUpstand.isSplash ? 'splashback' : 'upstand',
    width: sw,
    height: sh,
    centerX: centerX,    // Center position from left of upstand
    centerY: centerY,    // Center position from bottom of upstand
    draggable: true
  });
  
  console.log(`Socket added to ${targetUpstand.isSplash ? 'splashback' : 'upstand'} ${targetUpstand.id} at center (${centerX}, ${centerY}) - drag to reposition`);
  
  pendingSocketData = null;
  renderLists();
  render();
  updateSummary();
  
  // Show hint about dragging
  document.getElementById('statusHint').textContent = 'Socket added at center. Select it and drag to reposition.';
}

function cancelSocketModal() {
  document.getElementById('socketModal').style.display = 'none';
  pendingSocketData = null;
}

// ========== STEPOUT (L-SHAPE) FUNCTIONS ==========
let stepoutTargetWorktopId = null;

function showStepoutModal(worktopId) {
  const w = worktops.find(wt => wt.id === worktopId);
  if (!w) return;
  
  stepoutTargetWorktopId = worktopId;
  
  // Set default values based on orientation
  const isVertical = w.depth > w.length;
  const maxStepLen = isVertical ? w.depth - 100 : w.length - 100;
  document.getElementById('stepoutLength').value = Math.min(620, maxStepLen);
  document.getElementById('stepoutDepth').value = 100;
  document.getElementById('stepoutCorner').value = 'front-left';
  
  document.getElementById('stepoutModal').style.display = 'flex';
}

function cancelStepoutModal() {
  document.getElementById('stepoutModal').style.display = 'none';
  stepoutTargetWorktopId = null;
}

function confirmStepout() {
  if (!stepoutTargetWorktopId) return;
  
  const w = worktops.find(wt => wt.id === stepoutTargetWorktopId);
  if (!w) return;
  
  const corner = document.getElementById('stepoutCorner').value;
  const length = parseInt(document.getElementById('stepoutLength').value) || 620;
  const depth = parseInt(document.getElementById('stepoutDepth').value) || 100;
  
  const isVertical = w.depth > w.length;
  
  // Validate stepout fits within worktop
  // For vertical worktops, stepout extends along depth; for horizontal, along length
  if (isVertical) {
    if (length > w.depth - 50) {
      alert('Stepout length cannot exceed worktop depth minus 50mm');
      return;
    }
    if (depth > w.length) {
      alert('Stepout depth cannot exceed worktop width');
      return;
    }
  } else {
    if (length > w.length - 50) {
      alert('Stepout length cannot exceed worktop length minus 50mm');
      return;
    }
  }
  
  // Add stepout to worktop
  w.stepout = {
    corner: corner,
    length: length,
    depth: depth
  };
  
  cancelStepoutModal();
  render();
  if (currentView === '3d') render3D();
  renderLists();
  saveDesignState();
  
  document.getElementById('statusHint').textContent = `Stepout added to ${w.name} (${corner})`;
}

function removeStepout(worktopId) {
  const w = worktops.find(wt => wt.id === worktopId);
  if (w && w.stepout) {
    delete w.stepout;
    render();
    if (currentView === '3d') render3D();
    renderLists();
    saveDesignState();
    document.getElementById('statusHint').textContent = `Stepout removed from ${w.name}`;
  }
}

// Corner menu stepout functions
function showStepoutModalFromCorner() {
  if (!cornerMenuTarget) return;
  
  const w = worktops.find(wt => wt.id === cornerMenuTarget.wId);
  if (!w) return;
  
  // Map tl/tr/bl/br to front-left etc
  const cornerMap = {
    'tl': 'back-left', 'tr': 'back-right',
    'bl': 'front-left', 'br': 'front-right'
  };
  const corner = cornerMap[cornerMenuTarget.corner] || cornerMenuTarget.corner;
  document.getElementById('stepoutCorner').value = corner;
  
  // Show human-readable corner name
  const cornerNames = {
    'back-left': 'Back Left', 'back-right': 'Back Right',
    'front-left': 'Front Left', 'front-right': 'Front Right'
  };
  document.getElementById('stepoutCornerLabel').textContent = cornerNames[corner] || corner;
  
  // Set sensible defaults based on orientation
  const isVertical = w.depth > w.length;
  const maxStepLen = isVertical ? w.depth - 100 : w.length - 100;
  document.getElementById('stepoutLength').value = Math.min(620, maxStepLen);
  document.getElementById('stepoutDepth').value = 100;
  
  stepoutTargetWorktopId = cornerMenuTarget.wId;
  document.getElementById('cornerMenu').style.display = 'none';
  document.getElementById('stepoutModal').style.display = 'flex';
}

function editStepoutFromCorner() {
  if (!cornerMenuTarget) return;
  
  const w = worktops.find(wt => wt.id === cornerMenuTarget.wId);
  if (!w || !w.stepout) return;
  
  // Pre-fill with current values
  document.getElementById('stepoutCorner').value = w.stepout.corner;
  document.getElementById('stepoutLength').value = w.stepout.length;
  document.getElementById('stepoutDepth').value = w.stepout.depth;
  
  stepoutTargetWorktopId = cornerMenuTarget.wId;
  document.getElementById('cornerMenu').style.display = 'none';
  document.getElementById('stepoutModal').style.display = 'flex';
}

function removeStepoutFromCorner() {
  if (!cornerMenuTarget) return;
  removeStepout(cornerMenuTarget.wId);
  document.getElementById('cornerMenu').style.display = 'none';
}

// ========== WORKTOP DOUBLE-CLICK EDIT ==========
let editingWorktopId = null;

function showWorktopEditModal(worktopId) {
  const w = worktops.find(wt => wt.id === worktopId);
  if (!w) return;
  
  editingWorktopId = worktopId;
  
  document.getElementById('worktopEditTitle').textContent = `Edit ${w.name}`;
  document.getElementById('editWorktopLength').value = w.length;
  document.getElementById('editWorktopDepth').value = w.depth;
  document.getElementById('editWorktopName').value = w.name;
  document.getElementById('worktopEditModal').style.display = 'flex';
  
  // Focus on length input
  setTimeout(() => document.getElementById('editWorktopLength').select(), 100);
}

function cancelWorktopEdit() {
  document.getElementById('worktopEditModal').style.display = 'none';
  editingWorktopId = null;
}

function applyWorktopEdit() {
  if (!editingWorktopId) return;
  
  const w = worktops.find(wt => wt.id === editingWorktopId);
  if (!w) return;
  
  const newLength = parseInt(document.getElementById('editWorktopLength').value) || w.length;
  const newDepth = parseInt(document.getElementById('editWorktopDepth').value) || w.depth;
  const newName = document.getElementById('editWorktopName').value || w.name;
  
  // Get slab dimensions
  const slabWInput = document.getElementById('slabWidthInput');
  const slabHInput = document.getElementById('slabHeightInput');
  const SLAB_W = slabWInput ? parseInt(slabWInput.value) || 3200 : 3200;
  const SLAB_H = slabHInput ? parseInt(slabHInput.value) || 1600 : 1600;
  
  // Check if new size would exceed slab dimensions
  const canFitNormal = newLength <= SLAB_W && newDepth <= SLAB_H;
  const canFitRotated = newLength <= SLAB_H && newDepth <= SLAB_W;
  
  if (!canFitNormal && !canFitRotated) {
    alert(`‚ö†Ô∏è Worktop too large!\n\nRequested size: ${newLength}mm √ó ${newDepth}mm\nMax slab size: ${SLAB_W}mm √ó ${SLAB_H}mm\n\nPlease use a smaller size or split into multiple pieces with joints.`);
    return;
  }
  
  saveHistory();
  
  const oldLength = w.length;
  const oldDepth = w.depth;
  const oldX = w.x;
  const oldY = w.y;
  const tol = 30;
  
  // Check which sides have joints BEFORE making changes
  const hasJointRight = w.joints.right && w.joints.right.length > 0;
  const hasJointLeft = w.joints.left && w.joints.left.length > 0;
  const hasJointFront = w.joints.front && w.joints.front.length > 0;
  const hasJointBack = w.joints.back && w.joints.back.length > 0;
  
  // Handle length change
  if (newLength !== oldLength) {
    const diff = newLength - oldLength;
    
    if (hasJointRight && !hasJointLeft) {
      // Joint on RIGHT - keep right edge fixed, resize from left
      w.length = newLength;
      w.x = oldX + oldLength - newLength;
    } else if (hasJointLeft && !hasJointRight) {
      // Joint on LEFT - keep left edge fixed, resize from right, move connected
      w.length = newLength;
      const rightEdge = oldX + oldLength;
      const rightConnected = [];
      worktops.forEach(other => {
        if (other.id === w.id) return;
        if (Math.abs(other.x - rightEdge) <= tol) {
          if (Math.max(w.y, other.y) < Math.min(w.y + w.depth, other.y + other.depth)) {
            rightConnected.push(other);
          }
        }
      });
      if (rightConnected.length > 0) {
        const moved = [w.id];
        rightConnected.forEach(p => moveWithCascade(p, 'x', diff, moved, tol));
      }
    } else if (hasJointLeft && hasJointRight) {
      // Joints on BOTH - resize from right, move connected
      w.length = newLength;
      const rightEdge = oldX + oldLength;
      const rightConnected = [];
      worktops.forEach(other => {
        if (other.id === w.id) return;
        if (Math.abs(other.x - rightEdge) <= tol) {
          if (Math.max(w.y, other.y) < Math.min(w.y + w.depth, other.y + other.depth)) {
            rightConnected.push(other);
          }
        }
      });
      if (rightConnected.length > 0) {
        const moved = [w.id];
        rightConnected.forEach(p => moveWithCascade(p, 'x', diff, moved, tol));
      }
    } else {
      // No joints - check for back/front connections on right side (for G-shape W4)
      let backFrontConnectionOnRight = false;
      const frontEdge = w.y + w.depth;
      const backEdge = w.y;
      
      worktops.forEach(other => {
        if (other.id === w.id) return;
        if (Math.abs((other.y + other.depth) - backEdge) <= tol) {
          const overlapStart = Math.max(w.x, other.x);
          const overlapEnd = Math.min(w.x + w.length, other.x + other.length);
          if (overlapEnd > overlapStart) {
            const overlapCenter = (overlapStart + overlapEnd) / 2;
            const myCenter = w.x + w.length / 2;
            if (overlapCenter > myCenter) backFrontConnectionOnRight = true;
          }
        }
        if (Math.abs(other.y - frontEdge) <= tol) {
          const overlapStart = Math.max(w.x, other.x);
          const overlapEnd = Math.min(w.x + w.length, other.x + other.length);
          if (overlapEnd > overlapStart) {
            const overlapCenter = (overlapStart + overlapEnd) / 2;
            const myCenter = w.x + w.length / 2;
            if (overlapCenter > myCenter) backFrontConnectionOnRight = true;
          }
        }
      });
      
      if (backFrontConnectionOnRight) {
        w.length = newLength;
        w.x = oldX + oldLength - newLength;
      } else {
        w.length = newLength;
      }
    }
  }
  
  // Handle depth change
  if (newDepth !== oldDepth) {
    const diff = newDepth - oldDepth;
    const frontEdge = oldY + oldDepth;
    
    // For depth changes, ALWAYS keep back edge fixed (against wall)
    // and move any pieces connected to our front edge
    
    // Find pieces connected to our front edge BEFORE changing depth
    const frontConnected = [];
    worktops.forEach(other => {
      if (other.id === w.id) return;
      if (Math.abs(other.y - frontEdge) <= tol) {
        if (Math.max(w.x, other.x) < Math.min(w.x + w.length, other.x + other.length)) {
          frontConnected.push(other);
        }
      }
    });
    
    // Update depth (back edge stays at y, front edge moves)
    w.depth = newDepth;
    
    // Move front-connected pieces
    if (frontConnected.length > 0) {
      const moved = [w.id];
      frontConnected.forEach(p => moveWithCascade(p, 'y', diff, moved, tol));
    }
  }
  
  // Update edge profiles to match new dimensions
  if (newLength !== oldLength) {
    updateDropdownsForResize(w, 'length', oldLength, newLength);
  }
  if (newDepth !== oldDepth) {
    updateDropdownsForResize(w, 'depth', oldDepth, newDepth);
  }
  
  // Update name
  w.name = newName;
  
  // Auto-resize attached upstands
  if (newLength !== oldLength || newDepth !== oldDepth) {
    autoResizeUpstands(w, oldLength, oldDepth);
  }
  
  // Recalculate joints
  detectAllJoints();
  
  // Realign edge profiles to match current free segments
  if (newLength !== oldLength || newDepth !== oldDepth) {
    realignEdgeProfiles(w);
  }
  
  document.getElementById('worktopEditModal').style.display = 'none';
  editingWorktopId = null;
  
  renderLists();
  render();
  renderProps();
  updateSummary();
  if (currentView === '3d') render3D();
}

// Handle Enter key in edit modal
document.addEventListener('keydown', e => {
  if (document.getElementById('worktopEditModal').style.display === 'flex') {
    if (e.key === 'Enter') {
      applyWorktopEdit();
    } else if (e.key === 'Escape') {
      cancelWorktopEdit();
    }
  }
  // Handle upstand split modal
  if (document.getElementById('upstandSplitModal').style.display === 'flex') {
    if (e.key === 'Enter') {
      applyUpstandSplit();
    } else if (e.key === 'Escape') {
      cancelUpstandSplit();
    }
  }
  // Handle cill edit modal
  if (document.getElementById('cillEditModal').style.display === 'flex') {
    if (e.key === 'Enter') {
      applyCillEdit();
    } else if (e.key === 'Escape') {
      cancelCillEdit();
    }
  }
  // Handle profile modal escape
  if (document.getElementById('profileModal').style.display === 'flex') {
    if (e.key === 'Escape') {
      cancelProfileSelection();
    }
  }
});

// ========== EDGE PROFILE SELECTION ==========
function showProfileModal() {
  // Force hide edge menu immediately
  document.getElementById('edgeMenu').style.display = 'none';
  
  const modal = document.getElementById('profileModal');
  const optionsDiv = document.getElementById('profileOptions');
  const noteSpan = document.getElementById('profileThicknessNote');
  
  // Update thickness note
  noteSpan.textContent = `Showing profiles available for ${worktopThickness}mm thickness`;
  
  // Build profile options - ONLY show available profiles for current thickness
  let html = '';
  
  // If there's a last selected profile, show option to use same
  if (lastSelectedProfile && EDGE_PROFILES[lastSelectedProfile]) {
    const lastProfile = EDGE_PROFILES[lastSelectedProfile];
    if (lastProfile.thickness.includes(worktopThickness)) {
      const priceText = lastProfile.price === 0 ? 'Included' : `¬£${lastProfile.price.toFixed(2)}/m`;
      const lastExtraInfo = lastSelectedProfile === 'mitred_edge' ? `<div style="font-size:10px;color:#795548;">${lastMitredEdgeHeight}mm drop</div>` : `<div style="font-size:10px;color:#666;">Click to use same profile</div>`;
      html += `
        <div style="margin-bottom:12px;padding:10px;background:#e8f5e9;border-radius:8px;border:2px solid #4CAF50;">
          <div style="font-size:11px;color:#2e7d32;margin-bottom:6px;font-weight:600;">‚úì Previously Selected</div>
          <div onclick="selectEdgeProfile('${lastSelectedProfile}')" style="display:flex;align-items:center;gap:12px;padding:10px;background:white;border:2px solid #4CAF50;border-radius:6px;cursor:pointer;">
            <div style="width:50px;height:30px;background:#f0f0f0;border-radius:4px;display:flex;align-items:center;justify-content:center;font-size:10px;color:#666;">
              ${lastProfile.image ? `<img src="https://lh3.googleusercontent.com/d/${lastProfile.image}=s100" style="max-width:100%;max-height:100%;border-radius:4px;">` : 'üìê'}
            </div>
            <div style="flex:1;">
              <div style="font-weight:600;font-size:13px;">${lastProfile.name}</div>
              ${lastExtraInfo}
            </div>
            <div style="text-align:right;">
              <div style="font-weight:600;color:${lastProfile.price === 0 ? '#4CAF50' : '#1e4d3a'};">${priceText}</div>
            </div>
          </div>
        </div>
        <div style="font-size:11px;color:#666;margin-bottom:8px;padding-bottom:8px;border-bottom:1px solid #ddd;">Or choose a different profile:</div>
      `;
    }
  }
  
  Object.entries(EDGE_PROFILES).forEach(([key, profile]) => {
    // Only show profiles available for current thickness
    if (!profile.thickness.includes(worktopThickness)) return;
    
    // Skip the last selected one as it's already shown above
    if (key === lastSelectedProfile) return;
    
    const priceText = profile.price === 0 ? 'Included' : `¬£${profile.price.toFixed(2)}/m`;
    
    // Extra info for mitred edge
    const extraInfo = key === 'mitred_edge' ? `<div style="font-size:10px;color:#795548;">${lastMitredEdgeHeight}mm drop (click to change)</div>` : '';
    
    html += `
      <div onclick="selectEdgeProfile('${key}')" style="display:flex;align-items:center;gap:12px;padding:12px;border:2px solid #ddd;border-radius:8px;cursor:pointer;transition:all 0.2s;margin-bottom:6px;" onmouseover="this.style.borderColor='#1e4d3a';this.style.background='#f0f7f4';" onmouseout="this.style.borderColor='#ddd';this.style.background='white';">
        <div style="width:50px;height:30px;background:#f0f0f0;border-radius:4px;display:flex;align-items:center;justify-content:center;font-size:10px;color:#666;">
          ${profile.image ? `<img src="https://lh3.googleusercontent.com/d/${profile.image}=s100" style="max-width:100%;max-height:100%;border-radius:4px;">` : 'üìê'}
        </div>
        <div style="flex:1;">
          <div style="font-weight:600;font-size:13px;">${profile.name}</div>
          ${extraInfo}
        </div>
        <div style="text-align:right;">
          <div style="font-weight:600;color:${profile.price === 0 ? '#4CAF50' : '#1e4d3a'};">${priceText}</div>
        </div>
      </div>
    `;
  });
  
  optionsDiv.innerHTML = html;
  modal.style.display = 'flex';
}

// Track last selected profile
let lastSelectedProfile = null;
let lastMitredEdgeHeight = 50; // Remember mitred edge height

function selectEdgeProfile(profileKey) {
  const profile = EDGE_PROFILES[profileKey];
  if (!profile) return;
  
  // Check thickness compatibility
  if (!profile.thickness.includes(worktopThickness)) {
    alert(`${profile.name} is not available for ${worktopThickness}mm thickness`);
    return;
  }
  
  // Helper function to apply profile to stepout edge if applicable
  function applyToStepoutEdge(w, edge, profileData) {
    if (!w.stepout) return;
    
    const s = w.stepout;
    const isVertical = w.depth > w.length;
    
    console.log('applyToStepoutEdge:', edge, 'isVertical:', isVertical, 'corner:', s.corner);
    
    // Determine if this edge should extend to include stepout
    let stepoutEdge = null;
    let stepoutStart = 0;
    let stepoutEnd = 0;
    
    if (!isVertical) {
      // Horizontal worktop - stepout extends down (front) or up (back)
      // Left/right edges extend to stepout_left/stepout_right
      // Back/front edges extend to stepout_top/stepout_bottom
      
      if (edge === 'left' && (s.corner === 'front-left' || s.corner === 'back-left')) {
        stepoutEdge = 'stepout_left';
        stepoutEnd = s.depth;
      } else if (edge === 'right' && (s.corner === 'front-right' || s.corner === 'back-right')) {
        stepoutEdge = 'stepout_right';
        stepoutEnd = s.depth;
      } else if (edge === 'front' && (s.corner === 'front-left' || s.corner === 'front-right')) {
        stepoutEdge = 'stepout_bottom';
        stepoutEnd = s.length;
        console.log('  -> Extending front edge to stepout_bottom, length:', s.length);
      } else if (edge === 'back' && (s.corner === 'back-left' || s.corner === 'back-right')) {
        stepoutEdge = 'stepout_top';
        stepoutEnd = s.length;
        console.log('  -> Extending back edge to stepout_top, length:', s.length);
      }
    } else {
      // Vertical worktop - stepout extends left or right
      // Front edge extends to stepout_bottom if stepout is on front side
      // Back edge extends to stepout_top if stepout is on back side
      // Left edge extends to stepout_outer if stepout is on left side
      // Right edge extends to stepout_outer if stepout is on right side
      
      if (edge === 'front' && (s.corner === 'front-left' || s.corner === 'front-right')) {
        stepoutEdge = 'stepout_bottom';
        stepoutEnd = s.depth;
        console.log('  -> Extending front edge to stepout_bottom, depth:', s.depth);
      } else if (edge === 'back' && (s.corner === 'back-left' || s.corner === 'back-right')) {
        stepoutEdge = 'stepout_top';
        stepoutEnd = s.depth;
        console.log('  -> Extending back edge to stepout_top, depth:', s.depth);
      } else if (edge === 'left' && (s.corner === 'front-left' || s.corner === 'back-left')) {
        stepoutEdge = 'stepout_outer';
        stepoutEnd = s.length;
        console.log('  -> Extending left edge to stepout_outer, length:', s.length);
      } else if (edge === 'right' && (s.corner === 'front-right' || s.corner === 'back-right')) {
        stepoutEdge = 'stepout_outer';
        stepoutEnd = s.length;
        console.log('  -> Extending right edge to stepout_outer, length:', s.length);
      } else {
        console.log('  -> No match for vertical worktop. edge:', edge, 'corner:', s.corner);
      }
    }
    
    if (stepoutEdge) {
      w.edgeTypes[`${stepoutEdge}_${stepoutStart}_${stepoutEnd}`] = { ...profileData };
      console.log('Auto-extended profile to stepout edge:', stepoutEdge, stepoutStart, '-', stepoutEnd);
    }
  }
  
  // Special handling for mitred edge - prompt for height
  if (profileKey === 'mitred_edge') {
    const h = prompt(`Mitred Edge drop (10-100mm):`, lastMitredEdgeHeight.toString());
    if (h === null) return; // Cancelled
    const height = parseInt(h);
    
    if (isNaN(height) || height < 10 || height > 100) {
      alert('Please enter a size between 10mm and 100mm');
      return;
    }
    
    lastMitredEdgeHeight = height; // Remember for next time
    
    if (!edgeMenuTarget) {
      cancelProfileSelection();
      return;
    }
    
    saveHistory();
    
    const w = worktops.find(w => w.id === edgeMenuTarget.wId);
    if (!w) {
      cancelProfileSelection();
      return;
    }
    
    const { edge, seg } = edgeMenuTarget;
    if (!w.edgeTypes) w.edgeTypes = {};
    
    const profileData = { 
      type: 'mitred_edge', 
      height: height,
      pricePerMeter: profile.price
    };
    
    w.edgeTypes[`${edge}_${seg.start}_${seg.end}`] = { ...profileData };
    
    // Auto-extend to stepout edge
    applyToStepoutEdge(w, edge, profileData);
    
    lastSelectedProfile = profileKey;
    document.getElementById('profileModal').style.display = 'none';
    hideEdgeMenu();
    render();
    updateSummary();
    return;
  }
  
  // Remember this selection
  lastSelectedProfile = profileKey;
  
  // Apply the profile to the edge
  if (!edgeMenuTarget) {
    cancelProfileSelection();
    return;
  }
  
  saveHistory();
  
  const w = worktops.find(w => w.id === edgeMenuTarget.wId);
  if (!w) {
    cancelProfileSelection();
    return;
  }
  
  const { edge, seg } = edgeMenuTarget;
  if (!w.edgeTypes) w.edgeTypes = {};
  
  const profileData = { 
    type: 'profile', 
    profileKey: profileKey,
    profileName: profile.name,
    pricePerMeter: profile.price
  };
  
  w.edgeTypes[`${edge}_${seg.start}_${seg.end}`] = { ...profileData };
  
  // Auto-extend to stepout edge
  applyToStepoutEdge(w, edge, profileData);
  
  document.getElementById('profileModal').style.display = 'none';
  hideEdgeMenu();
  render();
  updateSummary();
}

function cancelProfileSelection() {
  document.getElementById('profileModal').style.display = 'none';
  hideEdgeMenu();
}

// ========== MATERIAL COLOR SELECTION ==========
function showMaterialModal() {
  // If a material is selected, default to its brand; otherwise show all
  if (selectedMaterial && MATERIAL_COLORS[selectedMaterial]) {
    currentBrandFilter = MATERIAL_COLORS[selectedMaterial].brand || 'all';
  } else {
    currentBrandFilter = 'all';
  }
  currentTierFilter = 'all';
  pendingMaterial = selectedMaterial;
  
  document.getElementById('materialSearch').value = '';
  
  // Reset brand logo buttons then highlight the correct one
  document.querySelectorAll('.brand-logo-btn').forEach(btn => {
    btn.style.borderColor = '#ddd';
    btn.style.background = 'white';
  });
  
  // Highlight the selected brand button
  const selectedBrandBtn = document.querySelector(`.brand-logo-btn[data-brand="${currentBrandFilter}"]`);
  if (selectedBrandBtn) {
    selectedBrandBtn.style.borderColor = '#1e4d3a';
    selectedBrandBtn.style.background = '#e8f5e9';
  } else {
    // Fallback to "All" if brand not found
    const brandAllBtn = document.getElementById('brandAll');
    if (brandAllBtn) {
      brandAllBtn.style.borderColor = '#1e4d3a';
      brandAllBtn.style.background = '#e8f5e9';
      brandAllBtn.style.fontWeight = '600';
    }
  }
  
  // Reset tier buttons
  document.querySelectorAll('.tier-btn').forEach(btn => {
    btn.style.background = 'white';
    btn.style.fontWeight = 'normal';
  });
  const tierAllBtn = document.getElementById('tierAll');
  if (tierAllBtn) {
    tierAllBtn.style.background = '#e8f5e9';
    tierAllBtn.style.fontWeight = '600';
  }
  
  // Set thickness buttons
  updateThicknessButtons();
  
  // Hide selected bar and OK button initially
  const bar = document.getElementById('selectedMaterialBar');
  if (bar) bar.style.display = 'none';
  
  filterMaterialsNew();
  document.getElementById('materialModal').style.display = 'flex';
}

function setThickness(thick) {
  worktopThickness = thick;
  updateThicknessButtons();
  filterMaterialsNew();
  
  // Also update the summary panel dropdown
  const thicknessSelect = document.getElementById('thicknessSelect');
  if (thicknessSelect) {
    thicknessSelect.value = thick;
  }
}

function updateThicknessButtons() {
  const btn20 = document.getElementById('thick20');
  const btn30 = document.getElementById('thick30');
  
  if (!btn20 || !btn30) return;
  
  if (worktopThickness === 20) {
    btn20.style.borderColor = '#1e4d3a';
    btn20.style.background = '#e8f5e9';
    btn20.style.fontWeight = '600';
    btn30.style.borderColor = '#ccc';
    btn30.style.background = 'white';
    btn30.style.fontWeight = 'normal';
  } else {
    btn30.style.borderColor = '#1e4d3a';
    btn30.style.background = '#e8f5e9';
    btn30.style.fontWeight = '600';
    btn20.style.borderColor = '#ccc';
    btn20.style.background = 'white';
    btn20.style.fontWeight = 'normal';
  }
}

// Get tier HTML based on current style
function getTierHTML(tier) {
  const t = tier || 1;
  const symbol = '¬£'.repeat(t);
  
  if (tierStyle === 'pill') {
    return `<span class="tier-pill t${t}">${symbol}</span>`;
  } else {
    return `<span class="tier-classic t${t}">${symbol}</span>`;
  }
}

// Set tier display style
function setTierStyle(style) {
  tierStyle = style;
  
  // Update toggle buttons
  document.getElementById('tierStyleClassic').classList.toggle('active', style === 'classic');
  document.getElementById('tierStylePill').classList.toggle('active', style === 'pill');
  
  // Update preview
  updateTierStylePreview();
  
  // Update tier filter buttons
  updateTierFilterButtons();
  
  // Re-render materials grid
  renderMaterialsGrid();
}

function updateTierStylePreview() {
  const preview = document.getElementById('tierStylePreview');
  if (!preview) return;
  
  let html = '';
  for (let t = 1; t <= 5; t++) {
    html += getTierHTML(t) + ' ';
  }
  preview.innerHTML = html;
}

function updateTierFilterButtons() {
  const container = document.getElementById('tierFilterButtons');
  if (!container) return;
  
  const tierColors = { 1: '#4CAF50', 2: '#8BC34A', 3: '#FFC107', 4: '#FF9800', 5: '#f44336' };
  const tierLabels = { 1: ' Budget', 2: '', 3: ' Mid', 4: '', 5: ' Premium' };
  
  let html = `<button onclick="setTierFilter('all')" id="tierAll" class="tier-btn" style="padding:6px 12px;border:none;border-radius:20px;background:${currentTierFilter === 'all' ? '#e8f5e9' : 'transparent'};cursor:pointer;font-size:12px;font-weight:600;">All</button>`;
  
  for (let t = 1; t <= 5; t++) {
    const symbol = '¬£'.repeat(t);
    const isActive = currentTierFilter === symbol;
    const color = tierColors[t];
    const label = tierLabels[t];
    const bg = isActive ? color.replace('#', 'rgba(') + ',0.15)' : 'transparent';
    
    html += `<button onclick="setTierFilter('${symbol}')" id="tier${t}" class="tier-btn" style="padding:6px 12px;border:none;border-radius:20px;background:${bg};cursor:pointer;font-size:12px;font-weight:${isActive ? '600' : 'normal'};">${getTierHTML(t)}${label}</button>`;
  }
  
  container.innerHTML = html;
}

// ========== LOAD PRICING JSON ==========
function loadPricingJSON(input) {
  const file = input.files[0];
  if (!file) return;
  
  const statusEl = document.getElementById('pricingLoadStatus');
  if (statusEl) {
    statusEl.textContent = 'Loading...';
    statusEl.style.color = '#666';
  }
  
  const reader = new FileReader();
  reader.onload = function(e) {
    try {
      const data = JSON.parse(e.target.result);
      loadMaterialsFromData(data);
      
      // Save to sessionStorage for persistence
      try {
        sessionStorage.setItem('materials_pricing_json', e.target.result);
        console.log('Saved materials to sessionStorage');
      } catch (storageErr) {
        console.warn('Could not save to sessionStorage:', storageErr);
      }
      
    } catch (err) {
      if (statusEl) {
        statusEl.textContent = '‚úó Error';
        statusEl.style.color = '#c62828';
      }
      console.error('Failed to load pricing JSON:', err);
    }
  };
  reader.readAsText(file);
}

// Load materials from data object (used by both file load and sessionStorage restore)
function loadMaterialsFromData(data) {
  const statusEl = document.getElementById('pricingLoadStatus');
  const count = Object.keys(data).length;
  
  // CLEAR existing materials and pricing - REPLACE don't add
  Object.keys(MATERIAL_COLORS).forEach(key => delete MATERIAL_COLORS[key]);
  Object.keys(MATERIAL_PRICING).forEach(key => delete MATERIAL_PRICING[key]);
  
  // Load fresh from data
  Object.entries(data).forEach(([key, mat]) => {
    // Tier should already be 1-5 from JSON, but cap just in case
    let tier = mat.tier || 2;
    if (tier > 5) tier = 5;
    
    // Add to MATERIAL_PRICING
    MATERIAL_PRICING[key] = {
      tier: tier,
      price20sqm: null,
      price20slab: mat.price20slab,
      price30sqm: null,
      price30slab: mat.price30slab
    };
    
    // Add to MATERIAL_COLORS
    MATERIAL_COLORS[key] = {
      name: mat.name,
      color: 0xe8e8e8,
      css: '#e8e8e8',
      cssSelected: '#d0d0d0',
      roughness: 0.15,
      textureId: mat.textureId || null,
      brand: mat.brandCode || 'OTH',
      tier: tier,
      type: mat.type || 'Quartz',
      finish: mat.finish || 'Polished',
      thickness: mat.price20slab && mat.price30slab ? [20, 30] : 
                 mat.price20slab ? [20] : 
                 mat.price30slab ? [30] : [20, 30]
    };
  });
  
  // Preserve selected material if it exists in new data, otherwise clear
  if (selectedMaterial && !data[selectedMaterial]) {
    console.log('Selected material not found in new data, clearing:', selectedMaterial);
    selectedMaterial = null;
  } else if (selectedMaterial) {
    console.log('Preserved selected material:', selectedMaterial);
  }
  pendingMaterial = null;
  updateCurrentMaterialDisplay();
  
  if (statusEl) {
    statusEl.textContent = `‚úì ${count} materials`;
    statusEl.style.color = '#2e7d32';
  }
  
  // Refresh the material grid
  filterMaterialsNew();
  
  console.log(`Loaded ${count} materials (replaced existing)`);
}

// Restore materials from sessionStorage on page load
function restoreMaterialsFromStorage() {
  try {
    const stored = sessionStorage.getItem('materials_pricing_json');
    if (stored) {
      const data = JSON.parse(stored);
      loadMaterialsFromData(data);
      console.log('Restored materials from sessionStorage');
      return true;
    }
  } catch (err) {
    console.warn('Could not restore from sessionStorage:', err);
  }
  return false;
}

// Auto-fetch materials_pricing.json from same folder
async function autoLoadPricingJSON() {
  const statusEl = document.getElementById('pricingLoadStatus');
  
  try {
    if (statusEl) {
      statusEl.textContent = 'Loading...';
      statusEl.style.color = '#666';
    }
    
    const response = await fetch('materials_pricing.json');
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }
    
    const data = await response.json();
    loadMaterialsFromData(data);
    
    // Save to sessionStorage for persistence
    try {
      sessionStorage.setItem('materials_pricing_json', JSON.stringify(data));
    } catch (storageErr) {
      console.warn('Could not save to sessionStorage:', storageErr);
    }
    
    console.log('Auto-loaded materials_pricing.json');
    return true;
  } catch (err) {
    console.warn('Could not auto-load materials_pricing.json:', err.message);
    if (statusEl) {
      statusEl.textContent = 'Load JSON ‚Üí';
      statusEl.style.color = '#e65100';
    }
    return false;
  }
}

function setTierFilter(tier) {
  currentTierFilter = tier;
  
  // Update button styles using the same function
  updateTierFilterButtons();
  
  filterMaterialsNew();
}

function setBrandFilter(brand) {
  currentBrandFilter = brand;
  
  // Update logo button styles
  document.querySelectorAll('.brand-logo-btn').forEach(btn => {
    btn.style.borderColor = '#ddd';
    btn.style.background = 'white';
    if (btn.id === 'brandAll') {
      btn.style.fontWeight = 'normal';
    }
  });
  
  // Highlight selected
  if (brand === 'all') {
    const allBtn = document.getElementById('brandAll');
    if (allBtn) {
      allBtn.style.borderColor = '#1e4d3a';
      allBtn.style.background = '#e8f5e9';
      allBtn.style.fontWeight = '600';
    }
  } else {
    const selectedBtn = document.querySelector(`.brand-logo-btn[data-brand="${brand}"]`);
    if (selectedBtn) {
      selectedBtn.style.borderColor = '#1e4d3a';
      selectedBtn.style.background = '#e8f5e9';
    }
  }
  
  filterMaterialsNew();
}

function filterMaterialsNew() {
  const grid = document.getElementById('materialGrid');
  const countEl = document.getElementById('materialCount');
  const searchText = (document.getElementById('materialSearch')?.value || '').toLowerCase();
  const brandFilter = currentBrandFilter;
  const tierFilter = currentTierFilter;
  
  // Material type mapping by brand
  const materialTypes = {
    'SIL': 'Quartz',
    'DEK': 'Sintered Stone',
    'GLO': 'Quartz',
    'MOD': 'Quartz',
    'COS': 'Quartz',
    'CQS': 'Quartz',
    'ART': 'Quartz',
    'NLQ': 'Quartz',
    'NAT': 'Natural Stone',
    'HOR': 'Quartz',
    'HSP': 'Porcelain'
  };
  
  let html = '';
  let count = 0;
  
  Object.entries(MATERIAL_COLORS).forEach(([key, mat]) => {
    // Filter by search
    if (searchText && !mat.name.toLowerCase().includes(searchText)) return;
    
    // Filter by brand
    if (brandFilter !== 'all' && mat.brand !== brandFilter) return;
    
    // Filter by tier
    if (tierFilter !== 'all') {
      const pricing = MATERIAL_PRICING[key];
      const tier = pricing ? pricing.tier : (mat.tier || 1);
      const tierSymbol = '¬£'.repeat(tier);
      if (tierSymbol !== tierFilter) return;
    }
    
    // Filter by thickness - don't filter, but mark unavailable
    const pricing = MATERIAL_PRICING[key];
    const thicknesses = mat.thickness || [20, 30];
    // Check actual price availability - explicitly check for number > 0
    const has20 = pricing && pricing.price20slab > 0 ? true : 
                  !pricing && thicknesses.includes(20);
    const has30 = pricing && pricing.price30slab > 0 ? true : 
                  !pricing && thicknesses.includes(30);
    const hasCurrentThickness = worktopThickness === 20 ? has20 : has30;
    
    // Only skip if NO thickness is available at all
    if (!has20 && !has30) return;
    
    count++;
    
    // Check if this is the currently selected OR pending material
    const isCurrentSelection = key === selectedMaterial;
    const isPending = key === pendingMaterial;
    const borderColor = isPending ? '#4CAF50' : isCurrentSelection ? '#2196F3' : '#ddd';
    const bgColor = isPending ? '#e8f5e9' : isCurrentSelection ? '#e3f2fd' : 'white';
    
    // Grey out if current thickness not available
    const isGreyedOut = !hasCurrentThickness;
    const opacity = isGreyedOut ? '0.4' : '1';
    const pointerEvents = isGreyedOut ? 'none' : 'auto';
    
    // Thumbnail with cropping - ART (Artemis) also needs cropping
    const needsCrop = mat.brand === 'GLO' || mat.brand === 'MOD' || mat.brand === 'ART' || mat.brand === 'NAT' || mat.brand === 'CQS';
    const bgSize = needsCrop ? '300%' : 'cover';
    const thumbnailUrl = mat.textureId ? 
      `https://lh3.googleusercontent.com/d/${mat.textureId}=s200` : '';
    
    const colorStyle = thumbnailUrl ? 
      `background-image:url('${thumbnailUrl}');background-size:${bgSize};background-position:center;` :
      `background:${mat.css};`;
    
    // Price tier display - get from MATERIAL_PRICING
    const tier = pricing ? pricing.tier : (mat.tier || 1);
    const tierHTML = getTierHTML(tier);
    
    // Material type - for NAT use actual type (Granite/Quartzite), for others use brand mapping
    const matType = mat.brand === 'NAT' ? (mat.type || 'Natural Stone') : (materialTypes[mat.brand] || mat.type || 'Stone');
    
    // Finish (Polished, Honed, etc.) - with color coding
    const finish = mat.finish || 'Polished';
    const finishColors = {
      'Honed': { bg: '#e3f2fd', color: '#1565c0' },
      'Suede': { bg: '#fce4ec', color: '#c2185b' },
      'Leather': { bg: '#fff3e0', color: '#e65100' },
      'Matte': { bg: '#f3e5f5', color: '#7b1fa2' },
      'Matt': { bg: '#f3e5f5', color: '#7b1fa2' },
      'Satinato': { bg: '#e8f5e9', color: '#2e7d32' },
      'Velvet': { bg: '#ede7f6', color: '#512da8' },
      'Silk': { bg: '#fff8e1', color: '#ff8f00' },
      'Anticato': { bg: '#efebe9', color: '#5d4037' },
      'Caress': { bg: '#fbe9e7', color: '#d84315' }
    };
    const finishStyle = finishColors[finish] || { bg: '#f5f5f5', color: '#666' };
    const finishDisplay = finish !== 'Polished' ? 
      `<span style="display:inline-block;font-size:9px;font-weight:600;color:${finishStyle.color};background:${finishStyle.bg};padding:2px 6px;border-radius:4px;margin-top:3px;border:1px solid ${finishStyle.color}30;">${finish}</span>` : '';
    
    // Current selection indicator
    const selectionBadge = isCurrentSelection ? '<span style="position:absolute;top:4px;right:4px;background:#2196F3;color:white;font-size:8px;padding:2px 5px;border-radius:3px;">CURRENT</span>' : '';
    
    // Unavailable thickness warning
    const thicknessWarning = isGreyedOut ? `<div style="font-size:8px;color:#c62828;margin-top:2px;">${worktopThickness}mm not available</div>` : '';
    
    html += `
      <div class="material-option" onclick="previewMaterial('${key}')" style="cursor:pointer;padding:10px;border:2px solid ${borderColor};border-radius:8px;text-align:center;background:${bgColor};transition:all 0.2s;opacity:${opacity};pointer-events:${pointerEvents};position:relative;">
        ${selectionBadge}
        <div style="width:100px;height:100px;margin:0 auto 8px;border-radius:6px;${colorStyle}border:1px solid #ccc;overflow:hidden;"></div>
        <div style="font-size:11px;font-weight:500;line-height:1.2;max-height:2.4em;overflow:hidden;">${mat.name}</div>
        <div style="font-size:9px;color:#888;margin-top:2px;">${matType}</div>
        ${finishDisplay}
        <div style="display:inline-block;margin-top:4px;">${tierHTML}</div>
        ${thicknessWarning}
      </div>
    `;
  });
  
  if (!html) {
    html = '<div style="grid-column:1/-1;text-align:center;padding:20px;color:#666;">No materials found</div>';
  }
  
  grid.innerHTML = html;
  if (countEl) countEl.textContent = 'Showing ' + count + ' materials';
}

function previewMaterial(key) {
  if (!MATERIAL_COLORS[key]) return;
  
  pendingMaterial = key;
  const mat = MATERIAL_COLORS[key];
  
  // Material type mapping
  const materialTypes = {
    'SIL': 'Quartz',
    'DEK': 'Sintered Stone',
    'GLO': 'Quartz',
    'MOD': 'Quartz',
    'COS': 'Quartz',
    'CQS': 'Quartz',
    'ART': 'Quartz',
    'NLQ': 'Quartz',
    'NAT': 'Natural Stone',
    'HOR': 'Quartz',
    'HSP': 'Porcelain'
  };
  
  // Update selected preview bar
  const bar = document.getElementById('selectedMaterialBar');
  const thumb = document.getElementById('selectedMatThumb');
  const nameEl = document.getElementById('selectedMatName');
  const brandEl = document.getElementById('selectedMatBrand');
  const tierEl = document.getElementById('selectedMatTier');
  const thickEl = document.getElementById('selectedMatThickness');

  if (bar && thumb && nameEl) {
    bar.style.display = 'block';
    nameEl.textContent = mat.name;
    
    const brandNames = {
      'SIL': 'Silestone', 'DEK': 'Dekton', 'GLO': 'Global Granite',
      'MOD': 'Modern Quartz', 'COS': 'Cosy Stone', 'CQS': 'Classic Quartz',
      'ART': 'Artemis Stone', 'NLQ': 'Nile Quartz', 'NAT': 'Natural Stone', 'HOR': 'Horizon Stone',
      'HSP': 'Horizon Porcelain'
    };
    // For NAT use actual type (Granite/Quartzite), for others use brand mapping
    const matType = mat.brand === 'NAT' ? (mat.type || 'Natural Stone') : (materialTypes[mat.brand] || 'Stone');
    brandEl.textContent = `${brandNames[mat.brand] || mat.brand || ''} ‚Ä¢ ${matType}`;
    
    // Show thickness
    if (thickEl) thickEl.textContent = worktopThickness + 'mm';
    
    // Get tier from MATERIAL_PRICING
    const pricing = MATERIAL_PRICING[key];
    const tier = pricing ? pricing.tier : (mat.tier || 1);
    tierEl.innerHTML = getTierHTML(tier);
    
    // Hide slab price element (not needed for display)
    const priceEl = document.getElementById('selectedMatPrice');
    if (priceEl) priceEl.style.display = 'none';
    
    if (mat.textureId) {
      const needsCrop = mat.brand === 'GLO' || mat.brand === 'MOD' || mat.brand === 'ART' || mat.brand === 'NAT' || mat.brand === 'CQS';
      thumb.style.backgroundImage = `url('https://lh3.googleusercontent.com/d/${mat.textureId}=s200')`;
      thumb.style.backgroundSize = needsCrop ? '300%' : 'cover';
      thumb.style.backgroundPosition = 'center';
    } else {
      thumb.style.backgroundImage = 'none';
      thumb.style.background = mat.css || '#ccc';
    }
    
  }
  
  // Re-render grid to highlight selection
  filterMaterialsNew();
}

function confirmMaterial() {
  if (pendingMaterial && MATERIAL_COLORS[pendingMaterial]) {
    selectedMaterial = pendingMaterial;
    const mat = MATERIAL_COLORS[selectedMaterial];
    
    // Suppress slab warning popup during material change
    isMaterialChanging = true;
    
    closeMaterialModal();
    
    // Update legacy info element
    const matInfo = document.getElementById('selectedMaterialInfo');
    if (matInfo) matInfo.textContent = mat.name;
    
    // Update current material display in toolbar
    updateCurrentMaterialDisplay();
    
    // Adjust slab size based on material type
    // Natural Stone (NAT) uses larger slabs: 3200x1900
    // Horizon Porcelain Indigo (PRID*) uses super jumbo: 3300x1840
    // All others use standard: 3200x1600
    const slabWidthInput = document.getElementById('slabWidthInput');
    const slabHeightInput = document.getElementById('slabHeightInput');
    if (slabWidthInput && slabHeightInput) {
      if (selectedMaterial.startsWith('prid')) {
        // Indigo range - Super Jumbo 3300x1840
        slabWidthInput.value = 3300;
        slabHeightInput.value = 1840;
        console.log('Horizon Porcelain Indigo selected - slab size set to 3300x1840');
      } else if (mat.brand === 'NAT') {
        slabWidthInput.value = 3200;
        slabHeightInput.value = 1900;
        console.log('Natural Stone selected - slab size set to 3200x1900');
      } else {
        slabWidthInput.value = 3200;
        slabHeightInput.value = 1600;
      }
    }
    
    // Recalculate pricing with new material
    updateSummary();
    
    render();
    
    // Re-render slab layout with new size
    if (currentView === 'slab') renderSlabLayout();
    
    if (currentView === '3d') {
      loadMaterialTexture(selectedMaterial, () => {
        render3D();
      });
    }
    
    // Re-enable slab warnings after material change completes
    setTimeout(() => {
      isMaterialChanging = false;
    }, 500);
  }
}

// Update the current material display in toolbar
function updateCurrentMaterialDisplay() {
  const nameEl = document.getElementById('currentMatName');
  const brandEl = document.getElementById('currentMatBrand');
  const swatchEl = document.getElementById('currentMatSwatch');
  
  const mat = MATERIAL_COLORS[selectedMaterial];
  
  // Handle no selection
  if (!mat) {
    if (nameEl) nameEl.textContent = 'No material selected';
    if (brandEl) brandEl.textContent = '';
    if (swatchEl) {
      swatchEl.style.backgroundImage = 'none';
      swatchEl.style.background = '#ccc';
    }
    return;
  }
  
  // Show name with finish if not Polished
  const finish = mat.finish || 'Polished';
  const finishSuffix = finish !== 'Polished' ? ` (${finish})` : '';
  if (nameEl) nameEl.textContent = mat.name + finishSuffix;
  
  // Brand names mapping
  const brandNames = {
    'SIL': 'Silestone', 'DEK': 'Dekton', 'GLO': 'Global',
    'MOD': 'Modern Quartz', 'COS': 'Cosy Stone', 'CQS': 'Classic Quartz',
    'ART': 'Artemis', 'NLQ': 'Nile Quartz', 'NAT': 'Natural Stone', 'HOR': 'Horizon',
    'HSP': 'Horizon Porcelain'
  };
  if (brandEl) {
    const pricing = MATERIAL_PRICING[selectedMaterial];
    const tier = pricing ? pricing.tier : (mat.tier || 1);
    brandEl.textContent = `${brandNames[mat.brand] || mat.brand || ''} ‚Ä¢ ${'¬£'.repeat(tier)}`;
  }
  
  if (swatchEl) {
    const needsCrop = mat.brand === 'GLO' || mat.brand === 'MOD' || mat.brand === 'ART' || mat.brand === 'NAT' || mat.brand === 'CQS';
    if (mat.textureId) {
      swatchEl.style.backgroundImage = `url('https://lh3.googleusercontent.com/d/${mat.textureId}=s100')`;
      swatchEl.style.backgroundSize = needsCrop ? '300%' : 'cover';
      swatchEl.style.backgroundPosition = 'center';
    } else {
      swatchEl.style.backgroundImage = 'none';
      swatchEl.style.background = mat.css || '#ccc';
    }
  }
}

function closeMaterialModal() {
  document.getElementById('materialModal').style.display = 'none';
  pendingMaterial = null;
}

// Clear the preview selection without closing modal
function clearMaterialSelection() {
  pendingMaterial = null;
  
  // Clear preview panel
  const nameEl = document.getElementById('selectedMatName');
  const brandEl = document.getElementById('selectedMatBrand');
  const thickEl = document.getElementById('selectedMatThickness');
  const tierEl = document.getElementById('selectedMatTier');
  const thumb = document.getElementById('selectedMatThumb');
  
  if (nameEl) nameEl.textContent = 'Select a material';
  if (brandEl) brandEl.textContent = '';
  if (thickEl) thickEl.textContent = '';
  if (tierEl) tierEl.innerHTML = '';
  if (thumb) {
    thumb.style.backgroundImage = 'none';
    thumb.style.background = '#e0e0e0';
  }
  
  // Refresh grid to remove highlight
  filterMaterialsNew();
}

// ========== CUTOUT EDIT MODAL ==========
let editingCutoutId = null;

function showCutoutEditModal(cutoutId) {
  const c = cutouts.find(ct => ct.id === cutoutId);
  if (!c) return;
  
  editingCutoutId = cutoutId;
  const parent = worktops.find(w => w.id === c.parentId);
  
  // Get type label
  let typeLabel = 'Cutout';
  if (c.type === 'undermount_sink') typeLabel = c.isButler ? 'Butler Sink' : 'Undermount Sink';
  else if (c.type === 'overmount_sink') typeLabel = 'Overmount Sink';
  else if (c.type === 'hob') typeLabel = 'Hob Cutout';
  else if (c.type === 'recess_hob') typeLabel = 'Recess Hob';
  else if (c.type === 'tap') typeLabel = 'Tap / Pop-Up Socket';
  else if (c.type === 'drainer') typeLabel = 'Drainer Grooves';
  else if (c.type === 'recess_drainer') typeLabel = 'Recess Drainer';
  else if (c.type === 'socket') typeLabel = 'Socket Cutout';
  
  document.getElementById('cutoutEditTitle').textContent = `Edit ${typeLabel}`;
  
  let html = '';
  
  if (c.type === 'tap') {
    // Tap/socket hole
    let distFromLeft = 0, distFromFront = 0;
    if (parent) {
      distFromLeft = Math.round(c.x - parent.x);
      distFromFront = Math.round(parent.y + parent.depth - c.y);
    }
    
    html = `
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-bottom:12px;">
        <div>
          <label style="font-size:11px;color:#666;display:block;margin-bottom:4px;">Diameter (mm)</label>
          <input type="number" id="editCutoutDiameter" value="${c.diameter}" style="width:100%;padding:8px;border:1px solid #ccc;border-radius:4px;font-size:14px;box-sizing:border-box;">
        </div>
        <div></div>
      </div>
      <div style="border-top:1px solid #eee;padding-top:12px;margin-top:8px;">
        <div style="font-size:11px;color:#1e4d3a;font-weight:600;margin-bottom:8px;">üìè Position</div>
      </div>
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;">
        <div>
          <label style="font-size:11px;color:#666;display:block;margin-bottom:4px;">From Left (mm)</label>
          <input type="number" id="editCutoutFromLeft" value="${distFromLeft}" style="width:100%;padding:8px;border:1px solid #ccc;border-radius:4px;font-size:14px;box-sizing:border-box;">
        </div>
        <div>
          <label style="font-size:11px;color:#666;display:block;margin-bottom:4px;">From Front (mm)</label>
          <input type="number" id="editCutoutFromFront" value="${distFromFront}" style="width:100%;padding:8px;border:1px solid #ccc;border-radius:4px;font-size:14px;box-sizing:border-box;">
        </div>
      </div>
    `;
  } else if (c.type === 'socket') {
    // Socket on splashback
    const splashParent = upstands.find(u => u.id === c.parentId);
    
    html = `
      <div style="font-size:10px;color:#666;margin-bottom:10px;">On Splashback (${splashParent ? splashParent.length + '√ó' + splashParent.height + 'mm' : 'Unknown'})</div>
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-bottom:12px;">
        <div>
          <label style="font-size:11px;color:#666;display:block;margin-bottom:4px;">Width (mm)</label>
          <input type="number" id="editCutoutWidth" value="${c.width}" style="width:100%;padding:8px;border:1px solid #ccc;border-radius:4px;font-size:14px;box-sizing:border-box;">
        </div>
        <div>
          <label style="font-size:11px;color:#666;display:block;margin-bottom:4px;">Height (mm)</label>
          <input type="number" id="editCutoutHeight" value="${c.height}" style="width:100%;padding:8px;border:1px solid #ccc;border-radius:4px;font-size:14px;box-sizing:border-box;">
        </div>
      </div>
      <div style="border-top:1px solid #eee;padding-top:12px;margin-top:8px;">
        <div style="font-size:11px;color:#1e4d3a;font-weight:600;margin-bottom:8px;">üìè Position (centre point)</div>
      </div>
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;">
        <div>
          <label style="font-size:11px;color:#666;display:block;margin-bottom:4px;">From Left (mm)</label>
          <input type="number" id="editCutoutCenterX" value="${Math.round(c.centerX)}" style="width:100%;padding:8px;border:1px solid #ccc;border-radius:4px;font-size:14px;box-sizing:border-box;">
        </div>
        <div>
          <label style="font-size:11px;color:#666;display:block;margin-bottom:4px;">From Bottom (mm)</label>
          <input type="number" id="editCutoutCenterY" value="${Math.round(c.centerY)}" style="width:100%;padding:8px;border:1px solid #ccc;border-radius:4px;font-size:14px;box-sizing:border-box;">
        </div>
      </div>
    `;
  } else {
    // Sinks, hobs, drainers - rectangular cutouts
    let distFromLeft = 0, distFromFront = 0;
    
    if (parent) {
      distFromLeft = Math.round(c.x - parent.x);
      distFromFront = Math.round(parent.y + parent.depth - c.y - c.length);
    }
    
    html = `
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-bottom:12px;">
        <div>
          <label style="font-size:11px;color:#666;display:block;margin-bottom:4px;">Width ‚Üê ‚Üí (mm)</label>
          <input type="number" id="editCutoutWidth" value="${c.width}" style="width:100%;padding:8px;border:1px solid #ccc;border-radius:4px;font-size:14px;box-sizing:border-box;">
        </div>
        <div>
          <label style="font-size:11px;color:#666;display:block;margin-bottom:4px;">Length ‚Üë ‚Üì (mm)</label>
          <input type="number" id="editCutoutLength" value="${c.length}" style="width:100%;padding:8px;border:1px solid #ccc;border-radius:4px;font-size:14px;box-sizing:border-box;">
        </div>
      </div>
      ${c.radius !== undefined ? `
      <div style="margin-bottom:12px;">
        <label style="font-size:11px;color:#666;display:block;margin-bottom:4px;">Corner Radius (mm)</label>
        <input type="number" id="editCutoutRadius" value="${c.radius}" style="width:100%;padding:8px;border:1px solid #ccc;border-radius:4px;font-size:14px;box-sizing:border-box;">
      </div>` : ''}
      <div style="border-top:1px solid #eee;padding-top:12px;margin-top:8px;">
        <div style="font-size:11px;color:#1e4d3a;font-weight:600;margin-bottom:8px;">üìè Position (from front left corner)</div>
      </div>
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;">
        <div>
          <label style="font-size:11px;color:#666;display:block;margin-bottom:4px;">From Left (mm)</label>
          <input type="number" id="editCutoutFromLeft" value="${distFromLeft}" style="width:100%;padding:8px;border:1px solid #ccc;border-radius:4px;font-size:14px;box-sizing:border-box;">
        </div>
        <div>
          <label style="font-size:11px;color:#666;display:block;margin-bottom:4px;">From Front (mm)</label>
          <input type="number" id="editCutoutFromFront" value="${distFromFront}" style="width:100%;padding:8px;border:1px solid #ccc;border-radius:4px;font-size:14px;box-sizing:border-box;">
        </div>
      </div>
    `;
  }
  
  document.getElementById('cutoutEditContent').innerHTML = html;
  document.getElementById('cutoutEditModal').style.display = 'flex';
}

function closeCutoutEditModal() {
  document.getElementById('cutoutEditModal').style.display = 'none';
  editingCutoutId = null;
}

function applyCutoutEdit() {
  if (!editingCutoutId) return;
  
  const c = cutouts.find(ct => ct.id === editingCutoutId);
  if (!c) return;
  
  saveHistory();
  
  const parent = worktops.find(w => w.id === c.parentId);
  
  if (c.type === 'tap') {
    c.diameter = parseInt(document.getElementById('editCutoutDiameter').value) || c.diameter;
    if (parent) {
      const fromLeft = parseInt(document.getElementById('editCutoutFromLeft').value) || 0;
      const fromFront = parseInt(document.getElementById('editCutoutFromFront').value) || 0;
      c.x = parent.x + fromLeft;
      c.y = parent.y + parent.depth - fromFront;
    }
  } else if (c.type === 'socket') {
    c.width = parseInt(document.getElementById('editCutoutWidth').value) || c.width;
    c.height = parseInt(document.getElementById('editCutoutHeight').value) || c.height;
    c.centerX = parseInt(document.getElementById('editCutoutCenterX').value) || c.centerX;
    c.centerY = parseInt(document.getElementById('editCutoutCenterY').value) || c.centerY;
  } else {
    c.width = parseInt(document.getElementById('editCutoutWidth').value) || c.width;
    c.length = parseInt(document.getElementById('editCutoutLength').value) || c.length;
    
    const radiusInput = document.getElementById('editCutoutRadius');
    if (radiusInput) {
      c.radius = parseInt(radiusInput.value) || c.radius;
    }
    
    if (parent) {
      const fromLeft = parseInt(document.getElementById('editCutoutFromLeft').value) || 0;
      const fromFront = parseInt(document.getElementById('editCutoutFromFront').value) || 0;
      
      c.x = parent.x + fromLeft;
      c.y = parent.y + parent.depth - fromFront - c.length;
    }
  }
  
  closeCutoutEditModal();
  renderLists();
  renderProps();
  render();
  updateSummary();
  if (currentView === '3d') render3D();
}

function deleteCutoutFromModal() {
  if (!editingCutoutId) return;
  
  if (!confirm('Delete this cutout?')) return;
  
  saveHistory();
  cutouts = cutouts.filter(c => c.id !== editingCutoutId);
  
  if (selectedType === 'cutout' && selectedId === editingCutoutId) {
    selectedType = null;
    selectedId = null;
  }
  
  closeCutoutEditModal();
  renderLists();
  renderProps();
  render();
  updateSummary();
  if (currentView === '3d') render3D();
}

// Remove the old split function for cills - they don't split upstands
function checkAndSplitUpstandsWithCill() {
  // Window cills sit ON TOP of splashbacks, they don't split them
  // This function is now empty but kept for compatibility
}

// ========== CUTOUTS (Sinks, Hobs, Taps, Drainers) ==========
let pendingSinkData = null; // Store sink data while waiting for drainer selection

function showDrainerModal() {
  document.getElementById('drainerModal').style.display = 'flex';
}

function selectDrainerSide(side) {
  document.getElementById('drainerModal').style.display = 'none';
  
  if (side === null || !pendingSinkData) {
    pendingSinkData = null;
    return;
  }
  
  // Continue with sink creation using selected drainer side
  finishSinkWithDrainers(side);
}

function finishSinkWithDrainers(drainerSide) {
  const data = pendingSinkData;
  if (!data) return;
  
  const { w, edge, cx, cy, cw, cl, cr, sb, isButler, isVerticalPlacement } = data;
  
  // Determine if recess drainer
  const isRecess = drainerSide && drainerSide.startsWith('recess_');
  const actualSide = isRecess ? drainerSide.replace('recess_', '') : drainerSide;
  const drainerType = isRecess ? 'recess_drainer' : 'drainer';
  
  const sinkId = nextId++;
  cutouts.push({
    id: sinkId,
    type: 'undermount_sink',
    parentId: w.id,
    x: cx,
    y: cy,
    width: cw,
    length: cl,
    radius: cr,
    setback: sb,
    isButler: isButler || false,
    drainerSide: actualSide
  });
  
  // Add drainers - position depends on whether vertical worktop
  const DRAINER_LENGTH = 400;
  
  // For vertical worktops, drainers go above/below sink (Y direction)
  // For horizontal worktops, drainers go left/right of sink (X direction)
  // On vertical worktop: sink width stored as cw runs in Y, length cl runs in X
  const drawW = isVerticalPlacement ? cl : cw;  // Drawn width (X dimension)
  const drawL = isVerticalPlacement ? cw : cl;  // Drawn length (Y dimension)
  
  // Swap left/right based on user's viewing perspective:
  // - RIGHT edge click (vertical): user faces left, swap needed
  // - FRONT edge click (horizontal): user faces back, swap needed
  let placeLeft = (actualSide === 'left' || actualSide === 'both');
  let placeRight = (actualSide === 'right' || actualSide === 'both');
  
  const needsSwap = (isVerticalPlacement && edge === 'right') || 
                    (!isVerticalPlacement && edge === 'back');
  
  if (needsSwap && actualSide !== 'both') {
    const temp = placeLeft;
    placeLeft = placeRight;
    placeRight = temp;
  }
  
  if (placeLeft) {
    if (isVerticalPlacement) {
      // Vertical worktop: "left" drainer goes above sink (smaller Y)
      cutouts.push({
        id: nextId++,
        type: drainerType,
        parentId: w.id,
        sinkId: sinkId,
        x: cx,
        y: cy - DRAINER_LENGTH,
        width: cl,  // Same width as sink
        length: DRAINER_LENGTH,  // Extends in Y direction
        grooveCount: 5,
        setback: sb,
        side: 'left',
        clickedSide: actualSide,  // What user clicked (left/right/both)
        radius: 15,
        vertical: true
      });
    } else {
      // Horizontal worktop: "left" drainer goes to left of sink (smaller X)
      cutouts.push({
        id: nextId++,
        type: drainerType,
        parentId: w.id,
        sinkId: sinkId,
        x: cx - DRAINER_LENGTH,
        y: cy,
        width: DRAINER_LENGTH,
        length: cl,
        grooveCount: 5,
        setback: sb,
        side: 'left',
        clickedSide: actualSide,  // What user clicked (left/right/both)
        radius: 15
      });
    }
  }
  
  if (placeRight) {
    if (isVerticalPlacement) {
      // Vertical worktop: "right" drainer goes below sink (larger Y)
      cutouts.push({
        id: nextId++,
        type: drainerType,
        parentId: w.id,
        sinkId: sinkId,
        x: cx,
        y: cy + drawL,  // After the drawn length of sink
        width: cl,  // Same width as sink
        length: DRAINER_LENGTH,  // Extends in Y direction
        grooveCount: 5,
        setback: sb,
        side: 'right',
        clickedSide: actualSide,  // What user clicked (left/right/both)
        radius: 15,
        vertical: true
      });
    } else {
      // Horizontal worktop: "right" drainer goes to right of sink (larger X)
      cutouts.push({
        id: nextId++,
        type: drainerType,
        parentId: w.id,
        sinkId: sinkId,
        x: cx + cw,
        y: cy,
        width: DRAINER_LENGTH,
        length: cl,
        grooveCount: 5,
        setback: sb,
        side: 'right',
        clickedSide: actualSide,  // What user clicked (left/right/both)
        radius: 15
      });
    }
  }
  
  // Ask for tap hole
  const addTap = confirm('Add tap hole behind sink?');
  if (addTap) {
    const tapDist = prompt('Tap hole distance behind sink (mm):', '50');
    const tapOffset = parseInt(tapDist) || 50;
    
    let tapX, tapY;
    
    if (isVerticalPlacement) {
      // Vertical worktop: "behind" means toward the WALL (opposite of the edge you clicked)
      // LEFT edge clicked = front is LEFT, back/wall is RIGHT ‚Üí tap goes toward larger X
      // RIGHT edge clicked = front is RIGHT, back/wall is LEFT ‚Üí tap goes toward smaller X
      tapY = cy + drawL / 2;  // Centered on sink
      
      if (edge === 'left') {
        // Clicked LEFT edge: sink set back from left, wall is on RIGHT
        // Tap goes BEHIND sink toward RIGHT (larger X)
        tapX = Math.min(w.x + w.length - 20, cx + drawW + tapOffset);
      } else {
        // Clicked RIGHT edge: sink set back from right, wall is on LEFT  
        // Tap goes BEHIND sink toward LEFT (smaller X)
        tapX = Math.max(w.x + 20, cx - tapOffset);
      }
    } else {
      // Horizontal worktop: "behind" means OPPOSITE side from clicked edge
      // BACK edge clicked = sink near back, tap goes toward FRONT (larger Y)
      // FRONT edge clicked = sink near front, tap goes toward BACK (smaller Y)
      tapX = cx + cw / 2;  // Centered on sink
      
      if (edge === 'back') {
        // Sink near back edge, tap goes behind it toward FRONT (larger Y)
        tapY = Math.min(w.y + w.depth - 20, cy + drawL + tapOffset);
      } else {
        // Sink near front edge, tap goes behind it toward BACK (smaller Y)
        tapY = Math.max(w.y + 20, cy - tapOffset);
      }
    }
    
    // Console debug info
    console.log(`TAP PLACEMENT: edge=${edge}, isVertical=${isVerticalPlacement}`);
    console.log(`  Tap: x=${tapX}, y=${tapY}`);
    
    cutouts.push({
      id: nextId++,
      type: 'tap',
      parentId: w.id,
      sinkId: sinkId,
      x: tapX,
      y: tapY,
      diameter: 35,
      setback: tapOffset,
      draggable: true
    });
  }
  
  pendingSinkData = null;
  renderLists();
  render();
  updateSummary();
}

function addCutout(type) {
  if (!edgeMenuTarget) return;
  
  const w = worktops.find(w => w.id === edgeMenuTarget.wId);
  if (!w) return;
  
  const { edge } = edgeMenuTarget;
  const edgeLen = (edge === 'back' || edge === 'front') ? w.length : w.depth;
  
  saveHistory();
  hideEdgeMenu();
  
  if (type === 'undermount_sink') {
    // Undermount sink with optional tap hole
    const width = prompt('Sink WIDTH ‚Üê ‚Üí (mm):\n(How wide across the front)', '480');
    if (!width) return;
    const length = prompt('Sink LENGTH ‚Üë ‚Üì (mm):\n(How deep front to back)', '380');
    if (!length) return;
    const radius = prompt('Corner radius (mm):', '10');
    if (!radius) return;
    const setbackInput = prompt('Setback from front edge (mm):\n(Enter 0 for Butler sink - no front bar)', '100');
    if (setbackInput === null) return;
    const centerPos = prompt(`Centre position along worktop (mm, 0-${edgeLen}):`, Math.round(edgeLen / 2).toString());
    if (!centerPos) return;
    
    const cw = parseInt(width) || 800;
    const cl = parseInt(length) || 500;
    const cr = parseInt(radius) || 25;
    const sb = parseInt(setbackInput) || 0;
    const center = parseInt(centerPos) || edgeLen / 2;
    const isButler = (sb === 0);
    
    // Check if this is a vertical worktop (left/right edge)
    const isVerticalPlacement = (edge === 'left' || edge === 'right');
    
    // For vertical worktops, swap width/length for positioning
    // User enters Width (across front) and Length (front to back)
    // On vertical worktop: Width runs along Y axis, Length runs along X axis
    const placeW = isVerticalPlacement ? cl : cw;  // X dimension
    const placeL = isVerticalPlacement ? cw : cl;  // Y dimension
    
    let cx, cy;
    if (edge === 'front') {
      cx = w.x + center - cw/2;
      cy = isButler ? w.y + w.depth - cl : w.y + w.depth - sb - cl;
    } else if (edge === 'back') {
      cx = w.x + center - cw/2;
      cy = w.y + sb;
    } else if (edge === 'left') {
      // Vertical worktop: setback from left (X), center along depth (Y)
      cx = w.x + sb;
      cy = w.y + center - placeL/2;
    } else {
      // Right edge: setback from right (X), center along depth (Y)
      cx = w.x + w.length - sb - placeW;
      cy = w.y + center - placeL/2;
    }
    
    const sinkId = nextId++;
    cutouts.push({
      id: sinkId,
      type: 'undermount_sink',
      parentId: w.id,
      x: cx,
      y: cy,
      width: cw,  // Store user's entered width
      length: cl, // Store user's entered length
      radius: cr,
      setback: sb,
      isButler: isButler,
      drainerSide: 'none'
    });
    
    // Ask for tap hole
    const addTap = confirm('Add tap hole behind sink?');
    if (addTap) {
      const tapDist = prompt('Tap hole distance behind sink (mm):', '50');
      const tapOffset = parseInt(tapDist) || 50;
      
      let tapX, tapY;
      
      if (isVerticalPlacement) {
        // Vertical worktop: "behind" means toward the WALL (opposite of the edge you clicked)
        // LEFT edge clicked = front is LEFT, back/wall is RIGHT ‚Üí tap goes toward larger X
        // RIGHT edge clicked = front is RIGHT, back/wall is LEFT ‚Üí tap goes toward smaller X
        tapY = cy + placeL / 2;  // Centered on sink
        
        if (edge === 'left') {
          // Clicked LEFT edge: sink set back from left, wall is on RIGHT
          // Tap goes BEHIND sink toward RIGHT (larger X)
          tapX = Math.min(w.x + w.length - 20, cx + placeW + tapOffset);
        } else {
          // Clicked RIGHT edge: sink set back from right, wall is on LEFT  
          // Tap goes BEHIND sink toward LEFT (smaller X)
          tapX = Math.max(w.x + 20, cx - tapOffset);
        }
      } else {
        // Horizontal worktop: "behind" means OPPOSITE side from clicked edge
        // BACK edge clicked = sink near back, tap goes toward FRONT (larger Y)
        // FRONT edge clicked = sink near front, tap goes toward BACK (smaller Y)
        tapX = cx + cw / 2;  // Centered on sink
        
        if (edge === 'back') {
          // Sink near back edge, tap goes behind it toward FRONT (larger Y)
          tapY = Math.min(w.y + w.depth - 20, cy + placeL + tapOffset);
        } else {
          // Sink near front edge, tap goes behind it toward BACK (smaller Y)
          tapY = Math.max(w.y + 20, cy - tapOffset);
        }
      }
      
      console.log(`TAP PLACEMENT: edge=${edge}, tap at x=${tapX}, y=${tapY}`);
      
      cutouts.push({
        id: nextId++,
        type: 'tap',
        parentId: w.id,
        sinkId: sinkId,
        x: tapX,
        y: tapY,
        diameter: 35,
        setback: tapOffset,
        draggable: true
      });
    }
    
    renderLists();
    render();
    updateSummary();
    
  } else if (type === 'sink_with_drainers') {
    // Sink with drainers - show modal for drainer position
    const width = prompt('Sink WIDTH ‚Üê ‚Üí (mm):\n(How wide across the front)', '480');
    if (!width) return;
    const length = prompt('Sink LENGTH ‚Üë ‚Üì (mm):\n(How deep front to back)', '380');
    if (!length) return;
    const radius = prompt('Corner radius (mm):', '10');
    if (!radius) return;
    const setbackInput = prompt('Setback from front edge (mm):\n(Enter 0 for Butler sink - no front bar)', '100');
    if (setbackInput === null) return;
    const centerPos = prompt(`Centre position along worktop (mm, 0-${edgeLen}):`, Math.round(edgeLen / 2).toString());
    if (!centerPos) return;
    
    const cw = parseInt(width) || 480;
    const cl = parseInt(length) || 380;
    const cr = parseInt(radius) || 25;
    const sb = parseInt(setbackInput) || 0;
    const center = parseInt(centerPos) || edgeLen / 2;
    const isButler = (sb === 0);
    
    // Check if this is a vertical worktop (left/right edge)
    const isVerticalPlacement = (edge === 'left' || edge === 'right');
    const placeW = isVerticalPlacement ? cl : cw;  // X dimension
    const placeL = isVerticalPlacement ? cw : cl;  // Y dimension
    
    let cx, cy;
    if (edge === 'front') {
      cx = w.x + center - cw/2;
      cy = isButler ? w.y + w.depth - cl : w.y + w.depth - sb - cl;
    } else if (edge === 'back') {
      cx = w.x + center - cw/2;
      cy = w.y + sb;
    } else if (edge === 'left') {
      cx = w.x + sb;
      cy = w.y + center - placeL/2;
    } else {
      cx = w.x + w.length - sb - placeW;
      cy = w.y + center - placeL/2;
    }
    
    // Store data and show modal (include isVerticalPlacement for drainer positioning)
    pendingSinkData = { w, edge, cx, cy, cw, cl, cr, sb, isButler, isVerticalPlacement };
    showDrainerModal();
    
  } else if (type === 'overmount_sink') {
    // Overmount sink - rectangular cutout like hob
    const width = prompt('Overmount Sink WIDTH ‚Üê ‚Üí (mm):', '800');
    if (!width) return;
    const length = prompt('Overmount Sink LENGTH ‚Üë ‚Üì (mm):', '500');
    if (!length) return;
    const setback = prompt('Setback from front edge (mm):', '50');
    if (!setback) return;
    const centerPos = prompt(`Centre position along worktop (mm, 0-${edgeLen}):`, Math.round(edgeLen / 2).toString());
    if (!centerPos) return;
    
    const cw = parseInt(width) || 800;
    const cl = parseInt(length) || 500;
    const sb = parseInt(setback) || 100;
    const center = parseInt(centerPos) || edgeLen / 2;
    
    // Check if this is a vertical worktop (left/right edge)
    const isVerticalPlacement = (edge === 'left' || edge === 'right');
    const placeW = isVerticalPlacement ? cl : cw;  // X dimension
    const placeL = isVerticalPlacement ? cw : cl;  // Y dimension
    
    let cx, cy;
    if (edge === 'front') {
      cx = w.x + center - cw/2;
      cy = w.y + w.depth - sb - cl;
    } else if (edge === 'back') {
      cx = w.x + center - cw/2;
      cy = w.y + sb;
    } else if (edge === 'left') {
      cx = w.x + sb;
      cy = w.y + center - placeL/2;
    } else {
      cx = w.x + w.length - sb - placeW;
      cy = w.y + center - placeL/2;
    }
    
    cutouts.push({
      id: nextId++,
      type: 'overmount_sink',
      parentId: w.id,
      x: cx,
      y: cy,
      width: cw,
      length: cl,
      setback: sb
    });
    
    renderLists();
    render();
    updateSummary();
    
  } else if (type === 'hob' || type === 'recess_hob') {
    // Hob or Recess Hob - rectangular cutout
    const label = type === 'recess_hob' ? 'Recess Hob' : 'Hob';
    const width = prompt(`${label} WIDTH ‚Üê ‚Üí (mm):`, '560');
    if (!width) return;
    const length = prompt(`${label} LENGTH ‚Üë ‚Üì (mm):`, '490');
    if (!length) return;
    const setback = prompt('Setback from front edge (mm):', '50');
    if (!setback) return;
    const centerPos = prompt(`Centre position along worktop (mm, 0-${edgeLen}):`, Math.round(edgeLen / 2).toString());
    if (!centerPos) return;
    
    const cw = parseInt(width) || 560;
    const cl = parseInt(length) || 490;
    const sb = parseInt(setback) || 50;
    const center = parseInt(centerPos) || edgeLen / 2;
    
    // Check if this is a vertical worktop (left/right edge)
    const isVerticalPlacement = (edge === 'left' || edge === 'right');
    const placeW = isVerticalPlacement ? cl : cw;  // X dimension
    const placeL = isVerticalPlacement ? cw : cl;  // Y dimension
    
    let cx, cy;
    if (edge === 'front') {
      cx = w.x + center - cw/2;
      cy = w.y + w.depth - sb - cl;
    } else if (edge === 'back') {
      cx = w.x + center - cw/2;
      cy = w.y + sb;
    } else if (edge === 'left') {
      cx = w.x + sb;
      cy = w.y + center - placeL/2;
    } else {
      cx = w.x + w.length - sb - placeW;
      cy = w.y + center - placeL/2;
    }
    
    cutouts.push({
      id: nextId++,
      type: type,
      parentId: w.id,
      x: cx,
      y: cy,
      width: cw,
      length: cl,
      setback: sb
    });
    
    renderLists();
    render();
    updateSummary();
    
  } else if (type === 'tap') {
    // Tap hole / Pop up socket - place anywhere, draggable
    const diameter = prompt('Hole diameter (mm):\n(35mm for tap, 80mm for pop-up socket)', '35');
    if (!diameter) return;
    
    const d = parseInt(diameter) || 35;
    
    // Place at centre of worktop initially
    const tapX = w.x + w.length / 2;
    const tapY = w.y + w.depth / 2;
    
    cutouts.push({
      id: nextId++,
      type: 'tap',
      parentId: w.id,
      x: tapX,
      y: tapY,
      diameter: d,
      draggable: true
    });
    
    alert('Tap/socket placed at centre. Select it and drag to position, or edit coordinates in Properties panel.');
    
    renderLists();
    render();
    updateSummary();
  }
}

function deleteCutout(id) {
  saveHistory();
  cutouts = cutouts.filter(c => c.id !== id);
  if (selectedType === 'cutout' && selectedId === id) {
    selectedType = null;
    selectedId = null;
  }
  renderLists();
  render();
  updateSummary();
}

function setEdgeType(type) {
  if (!edgeMenuTarget) return;
  saveHistory();
  
  const w = worktops.find(w => w.id === edgeMenuTarget.wId);
  if (!w) return;
  
  const { edge } = edgeMenuTarget;
  const MAX_LENGTH = 3200;
  
  // Get FULL edge length (ignore joints for upstands) - but account for stepouts
  let fullLength = (edge === 'back' || edge === 'front') ? w.length : w.depth;
  
  // Check if this is a stepout edge
  const isStepoutEdge = edge.startsWith('stepout_');
  
  // Adjust for stepout on main edges
  if (!isStepoutEdge && w.stepout) {
    const s = w.stepout;
    const isVertical = w.depth > w.length;
    
    if (isVertical) {
      // Vertical worktop - stepout affects left/right edges
      if ((s.corner === 'front-left' && edge === 'left') ||
          (s.corner === 'front-right' && edge === 'right') ||
          (s.corner === 'back-left' && edge === 'left') ||
          (s.corner === 'back-right' && edge === 'right')) {
        fullLength = w.depth - s.length;
      }
    } else {
      // Horizontal worktop - stepout affects front/back edges
      if ((s.corner === 'front-left' && edge === 'front') ||
          (s.corner === 'back-left' && edge === 'back') ||
          (s.corner === 'front-right' && edge === 'front') ||
          (s.corner === 'back-right' && edge === 'back')) {
        fullLength = w.length - s.length;
      }
    }
  }
  
  // For stepout edges, use the segment length
  if (isStepoutEdge && edgeMenuTarget.seg) {
    fullLength = edgeMenuTarget.seg.end - edgeMenuTarget.seg.start;
  }
  
  // Calculate position for upstand - sits directly against worktop edge
  let vertical = (edge === 'left' || edge === 'right' || edge === 'stepout_left' || edge === 'stepout_right' || edge === 'stepout_outer' || edge === 'stepout_inner');
  
  if (type === 'upstand' || type === 'splashback') {
    const height = type === 'splashback' ? prompt('Splashback height (mm):', '300') : '100';
    if (!height) return;
    
    const h = parseInt(height) || 100;
    
    // Handle stepout edges first
    if (isStepoutEdge && w.stepout) {
      const s = w.stepout;
      const isVertical = w.depth > w.length;
      const seg = edgeMenuTarget.seg;
      const upstandLen = seg.end - seg.start;
      
      console.log('Creating upstand for stepout edge:', edge, 'corner:', s.corner, 'isVertical worktop:', isVertical, 'len:', upstandLen);
      console.log('Worktop position:', w.x, w.y, 'size:', w.length, 'x', w.depth);
      
      // Calculate position based on stepout geometry - store the actual edge position
      let upstandX, upstandY, isVerticalUpstand;
      
      // For horizontal worktops (stepout extends down/up)
      if (!isVertical) {
        if (edge === 'stepout_bottom') {
          isVerticalUpstand = false;
          if (s.corner === 'front-left') {
            upstandX = w.x;
            upstandY = w.y + w.depth + s.depth; // Bottom of stepout
          } else if (s.corner === 'front-right') {
            upstandX = w.x + w.length - s.length;
            upstandY = w.y + w.depth + s.depth;
          } else if (s.corner === 'back-left') {
            upstandX = w.x;
            upstandY = w.y - s.depth;
          } else {
            upstandX = w.x + w.length - s.length;
            upstandY = w.y - s.depth;
          }
        } else if (edge === 'stepout_top') {
          isVerticalUpstand = false;
          if (s.corner === 'back-left') {
            upstandX = w.x;
            upstandY = w.y - s.depth;
          } else if (s.corner === 'back-right') {
            upstandX = w.x + w.length - s.length;
            upstandY = w.y - s.depth;
          }
        } else if (edge === 'stepout_left') {
          isVerticalUpstand = true;
          if (s.corner === 'front-left') {
            upstandX = w.x;
            upstandY = w.y + w.depth;
          } else if (s.corner === 'front-right') {
            upstandX = w.x + w.length - s.length;
            upstandY = w.y + w.depth;
          } else if (s.corner === 'back-left') {
            upstandX = w.x;
            upstandY = w.y - s.depth;
          } else {
            upstandX = w.x + w.length - s.length;
            upstandY = w.y - s.depth;
          }
        } else if (edge === 'stepout_right') {
          isVerticalUpstand = true;
          if (s.corner === 'front-left') {
            upstandX = w.x + s.length;
            upstandY = w.y + w.depth;
          } else if (s.corner === 'front-right') {
            upstandX = w.x + w.length;
            upstandY = w.y + w.depth;
          } else if (s.corner === 'back-left') {
            upstandX = w.x + s.length;
            upstandY = w.y - s.depth;
          } else {
            upstandX = w.x + w.length;
            upstandY = w.y - s.depth;
          }
        }
      } else {
        // For vertical worktops (stepout extends left/right)
        if (edge === 'stepout_outer') {
          isVerticalUpstand = true;
          if (s.corner === 'front-left' || s.corner === 'back-left') {
            upstandX = w.x - s.depth;
          } else {
            upstandX = w.x + w.length + s.depth;
          }
          upstandY = s.corner.startsWith('front') ? w.y + w.depth - s.length : w.y;
        } else if (edge === 'stepout_inner') {
          isVerticalUpstand = true;
          upstandX = s.corner.includes('left') ? w.x : w.x + w.length;
          upstandY = s.corner.startsWith('front') ? w.y + w.depth - s.length : w.y;
        } else if (edge === 'stepout_bottom') {
          isVerticalUpstand = false;
          if (s.corner === 'front-left' || s.corner === 'front-right') {
            upstandX = s.corner === 'front-left' ? w.x - s.depth : w.x + w.length;
            upstandY = w.y + w.depth;
          }
        } else if (edge === 'stepout_top') {
          isVerticalUpstand = false;
          if (s.corner === 'back-left' || s.corner === 'back-right') {
            upstandX = s.corner === 'back-left' ? w.x - s.depth : w.x + w.length;
            upstandY = w.y;
          }
        }
      }
      
      console.log('Upstand position:', upstandX, upstandY, 'vertical:', isVerticalUpstand);
      
      // Create upstand for stepout edge
      if (upstandLen > 0 && upstandX !== undefined && upstandY !== undefined) {
        upstands.push({
          id: nextId++,
          x: upstandX,
          y: upstandY,
          absoluteX: upstandX,
          absoluteY: upstandY,
          length: Math.round(upstandLen),
          height: h,
          vertical: isVerticalUpstand,
          isSplash: type === 'splashback',
          parentEdge: edge,
          parentId: w.id
        });
        console.log('Upstand created successfully');
      } else {
        console.log('Failed to create upstand - invalid position or length');
      }
      
      renderLists();
      if (type === 'splashback') checkAndSplitUpstands();
      hideEdgeMenu();
      render();
      updateSummary();
      return;
    }
    
    // Find CONNECTED worktops only (those that share a joint or overlap)
    function findConnectedWorktops(startWorktop, edgeType) {
      const connected = [startWorktop];
      const checked = new Set([startWorktop.id]);
      
      // BFS to find all connected worktops at same edge
      let queue = [startWorktop];
      while (queue.length > 0) {
        const current = queue.shift();
        
        // Check all other worktops
        worktops.forEach(other => {
          if (checked.has(other.id)) return;
          
          // Check if edges align
          let edgeAligned = false;
          if (edgeType === 'back' || edgeType === 'front') {
            const currentEdgeY = (edgeType === 'back') ? current.y : current.y + current.depth;
            const otherEdgeY = (edgeType === 'back') ? other.y : other.y + other.depth;
            edgeAligned = Math.abs(currentEdgeY - otherEdgeY) < 30;
          } else {
            const currentEdgeX = (edgeType === 'left') ? current.x : current.x + current.length;
            const otherEdgeX = (edgeType === 'left') ? other.x : other.x + other.length;
            edgeAligned = Math.abs(currentEdgeX - otherEdgeX) < 30;
          }
          
          if (!edgeAligned) return;
          
          // Check if they're actually touching (overlapping in the perpendicular direction)
          let touching = false;
          if (edgeType === 'back' || edgeType === 'front') {
            // For horizontal edges, check X overlap
            const xOverlap = !(current.x + current.length < other.x - 30 || other.x + other.length < current.x - 30);
            touching = xOverlap;
          } else {
            // For vertical edges, check Y overlap
            const yOverlap = !(current.y + current.depth < other.y - 30 || other.y + other.depth < current.y - 30);
            touching = yOverlap;
          }
          
          if (touching) {
            checked.add(other.id);
            connected.push(other);
            queue.push(other);
          }
        });
      }
      
      return connected;
    }
    
    // For back/front edges
    if (edge === 'back' || edge === 'front') {
      const edgeY = (edge === 'back') ? w.y : w.y + w.depth;
      
      // Find only CONNECTED worktops at this edge
      const connectedWorktops = findConnectedWorktops(w, edge);
      
      // Sort by X position
      connectedWorktops.sort((a, b) => a.x - b.x);
      
      // Find X range of connected worktops only
      let xStart = Infinity, xEnd = -Infinity;
      connectedWorktops.forEach(wt => {
        xStart = Math.min(xStart, wt.x);
        xEnd = Math.max(xEnd, wt.x + wt.length);
        
        // Extend range to include stepout if it's on the same edge (for vertical worktops)
        if (wt.stepout) {
          const s = wt.stepout;
          const isVerticalWt = wt.depth > wt.length;
          
          if (isVerticalWt) {
            // Vertical worktop - stepout extends LEFT or RIGHT
            // For back edge: back-left/back-right stepouts
            // For front edge: front-left/front-right stepouts
            if (edge === 'back' && (s.corner === 'back-left' || s.corner === 'back-right')) {
              if (s.corner === 'back-left') {
                xStart = Math.min(xStart, wt.x - s.depth);
              } else {
                xEnd = Math.max(xEnd, wt.x + wt.length + s.depth);
              }
            } else if (edge === 'front' && (s.corner === 'front-left' || s.corner === 'front-right')) {
              if (s.corner === 'front-left') {
                xStart = Math.min(xStart, wt.x - s.depth);
              } else {
                xEnd = Math.max(xEnd, wt.x + wt.length + s.depth);
              }
            }
          }
        }
      });
      
      // Remove existing upstands only in this X range (including stepout upstands on same edge)
      upstands = upstands.filter(u => {
        const isMatchingStepoutEdge = (edge === 'back' && u.parentEdge === 'stepout_top') ||
                                       (edge === 'front' && u.parentEdge === 'stepout_bottom');
        if (u.parentEdge !== edge && !isMatchingStepoutEdge) return true;
        const absY = u.absoluteY !== undefined ? u.absoluteY : u.y;
        const absX = u.absoluteX !== undefined ? u.absoluteX : u.x;
        // Keep upstands that are not at this Y level OR not in this X range
        if (Math.abs(absY - edgeY) > 30) return true;
        if (absX + u.length < xStart - 30 || absX > xEnd + 30) return true;
        return false;
      });
      
      const totalLength = xEnd - xStart;
      
      // Store worktop joints
      const joints = [];
      let cumulative = 0;
      for (let i = 0; i < connectedWorktops.length - 1; i++) {
        cumulative += connectedWorktops[i].length;
        joints.push(xStart + cumulative); // Absolute X positions
      }
      
      // If > 3200mm, split at ONE seam (in case no splash is added)
      if (totalLength > MAX_LENGTH) {
        // Find first valid joint
        let splitAt = null;
        for (const j of joints) {
          const relJ = j - xStart;
          if (relJ <= MAX_LENGTH && (totalLength - relJ) <= MAX_LENGTH) {
            splitAt = relJ;
            break;
          }
        }
        
        if (splitAt !== null) {
          upstands.push({
            id: nextId++,
            absoluteX: xStart,
            absoluteY: edgeY,
            x: xStart,
            y: edgeY,
            length: Math.round(splitAt),
            height: h,
            vertical: false,
            isSplash: type === 'splashback',
            isContinuous: true,
            parentEdge: edge,
            parentId: w.id,
            edgeStart: 0,
            joints: joints
          });
          
          upstands.push({
            id: nextId++,
            absoluteX: xStart + splitAt,
            absoluteY: edgeY,
            x: xStart + splitAt,
            y: edgeY,
            length: Math.round(totalLength - splitAt),
            height: h,
            vertical: false,
            isSplash: type === 'splashback',
            isContinuous: true,
            parentEdge: edge,
            parentId: w.id,
            edgeStart: splitAt,
            joints: joints
          });
          console.log('Split at seam:', splitAt + 'mm + ' + (totalLength - splitAt) + 'mm');
        } else {
          // No valid joint, create one piece
          upstands.push({
            id: nextId++,
            absoluteX: xStart,
            absoluteY: edgeY,
            x: xStart,
            y: edgeY,
            length: Math.round(totalLength),
            height: h,
            vertical: false,
            isSplash: type === 'splashback',
            isContinuous: true,
            parentEdge: edge,
            parentId: w.id,
            edgeStart: 0,
            joints: joints
          });
        }
      } else if (totalLength >= 50) {
        // <= 3200mm, create ONE piece
        upstands.push({
          id: nextId++,
          absoluteX: xStart,
          absoluteY: edgeY,
          x: xStart,
          y: edgeY,
          length: Math.round(totalLength),
          height: h,
          vertical: false,
          isSplash: type === 'splashback',
          isContinuous: true,
          parentEdge: edge,
          parentId: w.id,
          edgeStart: 0,
          joints: joints
        });
      }
    } else {
      // For left/right edges
      const edgeX = (edge === 'left') ? w.x : w.x + w.length;
      
      // Find only CONNECTED worktops at this edge
      const connectedWorktops = findConnectedWorktops(w, edge);
      
      // Sort by Y position
      connectedWorktops.sort((a, b) => a.y - b.y);
      
      // Find Y range of connected worktops only
      let yStart = Infinity, yEnd = -Infinity;
      connectedWorktops.forEach(wt => {
        yStart = Math.min(yStart, wt.y);
        yEnd = Math.max(yEnd, wt.y + wt.depth);
        
        // Extend range to include stepout if it's on the same side
        if (wt.stepout) {
          const s = wt.stepout;
          const isVerticalWt = wt.depth > wt.length;
          
          if (!isVerticalWt) {
            // Check if stepout is on the same side as this edge
            if (edge === 'left' && (s.corner === 'front-left' || s.corner === 'back-left')) {
              // Front-left: stepout extends DOWN (increases yEnd)
              // Back-left: stepout extends UP (decreases yStart)
              if (s.corner === 'front-left') {
                yEnd = Math.max(yEnd, wt.y + wt.depth + s.depth);
              } else {
                yStart = Math.min(yStart, wt.y - s.depth);
              }
            } else if (edge === 'right' && (s.corner === 'front-right' || s.corner === 'back-right')) {
              if (s.corner === 'front-right') {
                yEnd = Math.max(yEnd, wt.y + wt.depth + s.depth);
              } else {
                yStart = Math.min(yStart, wt.y - s.depth);
              }
            }
          }
        }
      });
      
      // Remove existing upstands only in this Y range (including stepout upstands on same edge)
      upstands = upstands.filter(u => {
        // Keep upstands on different edges, but remove stepout_left when adding left, etc.
        const isMatchingStepoutEdge = (edge === 'left' && u.parentEdge === 'stepout_left') ||
                                       (edge === 'right' && u.parentEdge === 'stepout_right');
        if (u.parentEdge !== edge && !isMatchingStepoutEdge) return true;
        
        const absX = u.absoluteX !== undefined ? u.absoluteX : u.x;
        const absY = u.absoluteY !== undefined ? u.absoluteY : u.y;
        // Keep upstands that are not at this X level OR not in this Y range
        if (Math.abs(absX - edgeX) > 30) return true;
        if (absY + u.length < yStart - 30 || absY > yEnd + 30) return true;
        return false;
      });
      
      const totalLength = yEnd - yStart;
      
      // Store worktop joints
      const joints = [];
      let cumulative = 0;
      for (let i = 0; i < connectedWorktops.length - 1; i++) {
        cumulative += connectedWorktops[i].depth;
        joints.push(yStart + cumulative); // Absolute Y positions
      }
      
      // If > 3200mm, split at ONE seam
      if (totalLength > MAX_LENGTH) {
        let splitAt = null;
        for (const j of joints) {
          const relJ = j - yStart;
          if (relJ <= MAX_LENGTH && (totalLength - relJ) <= MAX_LENGTH) {
            splitAt = relJ;
            break;
          }
        }
        
        if (splitAt !== null) {
          upstands.push({
            id: nextId++,
            absoluteX: edgeX,
            absoluteY: yStart,
            x: edgeX,
            y: yStart,
            length: Math.round(splitAt),
            height: h,
            vertical: true,
            isSplash: type === 'splashback',
            isContinuous: true,
            parentEdge: edge,
            parentId: w.id,
            edgeStart: 0,
            joints: joints
          });
          
          upstands.push({
            id: nextId++,
            absoluteX: edgeX,
            absoluteY: yStart + splitAt,
            x: edgeX,
            y: yStart + splitAt,
            length: Math.round(totalLength - splitAt),
            height: h,
            vertical: true,
            isSplash: type === 'splashback',
            isContinuous: true,
            parentEdge: edge,
            parentId: w.id,
            edgeStart: splitAt,
            joints: joints
          });
        } else {
          upstands.push({
            id: nextId++,
            absoluteX: edgeX,
            absoluteY: yStart,
            x: edgeX,
            y: yStart,
            length: Math.round(totalLength),
            height: h,
            vertical: true,
            isSplash: type === 'splashback',
            isContinuous: true,
            parentEdge: edge,
            parentId: w.id,
            edgeStart: 0,
            joints: joints
          });
        }
      } else if (totalLength >= 50) {
        upstands.push({
          id: nextId++,
          absoluteX: edgeX,
          absoluteY: yStart,
          x: edgeX,
          y: yStart,
          length: Math.round(totalLength),
          height: h,
          vertical: true,
          isSplash: type === 'splashback',
          isContinuous: true,
          parentEdge: edge,
          parentId: w.id,
          edgeStart: 0,
          joints: joints
        });
      }
    }
    
    renderLists();
    
    // If adding splashback, check if it should split existing upstands
    if (type === 'splashback') {
      checkAndSplitUpstands();
    }
  } else if (type === 'profile') {
    // Show profile selection modal
    showProfileModal();
    return; // Don't hide menu yet - modal will handle it
  } else if (type === 'dropdown') {
    const seg = edgeMenuTarget.seg;
    const h = prompt('Dropdown height (800-1000mm):', '900');
    if (h) {
      const height = parseInt(h);
      if (isNaN(height) || height < 800 || height > 1000) {
        alert('Please enter a size between 800mm and 1000mm');
        return;
      }
      if (!w.edgeTypes) w.edgeTypes = {};
      w.edgeTypes[`${edge}_${seg.start}_${seg.end}`] = { type: 'dropdown', height: height };
    }
  } else if (type === 'none') {
    const seg = edgeMenuTarget.seg;
    if (w.edgeTypes) delete w.edgeTypes[`${edge}_${seg.start}_${seg.end}`];
    
    // Remove upstands at this edge position
    if (edge === 'back' || edge === 'front') {
      const edgeY = (edge === 'back') ? w.y : w.y + w.depth;
      upstands = upstands.filter(u => {
        if (u.parentEdge !== edge) return true;
        const absY = u.absoluteY !== undefined ? u.absoluteY : u.y;
        return Math.abs(absY - edgeY) > 30;
      });
    } else {
      const edgeX = (edge === 'left') ? w.x : w.x + w.length;
      upstands = upstands.filter(u => {
        if (u.parentEdge !== edge) return true;
        const absX = u.absoluteX !== undefined ? u.absoluteX : u.x;
        return Math.abs(absX - edgeX) > 30;
      });
    }
    renderLists();
  }
  
  hideEdgeMenu();
  render();
  updateSummary();
}

// ========== WORKTOP SPLITS ==========
function addWorktopSplit() {
  if (!edgeMenuTarget) return;
  
  const w = worktops.find(w => w.id === edgeMenuTarget.wId);
  if (!w) return;
  
  const { edge, start, end } = edgeMenuTarget;
  
  // Determine split direction based on edge clicked
  // For back/front edges, split is perpendicular (across the length)
  // For left/right edges, split is perpendicular (across the depth)
  const isHorizontalEdge = (edge === 'back' || edge === 'front');
  
  // Ask where to place the split
  const maxPos = isHorizontalEdge ? w.length : w.depth;
  const direction = isHorizontalEdge ? 'length' : 'depth';
  const defaultPos = Math.round(maxPos / 2);
  
  const posStr = prompt(
    `Add split/join across worktop.\n\n` +
    `Enter position from ${isHorizontalEdge ? 'left' : 'back'} edge (mm):\n` +
    `(Worktop ${direction}: ${maxPos}mm)`,
    defaultPos
  );
  
  if (!posStr) return;
  
  const pos = parseInt(posStr);
  if (isNaN(pos) || pos <= 100 || pos >= maxPos - 100) {
    alert('Invalid position. Must be at least 100mm from each end.');
    return;
  }
  
  saveHistory();
  
  // Initialize splits array if needed
  if (!w.splits) w.splits = [];
  
  // Add split
  w.splits.push({
    position: pos,
    direction: isHorizontalEdge ? 'vertical' : 'horizontal'  // Split line direction
  });
  
  // Sort splits by position
  w.splits.sort((a, b) => a.position - b.position);
  
  hideEdgeMenu();
  render();
  updateSummary();
  
  alert(`Split added at ${pos}mm. This worktop will now be cut as ${w.splits.length + 1} pieces.`);
}

function removeWorktopSplit() {
  if (!edgeMenuTarget) return;
  
  const w = worktops.find(w => w.id === edgeMenuTarget.wId);
  if (!w || !w.splits || w.splits.length === 0) return;
  
  saveHistory();
  
  // If multiple splits, ask which to remove
  if (w.splits.length === 1) {
    w.splits = [];
  } else {
    const splitList = w.splits.map((s, i) => `${i + 1}: ${s.position}mm (${s.direction})`).join('\n');
    const choice = prompt(
      `Which split do you want to remove?\n\n${splitList}\n\nEnter number (or 0 to remove all):`,
      '1'
    );
    
    if (choice === null) return;
    
    const idx = parseInt(choice);
    if (idx === 0) {
      w.splits = [];
    } else if (idx >= 1 && idx <= w.splits.length) {
      w.splits.splice(idx - 1, 1);
    }
  }
  
  hideEdgeMenu();
  render();
  updateSummary();
}

// ========== FIND ITEM ==========
function findItemAt(mx, my) {
  // Check cutouts first (they're on top of worktops)
  for (let i = cutouts.length - 1; i >= 0; i--) {
    const c = cutouts[i];
    
    if (c.type === 'socket') {
      // Socket on splashback - calculate hit area for all edge types
      const parent = upstands.find(u => u.id === c.parentId);
      if (parent) {
        const pw = worktops.find(w => w.id === parent.parentId);
        const edge = parent.parentEdge || 'back';
        const edgeStart = parent.edgeStart || 0;
        const splashHeight = parent.height;
        const isVertical = (edge === 'left' || edge === 'right');
        
        // Calculate splashback position - handle continuous splashbacks
        let ux, uy, socketX, socketY, socketW, socketH;
        
        if (parent.isContinuous && parent.absoluteX !== undefined) {
          // Continuous splashback
          if (edge === 'back') {
            ux = parent.absoluteX;
            uy = parent.absoluteY - splashHeight;
          } else if (edge === 'front') {
            ux = parent.absoluteX;
            uy = parent.absoluteY;
          } else if (edge === 'left') {
            ux = parent.absoluteX - splashHeight;
            uy = parent.absoluteY;
          } else {
            ux = parent.absoluteX;
            uy = parent.absoluteY;
          }
        } else if (pw) {
          if (edge === 'back') {
            ux = pw.x + edgeStart;
            uy = pw.y - splashHeight;
          } else if (edge === 'front') {
            ux = pw.x + edgeStart;
            uy = pw.y + pw.depth;
          } else if (edge === 'left') {
            ux = pw.x - splashHeight;
            uy = pw.y + edgeStart;
          } else { // right
            ux = pw.x + pw.length;
            uy = pw.y + edgeStart;
          }
        } else {
          ux = parent.absoluteX || parent.x || 0;
          uy = (parent.absoluteY || parent.y || 0) - splashHeight;
        }
        
        // Calculate socket hit area based on edge
        if (isVertical) {
          socketW = c.height;
          socketH = c.width;
          if (edge === 'left') {
            socketX = ux + (splashHeight - c.centerY - c.height/2);
            socketY = uy + (c.centerX - c.width/2);
          } else {
            socketX = ux + (c.centerY - c.height/2);
            socketY = uy + (c.centerX - c.width/2);
          }
        } else {
          socketW = c.width;
          socketH = c.height;
          socketX = ux + (c.centerX - c.width/2);
          if (edge === 'back') {
            socketY = uy + (splashHeight - c.centerY - c.height/2);
          } else {
            socketY = uy + (c.centerY - c.height/2);
          }
        }
        
        if (mx >= socketX && mx <= socketX + socketW && my >= socketY && my <= socketY + socketH) {
          return { type: 'cutout', item: c };
        }
      }
    } else if (c.type === 'tap') {
      // Circular hit area with padding
      const dx = mx - c.x;
      const dy = my - c.y;
      if (Math.sqrt(dx*dx + dy*dy) <= c.diameter/2 + 15) {
        return { type: 'cutout', item: c };
      }
    } else if (c.type === 'undermount_sink' || c.type === 'overmount_sink' || 
               c.type === 'hob' || c.type === 'recess_hob' ||
               c.type === 'drainer' || c.type === 'recess_drainer') {
      // Rectangular cutouts - sinks, hobs, drainers
      const padding = 10; // Extra click area
      const hitX = c.x - padding;
      const hitY = c.y - padding;
      const hitW = c.width + padding * 2;
      const hitH = (c.length || c.height) + padding * 2;
      
      if (mx >= hitX && mx <= hitX + hitW && my >= hitY && my <= hitY + hitH) {
        return { type: 'cutout', item: c };
      }
    } else {
      // Generic rectangular hit area
      if (mx >= c.x && mx <= c.x + c.width && my >= c.y && my <= c.y + (c.length || c.height)) {
        return { type: 'cutout', item: c };
      }
    }
  }
  
  // Check upstands - use actual height for splashbacks, depth for cills
  for (let i = upstands.length - 1; i >= 0; i--) {
    const u = upstands[i];
    let ux, uy, uw, uh;
    
    // Window cills have their own hit area calculation
    if (u.isWindowCill) {
      const cillDepth = u.depth || 200;
      const edge = u.parentEdge || 'back';
      
      if (u.isContinuous && u.absoluteX !== undefined) {
        if (edge === 'back') {
          ux = u.absoluteX;
          uy = u.absoluteY - cillDepth;
          uw = u.length;
          uh = cillDepth;
        } else if (edge === 'front') {
          ux = u.absoluteX;
          uy = u.absoluteY;
          uw = u.length;
          uh = cillDepth;
        } else if (edge === 'left') {
          ux = u.absoluteX - cillDepth;
          uy = u.absoluteY;
          uw = cillDepth;
          uh = u.length;
        } else {
          ux = u.absoluteX;
          uy = u.absoluteY;
          uw = cillDepth;
          uh = u.length;
        }
      } else {
        const parent = worktops.find(w => w.id === u.parentId);
        if (parent) {
          const edgeStart = u.edgeStart || 0;
          if (edge === 'back') {
            ux = parent.x + edgeStart;
            uy = parent.y - cillDepth;
            uw = u.length;
            uh = cillDepth;
          } else if (edge === 'front') {
            ux = parent.x + edgeStart;
            uy = parent.y + parent.depth;
            uw = u.length;
            uh = cillDepth;
          } else if (edge === 'left') {
            ux = parent.x - cillDepth;
            uy = parent.y + edgeStart;
            uw = cillDepth;
            uh = u.length;
          } else {
            ux = parent.x + parent.length;
            uy = parent.y + edgeStart;
            uw = cillDepth;
            uh = u.length;
          }
        } else {
          ux = u.x;
          uy = u.y;
          uw = u.length;
          uh = cillDepth;
        }
      }
    } else {
      // Regular upstands and splashbacks - use actual height
      const VISUAL_DEPTH = u.height || 100;
    
    // For continuous upstands, use absolute position
    if (u.isContinuous && u.absoluteX !== undefined) {
      const edge = u.parentEdge || 'back';
      
      if (edge === 'back') {
        ux = u.absoluteX;
        uy = u.absoluteY - VISUAL_DEPTH;
        uw = u.length;
        uh = VISUAL_DEPTH;
      } else if (edge === 'front') {
        ux = u.absoluteX;
        uy = u.absoluteY;
        uw = u.length;
        uh = VISUAL_DEPTH;
      } else if (edge === 'left') {
        ux = u.absoluteX - VISUAL_DEPTH;
        uy = u.absoluteY;
        uw = VISUAL_DEPTH;
        uh = u.length;
      } else { // right
        ux = u.absoluteX;
        uy = u.absoluteY;
        uw = VISUAL_DEPTH;
        uh = u.length;
      }
    } else {
      const parent = worktops.find(w => w.id === u.parentId);
      
      if (parent && u.parentEdge) {
        const edgeStart = u.edgeStart || 0;
        
        if (u.parentEdge === 'back') {
          ux = parent.x + edgeStart;
          uy = parent.y - VISUAL_DEPTH;
          uw = u.length;
          uh = VISUAL_DEPTH;
        } else if (u.parentEdge === 'front') {
          ux = parent.x + edgeStart;
          uy = parent.y + parent.depth;
          uw = u.length;
          uh = VISUAL_DEPTH;
        } else if (u.parentEdge === 'left') {
          ux = parent.x - VISUAL_DEPTH;
          uy = parent.y + edgeStart;
          uw = VISUAL_DEPTH;
          uh = u.length;
        } else {
          ux = parent.x + parent.length;
          uy = parent.y + edgeStart;
          uw = VISUAL_DEPTH;
          uh = u.length;
        }
      } else {
        // Free-standing
        ux = u.x;
        uy = u.y;
        uw = u.vertical ? VISUAL_DEPTH : u.length;
        uh = u.vertical ? u.length : VISUAL_DEPTH;
      }
    }
    } // End of else (non-cill upstands)
    
    if (mx >= ux && mx <= ux + uw && my >= uy && my <= uy + uh) {
      return { type: 'upstand', item: u };
    }
  }
  
  // Check worktops
  for (let i = worktops.length - 1; i >= 0; i--) {
    const w = worktops[i];
    if (mx >= w.x && mx <= w.x + w.length && my >= w.y && my <= w.y + w.depth) {
      return { type: 'worktop', item: w };
    }
  }
  return null;
}

// ========== SELECTION ==========
function selectItem(type, id) {
  selectedType = type;
  selectedId = id;
  renderLists();
  renderProps();
  render();
}

function clearSelection() {
  selectedType = null;
  selectedId = null;
  renderLists();
  renderProps();
  render();
}

function deleteSelected() {
  if (selectedType === 'worktop') {
    saveHistory();
    worktops = worktops.filter(w => w.id !== selectedId);
    // Remove orphan upstands
    upstands = upstands.filter(u => !u.parentId || worktops.some(w => w.id === u.parentId));
    detectAllJoints();
  } else if (selectedType === 'upstand') {
    saveHistory();
    upstands = upstands.filter(u => u.id !== selectedId);
  }
  clearSelection();
  renderLists();
  render();
  updateSummary();
}

function rotateSelected() {
  if (selectedType === 'worktop') {
    saveHistory();
    const w = worktops.find(w => w.id === selectedId);
    if (w) {
      [w.length, w.depth] = [w.depth, w.length];
      // Rotate edge types
      const oldTypes = w.edgeTypes || {};
      const newTypes = {};
      Object.entries(oldTypes).forEach(([k, v]) => {
        const [e, s, en] = k.split('_');
        const map = { back: 'right', right: 'front', front: 'left', left: 'back' };
        newTypes[`${map[e]}_${s}_${en}`] = v;
      });
      w.edgeTypes = newTypes;
      detectAllJoints();
      render();
    }
  } else if (selectedType === 'upstand') {
    saveHistory();
    const u = upstands.find(u => u.id === selectedId);
    if (u) {
      u.vertical = !u.vertical;
      render();
    }
  }
}

// ========== RENDER 2D ==========
function render() {
  if (currentView !== '2d') return;
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawGrid();
  
  // Draw upstands first (behind worktops in 2D)
  upstands.forEach(u => drawUpstand2D(u));
  
  // Draw worktops
  worktops.forEach(w => drawWorktop2D(w));
  
  // Draw cutouts (on top of worktops)
  cutouts.forEach(c => drawCutout2D(c));
  
  // Draw preview
  if (isDrawing && drawStart) drawPreview();
  
  // Snap crosshair with connection circle
  if (activeSnap) {
    const p = mmToScreen(activeSnap.x, activeSnap.y);
    
    // Draw larger connection circle
    ctx.beginPath();
    ctx.arc(p.x, p.y, 12, 0, Math.PI * 2);
    ctx.strokeStyle = '#4CAF50';
    ctx.lineWidth = 3;
    ctx.stroke();
    
    // Inner filled circle
    ctx.beginPath();
    ctx.arc(p.x, p.y, 6, 0, Math.PI * 2);
    ctx.fillStyle = '#4CAF50';
    ctx.fill();
    
    // Crosshair
    ctx.strokeStyle = '#4CAF50';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(p.x - 18, p.y); ctx.lineTo(p.x - 8, p.y);
    ctx.moveTo(p.x + 8, p.y); ctx.lineTo(p.x + 18, p.y);
    ctx.moveTo(p.x, p.y - 18); ctx.lineTo(p.x, p.y - 8);
    ctx.moveTo(p.x, p.y + 8); ctx.lineTo(p.x, p.y + 18);
    ctx.stroke();
  }
}

function drawGrid() {
  const gridPx = 100 * scale;
  if (gridPx < 8) return;
  ctx.strokeStyle = '#ddd';
  ctx.lineWidth = 1;
  for (let x = offset.x % gridPx; x < canvas.width; x += gridPx) {
    ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke();
  }
  for (let y = offset.y % gridPx; y < canvas.height; y += gridPx) {
    ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke();
  }
}

function drawCutout2D(c) {
  const sel = selectedType === 'cutout' && selectedId === c.id;
  
  if (c.type === 'tap') {
    // Tap hole - circular with crosshair
    const p = mmToScreen(c.x, c.y);
    const r = Math.max((c.diameter / 2) * scale, 8);
    
    // Find parent worktop for measurements
    const parent = worktops.find(w => w.id === c.parentId);
    
    // If selected, show measurement rulers
    if (sel && parent) {
      const wp = mmToScreen(parent.x, parent.y);
      const ww = parent.length * scale;
      const wh = parent.depth * scale;
      
      // Distance from left edge
      const distLeft = c.x - parent.x;
      // Distance from back edge  
      const distBack = c.y - parent.y;
      // Distance from right edge
      const distRight = parent.x + parent.length - c.x;
      // Distance from front edge
      const distFront = parent.y + parent.depth - c.y;
      
      ctx.save();
      ctx.setLineDash([4, 4]);
      ctx.strokeStyle = '#e91e63';
      ctx.lineWidth = 1;
      ctx.fillStyle = '#e91e63';
      ctx.font = 'bold 10px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      
      // Horizontal ruler (from left edge)
      ctx.beginPath();
      ctx.moveTo(wp.x, p.y);
      ctx.lineTo(p.x, p.y);
      ctx.stroke();
      // Dimension text
      ctx.setLineDash([]);
      ctx.fillStyle = '#fff';
      ctx.fillRect(wp.x + (p.x - wp.x)/2 - 20, p.y - 8, 40, 16);
      ctx.fillStyle = '#e91e63';
      ctx.fillText(`${Math.round(distLeft)}`, wp.x + (p.x - wp.x)/2, p.y);
      
      // Vertical ruler (from back edge)
      ctx.setLineDash([4, 4]);
      ctx.beginPath();
      ctx.moveTo(p.x, wp.y);
      ctx.lineTo(p.x, p.y);
      ctx.stroke();
      // Dimension text
      ctx.setLineDash([]);
      ctx.fillStyle = '#fff';
      ctx.fillRect(p.x - 20, wp.y + (p.y - wp.y)/2 - 8, 40, 16);
      ctx.fillStyle = '#e91e63';
      ctx.fillText(`${Math.round(distBack)}`, p.x, wp.y + (p.y - wp.y)/2);
      
      ctx.restore();
    }
    
    // Outer ring
    ctx.beginPath();
    ctx.arc(p.x, p.y, r + 4, 0, Math.PI * 2);
    ctx.fillStyle = sel ? '#1565c0' : '#2196f3';
    ctx.fill();
    
    // Inner hole
    ctx.beginPath();
    ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
    ctx.fillStyle = sel ? '#0d47a1' : '#1a1a1a';
    ctx.fill();
    
    // Centre crosshair
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(p.x - r + 2, p.y);
    ctx.lineTo(p.x + r - 2, p.y);
    ctx.moveTo(p.x, p.y - r + 2);
    ctx.lineTo(p.x, p.y + r - 2);
    ctx.stroke();
    
    // Diameter label when selected
    if (sel) {
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 9px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(`√ò${c.diameter}`, p.x, p.y + r + 12);
    }
    
  } else if (c.type === 'drainer') {
    // Drainer grooves - 5 lines perpendicular to the sink edge
    // Use c.vertical flag if set, otherwise check parent worktop
    const parent = worktops.find(wt => wt.id === c.parentId);
    const isVerticalDrainer = c.vertical === true || (parent && parent.depth > parent.length);
    
    const p = mmToScreen(c.x, c.y);
    // Use stored dimensions directly
    const w = c.width * scale;
    const h = c.length * scale;
    
    const grooveCount = c.grooveCount || 5;
    
    ctx.strokeStyle = sel ? '#455a64' : '#78909c';
    ctx.lineWidth = 3;
    ctx.lineCap = 'round';
    
    if (isVerticalDrainer) {
      // Vertical drainer: grooves run VERTICALLY (along Y axis)
      const grooveAreaStart = p.x + 15 * scale;
      const grooveAreaEnd = p.x + w - 15 * scale;
      const spacing = (grooveAreaEnd - grooveAreaStart) / (grooveCount - 1);
      
      for (let i = 0; i < grooveCount; i++) {
        const gx = grooveAreaStart + (i * spacing);
        ctx.beginPath();
        if (c.side === 'left') {
          // "Left" on vertical = top of screen
          ctx.moveTo(gx, p.y + 10);
          ctx.lineTo(gx, p.y + h);  // Extends to sink edge
        } else if (c.side === 'right') {
          // "Right" on vertical = bottom of screen
          ctx.moveTo(gx, p.y);  // Starts from sink edge
          ctx.lineTo(gx, p.y + h - 10);
        } else {
          ctx.moveTo(gx, p.y + 10);
          ctx.lineTo(gx, p.y + h - 10);
        }
        ctx.stroke();
      }
    } else {
      // Horizontal worktop: grooves run HORIZONTALLY (along X axis)
      const grooveAreaStart = p.y + 15 * scale;
      const grooveAreaEnd = p.y + h - 15 * scale;
      const spacing = (grooveAreaEnd - grooveAreaStart) / (grooveCount - 1);
      
      for (let i = 0; i < grooveCount; i++) {
        const gy = grooveAreaStart + (i * spacing);
        ctx.beginPath();
        if (c.side === 'left') {
          ctx.moveTo(p.x + 10, gy);
          ctx.lineTo(p.x + w, gy);  // Extends to sink edge
        } else if (c.side === 'right') {
          ctx.moveTo(p.x, gy);  // Starts from sink edge
          ctx.lineTo(p.x + w - 10, gy);
        } else {
          ctx.moveTo(p.x + 10, gy);
          ctx.lineTo(p.x + w - 10, gy);
        }
        ctx.stroke();
      }
    }
    
  } else if (c.type === 'recess_drainer') {
    // Recess drainer - sunken area (no outer rim that extends past sink)
    const parent = worktops.find(wt => wt.id === c.parentId);
    const isVerticalDrainer = c.vertical === true || (parent && parent.depth > parent.length);
    
    const p = mmToScreen(c.x, c.y);
    // Use stored dimensions directly
    const w = c.width * scale;
    const h = c.length * scale;
    const r = 15 * scale;
    
    // Just draw the recess directly - no extending rim
    ctx.beginPath();
    if (c.side === 'left') {
      // Left drainer - round left corners, straight right edge (connects to sink)
      ctx.moveTo(p.x + w, p.y);  // Top right (straight)
      ctx.lineTo(p.x + r, p.y);   // Top edge
      ctx.quadraticCurveTo(p.x, p.y, p.x, p.y + r);  // Top left corner
      ctx.lineTo(p.x, p.y + h - r);  // Left edge
      ctx.quadraticCurveTo(p.x, p.y + h, p.x + r, p.y + h);  // Bottom left corner
      ctx.lineTo(p.x + w, p.y + h);  // Bottom edge
      ctx.closePath();
    } else if (c.side === 'right') {
      // Right drainer - round right corners, straight left edge (connects to sink)
      ctx.moveTo(p.x, p.y);  // Top left (straight)
      ctx.lineTo(p.x + w - r, p.y);  // Top edge
      ctx.quadraticCurveTo(p.x + w, p.y, p.x + w, p.y + r);  // Top right corner
      ctx.lineTo(p.x + w, p.y + h - r);  // Right edge
      ctx.quadraticCurveTo(p.x + w, p.y + h, p.x + w - r, p.y + h);  // Bottom right corner
      ctx.lineTo(p.x, p.y + h);  // Bottom edge
      ctx.closePath();
    }
    
    // Stepped/recess effect - draw rim first
    ctx.fillStyle = sel ? '#90a4ae' : '#b0bec5';
    ctx.fill();
    ctx.strokeStyle = sel ? '#37474f' : '#607d8b';
    ctx.lineWidth = sel ? 2 : 1;
    ctx.stroke();
    
    // Inner recessed area (darker - shows it's sunken) - inset by 6mm
    const inset = 6 * scale;
    ctx.beginPath();
    if (c.side === 'left') {
      ctx.moveTo(p.x + w, p.y + inset);
      ctx.lineTo(p.x + r + inset, p.y + inset);
      ctx.quadraticCurveTo(p.x + inset, p.y + inset, p.x + inset, p.y + r + inset);
      ctx.lineTo(p.x + inset, p.y + h - r - inset);
      ctx.quadraticCurveTo(p.x + inset, p.y + h - inset, p.x + r + inset, p.y + h - inset);
      ctx.lineTo(p.x + w, p.y + h - inset);
      ctx.closePath();
    } else if (c.side === 'right') {
      ctx.moveTo(p.x, p.y + inset);
      ctx.lineTo(p.x + w - r - inset, p.y + inset);
      ctx.quadraticCurveTo(p.x + w - inset, p.y + inset, p.x + w - inset, p.y + r + inset);
      ctx.lineTo(p.x + w - inset, p.y + h - r - inset);
      ctx.quadraticCurveTo(p.x + w - inset, p.y + h - inset, p.x + w - r - inset, p.y + h - inset);
      ctx.lineTo(p.x, p.y + h - inset);
      ctx.closePath();
    }
    ctx.fillStyle = sel ? 'rgba(69, 90, 100, 0.5)' : 'rgba(69, 90, 100, 0.35)';
    ctx.fill();
    
    // Draw grooves inside recess - perpendicular to sink edge
    const grooveCount = c.grooveCount || 5;
    
    ctx.strokeStyle = sel ? '#37474f' : '#546e7a';
    ctx.lineWidth = 2;
    ctx.lineCap = 'round';
    
    if (isVerticalDrainer) {
      // Vertical drainer: grooves run VERTICALLY
      const grooveAreaStart = p.x + inset + 10;
      const grooveAreaEnd = p.x + w - inset - 10;
      const grooveSpacing = (grooveAreaEnd - grooveAreaStart) / (grooveCount - 1);
      
      for (let i = 0; i < grooveCount; i++) {
        const gx = grooveAreaStart + (i * grooveSpacing);
        ctx.beginPath();
        if (c.side === 'left') {
          ctx.moveTo(gx, p.y + inset + 8);
          ctx.lineTo(gx, p.y + h - 4);
        } else {
          ctx.moveTo(gx, p.y + 4);
          ctx.lineTo(gx, p.y + h - inset - 8);
        }
        ctx.stroke();
      }
    } else {
      // Horizontal worktop: grooves run HORIZONTALLY  
      const grooveAreaStart = p.y + inset + 10;
      const grooveAreaEnd = p.y + h - inset - 10;
      const grooveSpacing = (grooveAreaEnd - grooveAreaStart) / (grooveCount - 1);
      
      for (let i = 0; i < grooveCount; i++) {
        const gy = grooveAreaStart + (i * grooveSpacing);
        ctx.beginPath();
        if (c.side === 'left') {
          ctx.moveTo(p.x + inset + 8, gy);
          ctx.lineTo(p.x + w - 4, gy);
        } else {
          ctx.moveTo(p.x + 4, gy);
          ctx.lineTo(p.x + w - inset - 8, gy);
        }
        ctx.stroke();
      }
    }
    
    // Label
    ctx.fillStyle = sel ? '#263238' : '#455a64';
    ctx.font = 'bold 8px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('RECESS', p.x + w/2, p.y + h/2);
    
  } else if (c.type === 'undermount_sink') {
    // Undermount sink - rounded rectangle cutout
    const parent = worktops.find(wt => wt.id === c.parentId);
    const isVerticalWorktop = parent && parent.depth > parent.length;
    
    const p = mmToScreen(c.x, c.y);
    // On vertical worktops, swap width/height for drawing
    const w = (isVerticalWorktop ? c.length : c.width) * scale;
    const h = (isVerticalWorktop ? c.width : c.length) * scale;
    const r = (c.radius || 25) * scale;
    
    // Display dimensions should always show what user entered
    const displayW = c.width;
    const displayL = c.length;
    
    if (c.isButler) {
      // Butler sink - open at front, radius only on back corners
      // Inner cutout (dark hole) - open at front
      ctx.beginPath();
      ctx.moveTo(p.x, p.y + h);           // Start bottom left
      ctx.lineTo(p.x, p.y + r);           // Left side up
      ctx.quadraticCurveTo(p.x, p.y, p.x + r, p.y);  // Top left corner
      ctx.lineTo(p.x + w - r, p.y);       // Top edge
      ctx.quadraticCurveTo(p.x + w, p.y, p.x + w, p.y + r);  // Top right corner
      ctx.lineTo(p.x + w, p.y + h);       // Right side down
      ctx.closePath();
      ctx.fillStyle = sel ? '#37474f' : '#263238';
      ctx.fill();
      
      // Thin rim line on sides and back only
      ctx.strokeStyle = sel ? '#90a4ae' : '#b0bec5';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(p.x, p.y + h);
      ctx.lineTo(p.x, p.y + r);
      ctx.quadraticCurveTo(p.x, p.y, p.x + r, p.y);
      ctx.lineTo(p.x + w - r, p.y);
      ctx.quadraticCurveTo(p.x + w, p.y, p.x + w, p.y + r);
      ctx.lineTo(p.x + w, p.y + h);
      ctx.stroke();
      
      // Label
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 9px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('BUTLER', p.x + w/2, p.y + h/2 - 8);
      ctx.fillText(`${displayW}√ó${displayL}`, p.x + w/2, p.y + h/2 + 8);
    } else {
      // Standard undermount sink - draw at exact bounds (no extended rim)
      // Inner cutout (dark hole)
      ctx.beginPath();
      roundRect(ctx, p.x, p.y, w, h, r);
      ctx.fillStyle = sel ? '#37474f' : '#263238';
      ctx.fill();
      
      // Thin rim line around edge
      ctx.strokeStyle = sel ? '#90a4ae' : '#b0bec5';
      ctx.lineWidth = 3;
      ctx.stroke();
      
      // Selection highlight
      if (sel) {
        ctx.strokeStyle = '#e91e63';
        ctx.lineWidth = 2;
        ctx.stroke();
      }
      
      // Dimensions label
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 10px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(`${displayW}√ó${displayL}`, p.x + w/2, p.y + h/2);
    }
    
  } else if (c.type === 'overmount_sink') {
    // Overmount sink - rectangular cutout (similar to hob)
    const parent = worktops.find(wt => wt.id === c.parentId);
    const isVerticalWorktop = parent && parent.depth > parent.length;
    
    const p = mmToScreen(c.x, c.y);
    const w = (isVerticalWorktop ? c.length : c.width) * scale;
    const h = (isVerticalWorktop ? c.width : c.length) * scale;
    
    // Dark cutout
    ctx.fillStyle = sel ? '#5d4037' : '#3e2723';
    ctx.fillRect(p.x, p.y, w, h);
    
    // Selection border
    if (sel) {
      ctx.strokeStyle = '#e91e63';
      ctx.lineWidth = 3;
      ctx.strokeRect(p.x, p.y, w, h);
    }
    
    // Label
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 9px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('OVERMOUNT', p.x + w/2, p.y + h/2 - 6);
    ctx.fillText(`${c.width}√ó${c.length}`, p.x + w/2, p.y + h/2 + 8);
    
  } else if (c.type === 'hob' || c.type === 'recess_hob') {
    // Hob or Recess Hob - rectangular cutout with burner indicator
    const parent = worktops.find(wt => wt.id === c.parentId);
    const isVerticalWorktop = parent && parent.depth > parent.length;
    
    const p = mmToScreen(c.x, c.y);
    const w = (isVerticalWorktop ? c.length : c.width) * scale;
    const h = (isVerticalWorktop ? c.width : c.length) * scale;
    
    // Dark cutout
    ctx.fillStyle = sel ? '#424242' : '#212121';
    ctx.fillRect(p.x, p.y, w, h);
    
    // Draw 4 burner circles
    const burnerR = Math.min(w, h) * 0.12;
    const positions = [
      { x: p.x + w * 0.28, y: p.y + h * 0.35 },
      { x: p.x + w * 0.72, y: p.y + h * 0.35 },
      { x: p.x + w * 0.28, y: p.y + h * 0.65 },
      { x: p.x + w * 0.72, y: p.y + h * 0.65 }
    ];
    
    ctx.strokeStyle = c.type === 'recess_hob' ? '#e64a19' : '#ff5722';
    ctx.lineWidth = 2;
    positions.forEach(pos => {
      ctx.beginPath();
      ctx.arc(pos.x, pos.y, burnerR, 0, Math.PI * 2);
      ctx.stroke();
    });
    
    // Selection border
    if (sel) {
      ctx.strokeStyle = '#e91e63';
      ctx.lineWidth = 3;
      ctx.strokeRect(p.x, p.y, w, h);
    }
    
    // Label - always show user's entered dimensions
    ctx.fillStyle = c.type === 'recess_hob' ? '#e64a19' : '#ff5722';
    ctx.font = 'bold 9px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(c.type === 'recess_hob' ? 'RECESS HOB' : 'HOB', p.x + w/2, p.y + h/2);
  } else if (c.type === 'socket') {
    // Socket cutout on splashback - find parent splashback
    const parent = upstands.find(u => u.id === c.parentId);
    if (!parent) return;
    
    const pw = worktops.find(w => w.id === parent.parentId);
    const edge = parent.parentEdge || 'back';
    const edgeStart = parent.edgeStart || 0;
    const splashHeight = parent.height;
    const isVertical = (edge === 'left' || edge === 'right');
    
    // Calculate splashback rectangle in mm coordinates
    // For continuous splashbacks, use absoluteX/Y; otherwise use parent worktop position
    let ux, uy, uw, uh;
    
    if (parent.isContinuous && parent.absoluteX !== undefined) {
      // Continuous splashback - use absolute position
      if (edge === 'back') {
        ux = parent.absoluteX;
        uy = parent.absoluteY - splashHeight;
        uw = parent.length;
        uh = splashHeight;
      } else if (edge === 'front') {
        ux = parent.absoluteX;
        uy = parent.absoluteY;
        uw = parent.length;
        uh = splashHeight;
      } else if (edge === 'left') {
        ux = parent.absoluteX - splashHeight;
        uy = parent.absoluteY;
        uw = splashHeight;
        uh = parent.length;
      } else { // right
        ux = parent.absoluteX;
        uy = parent.absoluteY;
        uw = splashHeight;
        uh = parent.length;
      }
    } else if (pw) {
      // Non-continuous splashback - use parent worktop position
      if (edge === 'back') {
        ux = pw.x + edgeStart;
        uy = pw.y - splashHeight;
        uw = parent.length;
        uh = splashHeight;
      } else if (edge === 'front') {
        ux = pw.x + edgeStart;
        uy = pw.y + pw.depth;
        uw = parent.length;
        uh = splashHeight;
      } else if (edge === 'left') {
        ux = pw.x - splashHeight;
        uy = pw.y + edgeStart;
        uw = splashHeight;
        uh = parent.length;
      } else { // right
        ux = pw.x + pw.length;
        uy = pw.y + edgeStart;
        uw = splashHeight;
        uh = parent.length;
      }
    } else {
      // Fallback for splashbacks without parent
      ux = parent.absoluteX || parent.x || 0;
      uy = (parent.absoluteY || parent.y || 0) - splashHeight;
      uw = parent.length;
      uh = splashHeight;
    }
    
    // Convert to screen coordinates
    const sp = mmToScreen(ux, uy);
    const splashW = uw * scale;
    const splashH = uh * scale;
    
    // Socket position in mm relative to splashback
    // centerX = distance along the LENGTH of splashback (from the START of the splashback)
    // centerY = distance from the worktop surface (height up from bottom)
    let socketMmX, socketMmY, socketMmW, socketMmH;
    
    if (isVertical) {
      // For left/right edges: splashback length runs vertically in 2D
      socketMmW = c.height;  // Socket rotated
      socketMmH = c.width;
      
      if (edge === 'left') {
        socketMmX = ux + (splashHeight - c.centerY - c.height/2);
        socketMmY = uy + (c.centerX - c.width/2);
      } else {
        socketMmX = ux + (c.centerY - c.height/2);
        socketMmY = uy + (c.centerX - c.width/2);
      }
    } else {
      // For back/front edges: splashback length runs horizontally in 2D
      socketMmW = c.width;
      socketMmH = c.height;
      socketMmX = ux + (c.centerX - c.width/2);
      
      if (edge === 'back') {
        socketMmY = uy + (splashHeight - c.centerY - c.height/2);
      } else {
        socketMmY = uy + (c.centerY - c.height/2);
      }
    }
    
    // Debug: log socket rendering calculations (disable in production)
    // console.log('Socket 2D render:', c.id, 'parent:', parent.id, 
    //   'isContinuous:', parent.isContinuous, 
    //   'absoluteX:', parent.absoluteX, 
    //   'ux:', ux, 'uy:', uy,
    //   'centerX:', c.centerX, 'centerY:', c.centerY,
    //   'socketMmX:', socketMmX, 'socketMmY:', socketMmY);
    
    // Convert socket position to screen
    const socketScreen = mmToScreen(socketMmX, socketMmY);
    const socketX = socketScreen.x;
    const socketY = socketScreen.y;
    const socketW = socketMmW * scale;
    const socketH = socketMmH * scale;
    
    // Store screen position for hit testing
    c._screenX = socketX;
    c._screenY = socketY;
    c._screenW = socketW;
    c._screenH = socketH;
    c._parentSp = sp;
    c._splashW = splashW;
    c._splashH = splashH;
    c._isVertical = isVertical;
    
    // If selected, show measurement rulers
    if (sel) {
      ctx.save();
      ctx.setLineDash([4, 4]);
      ctx.strokeStyle = '#e91e63';
      ctx.lineWidth = 1;
      ctx.fillStyle = '#e91e63';
      ctx.font = 'bold 10px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      
      if (isVertical) {
        // VERTICAL splashback (left/right edge)
        // centerX runs along the LENGTH (vertical on screen)
        // centerY is horizontal distance from worktop edge
        
        // Distance from top of splashback (screen) to top of socket
        const distFromTop = Math.round(c.centerX - c.width/2);
        
        // Vertical ruler - from top of splashback to top of socket
        ctx.beginPath();
        ctx.moveTo(socketX + socketW/2, sp.y);
        ctx.lineTo(socketX + socketW/2, socketY);
        ctx.stroke();
        // Dimension text
        ctx.setLineDash([]);
        ctx.fillStyle = '#fff';
        ctx.fillRect(socketX + socketW/2 - 22, sp.y + (socketY - sp.y)/2 - 9, 44, 18);
        ctx.fillStyle = '#e91e63';
        ctx.fillText(`${distFromTop}`, socketX + socketW/2, sp.y + (socketY - sp.y)/2);
        
        // Horizontal ruler - from worktop edge to socket
        // For left edge: worktop is on RIGHT, so measure from right side of splashback
        // For right edge: worktop is on LEFT, so measure from left side of splashback
        const distFromWorktop = Math.round(c.centerY - c.height/2);
        ctx.setLineDash([4, 4]);
        ctx.beginPath();
        if (edge === 'left') {
          // Measure from right edge of splashback (worktop side)
          ctx.moveTo(sp.x + splashW, socketY + socketH/2);
          ctx.lineTo(socketX + socketW, socketY + socketH/2);
        } else {
          // Measure from left edge of splashback (worktop side)
          ctx.moveTo(sp.x, socketY + socketH/2);
          ctx.lineTo(socketX, socketY + socketH/2);
        }
        ctx.stroke();
        // Dimension text
        ctx.setLineDash([]);
        const hRulerMid = edge === 'left' 
          ? socketX + socketW + (sp.x + splashW - socketX - socketW)/2
          : sp.x + (socketX - sp.x)/2;
        ctx.fillStyle = '#fff';
        ctx.fillRect(hRulerMid - 22, socketY + socketH/2 - 9, 44, 18);
        ctx.fillStyle = '#e91e63';
        ctx.fillText(`${distFromWorktop}`, hRulerMid, socketY + socketH/2);
        
      } else {
        // HORIZONTAL splashback (back/front edge)
        // centerX is from left edge of splashback
        // centerY is from bottom (worktop surface)
        
        // Distance from left edge of splashback to left edge of socket
        const distFromLeft = Math.round(c.centerX - c.width/2);
        
        // Horizontal ruler (from left edge of splashback)
        ctx.beginPath();
        ctx.moveTo(sp.x, socketY + socketH/2);
        ctx.lineTo(socketX, socketY + socketH/2);
        ctx.stroke();
        // Dimension text
        ctx.setLineDash([]);
        ctx.fillStyle = '#fff';
        ctx.fillRect(sp.x + (socketX - sp.x)/2 - 22, socketY + socketH/2 - 9, 44, 18);
        ctx.fillStyle = '#e91e63';
        ctx.fillText(`${distFromLeft}`, sp.x + (socketX - sp.x)/2, socketY + socketH/2);
        
        // Vertical ruler (from worktop surface / bottom of splashback)
        // For back edge: bottom of splashback is at sp.y + splashH
        // For front edge: bottom is at sp.y
        const distFromWorktop = Math.round(c.centerY - c.height/2);
        ctx.setLineDash([4, 4]);
        ctx.beginPath();
        if (edge === 'back') {
          // Worktop is below, measure from bottom of splashback
          ctx.moveTo(socketX + socketW/2, sp.y + splashH);
          ctx.lineTo(socketX + socketW/2, socketY + socketH);
        } else {
          // Front edge - worktop is above, measure from top of splashback
          ctx.moveTo(socketX + socketW/2, sp.y);
          ctx.lineTo(socketX + socketW/2, socketY);
        }
        ctx.stroke();
        // Dimension text
        ctx.setLineDash([]);
        const vRulerMid = edge === 'back'
          ? socketY + socketH + (sp.y + splashH - socketY - socketH)/2
          : sp.y + (socketY - sp.y)/2;
        ctx.fillStyle = '#fff';
        ctx.fillRect(socketX + socketW/2 - 22, vRulerMid - 9, 44, 18);
        ctx.fillStyle = '#e91e63';
        ctx.fillText(`${distFromWorktop}`, socketX + socketW/2, vRulerMid);
      }
      
      ctx.restore();
    }
    
    // Draw socket cutout
    ctx.fillStyle = sel ? '#bf360c' : '#ff7043';
    ctx.fillRect(socketX, socketY, socketW, socketH);
    ctx.strokeStyle = sel ? '#e64a19' : '#d84315';
    ctx.lineWidth = sel ? 2 : 1;
    ctx.strokeRect(socketX, socketY, socketW, socketH);
    
    // Inner rectangle for socket appearance
    const inset = 4;
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 1;
    ctx.strokeRect(socketX + inset, socketY + inset, socketW - inset*2, socketH - inset*2);
    
    // Label
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 9px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    if (socketW > 40 && socketH > 25) {
      ctx.fillText(`${c.width}√ó${c.height}`, socketX + socketW/2, socketY + socketH/2);
    }
  }
}

// Helper function for rounded rectangles
function roundRect(ctx, x, y, w, h, r) {
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r);
  ctx.lineTo(x + w, y + h - r);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  ctx.lineTo(x + r, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r);
  ctx.lineTo(x, y + r);
  ctx.quadraticCurveTo(x, y, x + r, y);
}

function drawWorktop2D(w) {
  const p = mmToScreen(w.x, w.y);
  const width = w.length * scale;
  const height = w.depth * scale;
  const sel = selectedType === 'worktop' && selectedId === w.id;
  
  // Get corner radii (scaled to screen)
  const radii = w.cornerRadii || { tl: 0, tr: 0, br: 0, bl: 0 };
  const rTL = (radii.tl || 0) * scale;  // Top-left (back-left)
  const rTR = (radii.tr || 0) * scale;  // Top-right (back-right)
  const rBR = (radii.br || 0) * scale;  // Bottom-right (front-right)
  const rBL = (radii.bl || 0) * scale;  // Bottom-left (front-left)
  
  // Check for stepout
  const stepout = w.stepout;
  const isVertical = w.depth > w.length; // Vertical if taller than wide
  
  // Draw worktop fill
  ctx.fillStyle = sel ? '#c8e6c9' : '#f5f5f5';
  ctx.beginPath();
  
  if (stepout) {
    // Draw L-shape for stepout
    const stepLen = stepout.length * scale;
    const stepDepth = stepout.depth * scale;
    drawLShapePath(ctx, p.x, p.y, width, height, stepLen, stepDepth, stepout.corner, isVertical);
  } else {
    drawRoundedRectPath(ctx, p.x, p.y, width, height, rTL, rTR, rBR, rBL);
  }
  ctx.fill();
  
  // Draw edges with radius awareness
  const screenRadii = {
    tl: rTL,
    tr: rTR,
    br: rBR,
    bl: rBL
  };
  
  // Adjust edge segments based on stepout
  // When stepout exists, some edges are shortened or repositioned
  ['back', 'front', 'left', 'right'].forEach(edge => {
    let free = getFreeSegments(w, edge);
    const joints = w.joints[edge] || [];
    let len = (edge === 'back' || edge === 'front') ? w.length : w.depth;
    
    // Modify segments based on stepout
    if (stepout) {
      if (isVertical) {
        // VERTICAL WORKTOP - stepout extends LEFT/RIGHT, affects left/right edges
        if (stepout.corner === 'front-left') {
          if (edge === 'left') {
            // Left edge ends before stepout (at depth - stepLen)
            free = free.map(seg => ({
              start: seg.start,
              end: Math.min(seg.end, w.depth - stepout.length)
            })).filter(seg => seg.end > seg.start);
          }
        } else if (stepout.corner === 'front-right') {
          if (edge === 'right') {
            // Right edge ends before stepout
            free = free.map(seg => ({
              start: seg.start,
              end: Math.min(seg.end, w.depth - stepout.length)
            })).filter(seg => seg.end > seg.start);
          }
        } else if (stepout.corner === 'back-left') {
          if (edge === 'left') {
            // Left edge starts after stepout
            free = free.map(seg => ({
              start: Math.max(seg.start, stepout.length),
              end: seg.end
            })).filter(seg => seg.end > seg.start);
          }
        } else if (stepout.corner === 'back-right') {
          if (edge === 'right') {
            // Right edge starts after stepout
            free = free.map(seg => ({
              start: Math.max(seg.start, stepout.length),
              end: seg.end
            })).filter(seg => seg.end > seg.start);
          }
        }
      } else {
        // HORIZONTAL WORKTOP - stepout extends DOWN/UP, affects front/back edges
        if (stepout.corner === 'front-left') {
          if (edge === 'front') {
            // Front edge starts after stepout (stepLen from left)
            free = free.map(seg => ({
              start: Math.max(seg.start, stepout.length),
              end: seg.end
            })).filter(seg => seg.end > seg.start);
          }
        } else if (stepout.corner === 'front-right') {
          if (edge === 'front') {
            // Front edge ends before stepout
            free = free.map(seg => ({
              start: seg.start,
              end: Math.min(seg.end, w.length - stepout.length)
            })).filter(seg => seg.end > seg.start);
          }
        } else if (stepout.corner === 'back-left') {
          if (edge === 'back') {
            // Back edge starts after stepout
            free = free.map(seg => ({
              start: Math.max(seg.start, stepout.length),
              end: seg.end
            })).filter(seg => seg.end > seg.start);
          }
        } else if (stepout.corner === 'back-right') {
          if (edge === 'back') {
            // Back edge ends before stepout
            free = free.map(seg => ({
              start: seg.start,
              end: Math.min(seg.end, w.length - stepout.length)
            })).filter(seg => seg.end > seg.start);
          }
        }
      }
    }
    
    // Joined (gray)
    ctx.strokeStyle = '#999';
    ctx.lineWidth = 4;
    joints.forEach(j => {
      let jStart = j.start, jEnd = j.end;
      // Adjust joint segments for stepout too
      if (stepout) {
        if (isVertical) {
          if ((stepout.corner === 'front-left' && edge === 'left') ||
              (stepout.corner === 'front-right' && edge === 'right')) {
            jEnd = Math.min(jEnd, w.depth - stepout.length);
          } else if ((stepout.corner === 'back-left' && edge === 'left') ||
                     (stepout.corner === 'back-right' && edge === 'right')) {
            jStart = Math.max(jStart, stepout.length);
          }
        } else {
          if ((stepout.corner === 'front-left' && edge === 'front') ||
              (stepout.corner === 'back-left' && edge === 'back')) {
            jStart = Math.max(jStart, stepout.length);
          } else if ((stepout.corner === 'front-right' && edge === 'front') ||
                     (stepout.corner === 'back-right' && edge === 'back')) {
            jEnd = Math.min(jEnd, w.length - stepout.length);
          }
        }
      }
      if (jEnd > jStart) {
        drawEdgeSeg(edge, p, width, height, jStart / len, jEnd / len);
      }
    });
    
    // Free segments - use radius-aware drawing
    free.forEach(seg => {
      // First try exact match
      let key = `${edge}_${seg.start}_${seg.end}`;
      let t = w.edgeTypes?.[key];
      
      // If no exact match, find any edge profile that covers this segment
      if (!t && w.edgeTypes) {
        Object.entries(w.edgeTypes).forEach(([k, v]) => {
          const parts = k.split('_');
          if (parts[0] === edge) {
            const pStart = parseInt(parts[1]);
            const pEnd = parseInt(parts[2]);
            // Check if profile covers most of this segment (80% overlap)
            const overlapStart = Math.max(seg.start, pStart);
            const overlapEnd = Math.min(seg.end, pEnd);
            const overlapLen = Math.max(0, overlapEnd - overlapStart);
            const segLen = seg.end - seg.start;
            if (overlapLen >= segLen * 0.8 || (pStart <= seg.start + 5 && pEnd >= seg.end - 5)) {
              t = v;
            }
          }
        });
      }
      
      if (t?.type === 'profile') {
        // Use profile-specific color
        const profileKey = t.profileKey || 'chamfer';
        const profile = EDGE_PROFILES[profileKey];
        ctx.strokeStyle = profile?.color || '#ff5722'; 
        ctx.lineWidth = 5; 
        ctx.setLineDash([8, 4]);
      } else if (t?.type === 'dropdown') {
        ctx.strokeStyle = '#9c27b0'; ctx.lineWidth = 6; ctx.setLineDash([]);
      } else if (t?.type === 'mitred_edge') {
        ctx.strokeStyle = '#795548'; ctx.lineWidth = 5; ctx.setLineDash([]);
      } else {
        ctx.strokeStyle = '#4CAF50'; ctx.lineWidth = 4; ctx.setLineDash([]);
      }
      drawEdgeSegWithRadius(edge, p, width, height, seg.start / len, seg.end / len, screenRadii);
      ctx.setLineDash([]);
    });
  });
  
  // Draw stepout edges if present (check for profiles)
  if (stepout) {
    const stepLen = stepout.length * scale;
    const stepDepth = stepout.depth * scale;
    const s = stepout;
    
    // Helper function to get edge style based on profile
    function getStepoutEdgeStyle(edgeName) {
      if (w.edgeTypes) {
        // Look for any profile on this stepout edge (search all keys that start with this edge name)
        for (const [key, edgeType] of Object.entries(w.edgeTypes)) {
          if (key.startsWith(edgeName + '_')) {
            if (edgeType?.type === 'profile') {
              const profileKey = edgeType.profileKey || 'chamfer';
              const profile = EDGE_PROFILES[profileKey];
              return { color: profile?.color || '#ff5722', lineWidth: 5, dash: [8, 4] };
            } else if (edgeType?.type === 'mitred_edge') {
              return { color: '#795548', lineWidth: 5, dash: [] };
            } else if (edgeType?.type === 'dropdown') {
              return { color: '#9c27b0', lineWidth: 6, dash: [] };
            }
          }
        }
      }
      return { color: '#4CAF50', lineWidth: 4, dash: [] }; // Default free edge
    }
    
    // Draw each stepout edge separately with its style
    if (isVertical) {
      // VERTICAL WORKTOP - stepout extends LEFT/RIGHT
      if (stepout.corner === 'front-left') {
        // Outer edge (vertical)
        let style = getStepoutEdgeStyle('stepout_outer');
        ctx.strokeStyle = style.color; ctx.lineWidth = style.lineWidth; ctx.setLineDash(style.dash);
        ctx.beginPath();
        ctx.moveTo(p.x - stepDepth, p.y + height - stepLen);
        ctx.lineTo(p.x - stepDepth, p.y + height);
        ctx.stroke();
        
        // Bottom edge
        style = getStepoutEdgeStyle('stepout_bottom');
        ctx.strokeStyle = style.color; ctx.lineWidth = style.lineWidth; ctx.setLineDash(style.dash);
        ctx.beginPath();
        ctx.moveTo(p.x - stepDepth, p.y + height);
        ctx.lineTo(p.x, p.y + height);
        ctx.stroke();
        
        // Inner edge
        style = getStepoutEdgeStyle('stepout_inner');
        ctx.strokeStyle = style.color; ctx.lineWidth = style.lineWidth; ctx.setLineDash(style.dash);
        ctx.beginPath();
        ctx.moveTo(p.x - stepDepth, p.y + height - stepLen);
        ctx.lineTo(p.x, p.y + height - stepLen);
        ctx.stroke();
        
      } else if (stepout.corner === 'front-right') {
        let style = getStepoutEdgeStyle('stepout_outer');
        ctx.strokeStyle = style.color; ctx.lineWidth = style.lineWidth; ctx.setLineDash(style.dash);
        ctx.beginPath();
        ctx.moveTo(p.x + width + stepDepth, p.y + height - stepLen);
        ctx.lineTo(p.x + width + stepDepth, p.y + height);
        ctx.stroke();
        
        style = getStepoutEdgeStyle('stepout_bottom');
        ctx.strokeStyle = style.color; ctx.lineWidth = style.lineWidth; ctx.setLineDash(style.dash);
        ctx.beginPath();
        ctx.moveTo(p.x + width, p.y + height);
        ctx.lineTo(p.x + width + stepDepth, p.y + height);
        ctx.stroke();
        
        style = getStepoutEdgeStyle('stepout_inner');
        ctx.strokeStyle = style.color; ctx.lineWidth = style.lineWidth; ctx.setLineDash(style.dash);
        ctx.beginPath();
        ctx.moveTo(p.x + width, p.y + height - stepLen);
        ctx.lineTo(p.x + width + stepDepth, p.y + height - stepLen);
        ctx.stroke();
        
      } else if (stepout.corner === 'back-left') {
        let style = getStepoutEdgeStyle('stepout_outer');
        ctx.strokeStyle = style.color; ctx.lineWidth = style.lineWidth; ctx.setLineDash(style.dash);
        ctx.beginPath();
        ctx.moveTo(p.x - stepDepth, p.y);
        ctx.lineTo(p.x - stepDepth, p.y + stepLen);
        ctx.stroke();
        
        style = getStepoutEdgeStyle('stepout_top');
        ctx.strokeStyle = style.color; ctx.lineWidth = style.lineWidth; ctx.setLineDash(style.dash);
        ctx.beginPath();
        ctx.moveTo(p.x - stepDepth, p.y);
        ctx.lineTo(p.x, p.y);
        ctx.stroke();
        
        style = getStepoutEdgeStyle('stepout_inner');
        ctx.strokeStyle = style.color; ctx.lineWidth = style.lineWidth; ctx.setLineDash(style.dash);
        ctx.beginPath();
        ctx.moveTo(p.x - stepDepth, p.y + stepLen);
        ctx.lineTo(p.x, p.y + stepLen);
        ctx.stroke();
        
      } else if (stepout.corner === 'back-right') {
        let style = getStepoutEdgeStyle('stepout_outer');
        ctx.strokeStyle = style.color; ctx.lineWidth = style.lineWidth; ctx.setLineDash(style.dash);
        ctx.beginPath();
        ctx.moveTo(p.x + width + stepDepth, p.y);
        ctx.lineTo(p.x + width + stepDepth, p.y + stepLen);
        ctx.stroke();
        
        style = getStepoutEdgeStyle('stepout_top');
        ctx.strokeStyle = style.color; ctx.lineWidth = style.lineWidth; ctx.setLineDash(style.dash);
        ctx.beginPath();
        ctx.moveTo(p.x + width, p.y);
        ctx.lineTo(p.x + width + stepDepth, p.y);
        ctx.stroke();
        
        style = getStepoutEdgeStyle('stepout_inner');
        ctx.strokeStyle = style.color; ctx.lineWidth = style.lineWidth; ctx.setLineDash(style.dash);
        ctx.beginPath();
        ctx.moveTo(p.x + width, p.y + stepLen);
        ctx.lineTo(p.x + width + stepDepth, p.y + stepLen);
        ctx.stroke();
      }
    } else {
      // HORIZONTAL WORKTOP - stepout extends DOWN/UP
      if (stepout.corner === 'front-left') {
        let style = getStepoutEdgeStyle('stepout_left');
        ctx.strokeStyle = style.color; ctx.lineWidth = style.lineWidth; ctx.setLineDash(style.dash);
        ctx.beginPath();
        ctx.moveTo(p.x, p.y + height);
        ctx.lineTo(p.x, p.y + height + stepDepth);
        ctx.stroke();
        
        style = getStepoutEdgeStyle('stepout_bottom');
        ctx.strokeStyle = style.color; ctx.lineWidth = style.lineWidth; ctx.setLineDash(style.dash);
        ctx.beginPath();
        ctx.moveTo(p.x, p.y + height + stepDepth);
        ctx.lineTo(p.x + stepLen, p.y + height + stepDepth);
        ctx.stroke();
        
        style = getStepoutEdgeStyle('stepout_right');
        ctx.strokeStyle = style.color; ctx.lineWidth = style.lineWidth; ctx.setLineDash(style.dash);
        ctx.beginPath();
        ctx.moveTo(p.x + stepLen, p.y + height);
        ctx.lineTo(p.x + stepLen, p.y + height + stepDepth);
        ctx.stroke();
        
      } else if (stepout.corner === 'front-right') {
        let style = getStepoutEdgeStyle('stepout_right');
        ctx.strokeStyle = style.color; ctx.lineWidth = style.lineWidth; ctx.setLineDash(style.dash);
        ctx.beginPath();
        ctx.moveTo(p.x + width, p.y + height);
        ctx.lineTo(p.x + width, p.y + height + stepDepth);
        ctx.stroke();
        
        style = getStepoutEdgeStyle('stepout_bottom');
        ctx.strokeStyle = style.color; ctx.lineWidth = style.lineWidth; ctx.setLineDash(style.dash);
        ctx.beginPath();
        ctx.moveTo(p.x + width - stepLen, p.y + height + stepDepth);
        ctx.lineTo(p.x + width, p.y + height + stepDepth);
        ctx.stroke();
        
        style = getStepoutEdgeStyle('stepout_left');
        ctx.strokeStyle = style.color; ctx.lineWidth = style.lineWidth; ctx.setLineDash(style.dash);
        ctx.beginPath();
        ctx.moveTo(p.x + width - stepLen, p.y + height);
        ctx.lineTo(p.x + width - stepLen, p.y + height + stepDepth);
        ctx.stroke();
        
      } else if (stepout.corner === 'back-left') {
        let style = getStepoutEdgeStyle('stepout_left');
        ctx.strokeStyle = style.color; ctx.lineWidth = style.lineWidth; ctx.setLineDash(style.dash);
        ctx.beginPath();
        ctx.moveTo(p.x, p.y - stepDepth);
        ctx.lineTo(p.x, p.y);
        ctx.stroke();
        
        style = getStepoutEdgeStyle('stepout_top');
        ctx.strokeStyle = style.color; ctx.lineWidth = style.lineWidth; ctx.setLineDash(style.dash);
        ctx.beginPath();
        ctx.moveTo(p.x, p.y - stepDepth);
        ctx.lineTo(p.x + stepLen, p.y - stepDepth);
        ctx.stroke();
        
        style = getStepoutEdgeStyle('stepout_right');
        ctx.strokeStyle = style.color; ctx.lineWidth = style.lineWidth; ctx.setLineDash(style.dash);
        ctx.beginPath();
        ctx.moveTo(p.x + stepLen, p.y - stepDepth);
        ctx.lineTo(p.x + stepLen, p.y);
        ctx.stroke();
        
      } else if (stepout.corner === 'back-right') {
        let style = getStepoutEdgeStyle('stepout_right');
        ctx.strokeStyle = style.color; ctx.lineWidth = style.lineWidth; ctx.setLineDash(style.dash);
        ctx.beginPath();
        ctx.moveTo(p.x + width, p.y - stepDepth);
        ctx.lineTo(p.x + width, p.y);
        ctx.stroke();
        
        style = getStepoutEdgeStyle('stepout_top');
        ctx.strokeStyle = style.color; ctx.lineWidth = style.lineWidth; ctx.setLineDash(style.dash);
        ctx.beginPath();
        ctx.moveTo(p.x + width - stepLen, p.y - stepDepth);
        ctx.lineTo(p.x + width, p.y - stepDepth);
        ctx.stroke();
        
        style = getStepoutEdgeStyle('stepout_left');
        ctx.strokeStyle = style.color; ctx.lineWidth = style.lineWidth; ctx.setLineDash(style.dash);
        ctx.beginPath();
        ctx.moveTo(p.x + width - stepLen, p.y - stepDepth);
        ctx.lineTo(p.x + width - stepLen, p.y);
        ctx.stroke();
      }
    }
    ctx.setLineDash([]);
  }
  
  // Draw outline
  ctx.strokeStyle = sel ? '#1e4d3a' : '#999';
  ctx.lineWidth = sel ? 2 : 1;
  ctx.beginPath();
  if (stepout) {
    const stepLen = stepout.length * scale;
    const stepDepth = stepout.depth * scale;
    drawLShapePath(ctx, p.x, p.y, width, height, stepLen, stepDepth, stepout.corner, isVertical);
  } else {
    drawRoundedRectPath(ctx, p.x, p.y, width, height, rTL, rTR, rBR, rBL);
  }
  ctx.stroke();
  
  // Draw corner radius indicators when selected
  if (sel && !stepout) {
    ctx.fillStyle = '#1e4d3a';
    ctx.font = '9px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    
    if (radii.tl > 0) {
      ctx.fillText(`R${radii.tl}`, p.x + rTL/2 + 10, p.y + rTL/2 + 10);
    }
    if (radii.tr > 0) {
      ctx.fillText(`R${radii.tr}`, p.x + width - rTR/2 - 10, p.y + rTR/2 + 10);
    }
    if (radii.br > 0) {
      ctx.fillText(`R${radii.br}`, p.x + width - rBR/2 - 10, p.y + height - rBR/2 - 10);
    }
    if (radii.bl > 0) {
      ctx.fillText(`R${radii.bl}`, p.x + rBL/2 + 10, p.y + height - rBL/2 - 10);
    }
  }
  
  // Draw split lines (joins)
  if (w.splits && w.splits.length > 0) {
    ctx.strokeStyle = '#ff9800';
    ctx.lineWidth = 2;
    ctx.setLineDash([6, 3]);
    
    w.splits.forEach(split => {
      ctx.beginPath();
      if (split.direction === 'vertical') {
        // Vertical line across the depth at position along length
        const splitX = p.x + split.position * scale;
        ctx.moveTo(splitX, p.y);
        ctx.lineTo(splitX, p.y + height);
      } else {
        // Horizontal line across the length at position along depth
        const splitY = p.y + split.position * scale;
        ctx.moveTo(p.x, splitY);
        ctx.lineTo(p.x + width, splitY);
      }
      ctx.stroke();
      
      // Draw "JOIN" label
      ctx.setLineDash([]);
      ctx.fillStyle = '#ff9800';
      ctx.font = 'bold 8px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      
      if (split.direction === 'vertical') {
        const splitX = p.x + split.position * scale;
        ctx.save();
        ctx.translate(splitX, p.y + height/2);
        ctx.rotate(-Math.PI/2);
        ctx.fillText('JOIN', 0, -8);
        ctx.restore();
      } else {
        const splitY = p.y + split.position * scale;
        ctx.fillText('JOIN', p.x + width/2, splitY - 8);
      }
    });
    ctx.setLineDash([]);
  }
  
  ctx.fillStyle = '#333';
  ctx.font = 'bold 11px sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(w.name || 'Worktop', p.x + width/2, p.y + height/2 - 14);
  ctx.font = '10px sans-serif';
  ctx.fillText(`${w.length} √ó ${w.depth}`, p.x + width/2, p.y + height/2);
  if (stepout) {
    ctx.fillStyle = '#9c27b0';
    ctx.font = '9px sans-serif';
    ctx.fillText(`+ ${stepout.length} √ó ${stepout.depth} stepout`, p.x + width/2, p.y + height/2 + 14);
  }
}

// Draw L-shape path for stepout worktops
function drawLShapePath(ctx, x, y, w, h, stepLen, stepDepth, corner, isVertical) {
  ctx.beginPath();
  
  // For vertical worktops (depth > length), stepout extends LEFT/RIGHT
  // For horizontal worktops, stepout extends DOWN/UP
  
  if (isVertical) {
    // VERTICAL WORKTOP - stepout extends sideways
    if (corner === 'front-left') {
      // Stepout extends LEFT from bottom-left corner
      ctx.moveTo(x, y);                     // Top-left
      ctx.lineTo(x + w, y);                 // Top-right
      ctx.lineTo(x + w, y + h);             // Bottom-right
      ctx.lineTo(x, y + h);                 // Bottom-left of main
      ctx.lineTo(x - stepDepth, y + h);     // Left to stepout outer
      ctx.lineTo(x - stepDepth, y + h - stepLen); // Up along stepout left
      ctx.lineTo(x, y + h - stepLen);       // Right to where stepout meets main
      ctx.closePath();
    } else if (corner === 'front-right') {
      // Stepout extends RIGHT from bottom-right corner
      ctx.moveTo(x, y);                     // Top-left
      ctx.lineTo(x + w, y);                 // Top-right
      ctx.lineTo(x + w, y + h - stepLen);   // Down right side to stepout
      ctx.lineTo(x + w + stepDepth, y + h - stepLen); // Right to stepout outer
      ctx.lineTo(x + w + stepDepth, y + h); // Down along stepout right
      ctx.lineTo(x, y + h);                 // Left to bottom-left
      ctx.closePath();
    } else if (corner === 'back-left') {
      // Stepout extends LEFT from top-left corner
      ctx.moveTo(x - stepDepth, y);         // Top-left of stepout
      ctx.lineTo(x - stepDepth, y + stepLen); // Down along stepout left
      ctx.lineTo(x, y + stepLen);           // Right to where stepout meets main
      ctx.lineTo(x, y + h);                 // Down to bottom-left
      ctx.lineTo(x + w, y + h);             // Right to bottom-right
      ctx.lineTo(x + w, y);                 // Up to top-right
      ctx.closePath();
    } else if (corner === 'back-right') {
      // Stepout extends RIGHT from top-right corner
      ctx.moveTo(x, y);                     // Top-left
      ctx.lineTo(x + w, y);                 // Top-right of main
      ctx.lineTo(x + w + stepDepth, y);     // Right to stepout outer
      ctx.lineTo(x + w + stepDepth, y + stepLen); // Down along stepout right
      ctx.lineTo(x + w, y + stepLen);       // Left to where stepout meets main
      ctx.lineTo(x + w, y + h);             // Down to bottom-right
      ctx.lineTo(x, y + h);                 // Left to bottom-left
      ctx.closePath();
    }
  } else {
    // HORIZONTAL WORKTOP - stepout extends down/up
    if (corner === 'front-left') {
      // Stepout extends DOWN from front edge at the LEFT end
      ctx.moveTo(x, y);                     // Top-left
      ctx.lineTo(x + w, y);                 // Top-right
      ctx.lineTo(x + w, y + h);             // Bottom-right
      ctx.lineTo(x + stepLen, y + h);       // Along front to where stepout starts
      ctx.lineTo(x + stepLen, y + h + stepDepth); // Down the stepout right edge
      ctx.lineTo(x, y + h + stepDepth);     // Along stepout bottom
      ctx.closePath();
    } else if (corner === 'front-right') {
      // Stepout extends DOWN from front edge at the RIGHT end
      ctx.moveTo(x, y);                     // Top-left
      ctx.lineTo(x + w, y);                 // Top-right
      ctx.lineTo(x + w, y + h + stepDepth); // Down right side including stepout
      ctx.lineTo(x + w - stepLen, y + h + stepDepth); // Along stepout bottom
      ctx.lineTo(x + w - stepLen, y + h);   // Up stepout left edge
      ctx.lineTo(x, y + h);                 // Along front to left
      ctx.closePath();
    } else if (corner === 'back-left') {
      // Stepout extends UP from back edge at the LEFT end
      ctx.moveTo(x, y - stepDepth);         // Top of stepout
      ctx.lineTo(x + stepLen, y - stepDepth); // Along stepout top
      ctx.lineTo(x + stepLen, y);           // Down stepout right edge
      ctx.lineTo(x + w, y);                 // Along back to right
      ctx.lineTo(x + w, y + h);             // Down right side
      ctx.lineTo(x, y + h);                 // Along front to left
      ctx.closePath();
    } else if (corner === 'back-right') {
      // Stepout extends UP from back edge at the RIGHT end
      ctx.moveTo(x, y);                     // Top-left of main
      ctx.lineTo(x + w - stepLen, y);       // Along back to stepout
      ctx.lineTo(x + w - stepLen, y - stepDepth); // Up stepout left edge
      ctx.lineTo(x + w, y - stepDepth);     // Along stepout top
      ctx.lineTo(x + w, y + h);             // Down right side
      ctx.lineTo(x, y + h);                 // Along front
      ctx.closePath();
    }
  }
}

// Draw a rectangle path with individual corner radii
function drawRoundedRectPath(ctx, x, y, w, h, rTL, rTR, rBR, rBL) {
  ctx.moveTo(x + rTL, y);
  ctx.lineTo(x + w - rTR, y);
  if (rTR > 0) ctx.quadraticCurveTo(x + w, y, x + w, y + rTR);
  else ctx.lineTo(x + w, y);
  ctx.lineTo(x + w, y + h - rBR);
  if (rBR > 0) ctx.quadraticCurveTo(x + w, y + h, x + w - rBR, y + h);
  else ctx.lineTo(x + w, y + h);
  ctx.lineTo(x + rBL, y + h);
  if (rBL > 0) ctx.quadraticCurveTo(x, y + h, x, y + h - rBL);
  else ctx.lineTo(x, y + h);
  ctx.lineTo(x, y + rTL);
  if (rTL > 0) ctx.quadraticCurveTo(x, y, x + rTL, y);
  else ctx.lineTo(x, y);
  ctx.closePath();
}

function drawEdgeSegWithRadius(edge, p, w, h, s, e, radii) {
  // Get corner radii in screen units
  const rTL = radii?.tl || 0;
  const rTR = radii?.tr || 0;
  const rBR = radii?.br || 0;
  const rBL = radii?.bl || 0;
  
  ctx.beginPath();
  
  if (edge === 'back') {
    // Back edge: from left to right at y=0
    const edgeLen = w;
    const startX = p.x + w * s;
    const endX = p.x + w * e;
    
    // Adjust for corner radii
    const effectiveStartX = s === 0 ? p.x + rTL : startX;
    const effectiveEndX = e === 1 ? p.x + w - rTR : endX;
    
    ctx.moveTo(effectiveStartX, p.y);
    ctx.lineTo(effectiveEndX, p.y);
    
    // Draw corner curves if at full edges
    if (s === 0 && rTL > 0) {
      ctx.moveTo(p.x, p.y + rTL);
      ctx.quadraticCurveTo(p.x, p.y, p.x + rTL, p.y);
    }
    if (e === 1 && rTR > 0) {
      ctx.moveTo(p.x + w - rTR, p.y);
      ctx.quadraticCurveTo(p.x + w, p.y, p.x + w, p.y + rTR);
    }
  } else if (edge === 'front') {
    // Front edge: from left to right at y=h
    const effectiveStartX = s === 0 ? p.x + rBL : p.x + w * s;
    const effectiveEndX = e === 1 ? p.x + w - rBR : p.x + w * e;
    
    ctx.moveTo(effectiveStartX, p.y + h);
    ctx.lineTo(effectiveEndX, p.y + h);
    
    // Draw corner curves if at full edges
    if (s === 0 && rBL > 0) {
      ctx.moveTo(p.x, p.y + h - rBL);
      ctx.quadraticCurveTo(p.x, p.y + h, p.x + rBL, p.y + h);
    }
    if (e === 1 && rBR > 0) {
      ctx.moveTo(p.x + w - rBR, p.y + h);
      ctx.quadraticCurveTo(p.x + w, p.y + h, p.x + w, p.y + h - rBR);
    }
  } else if (edge === 'left') {
    // Left edge: from top to bottom at x=0
    const effectiveStartY = s === 0 ? p.y + rTL : p.y + h * s;
    const effectiveEndY = e === 1 ? p.y + h - rBL : p.y + h * e;
    
    ctx.moveTo(p.x, effectiveStartY);
    ctx.lineTo(p.x, effectiveEndY);
    
    // Corner curves already drawn by back/front edges
  } else {
    // Right edge: from top to bottom at x=w
    const effectiveStartY = s === 0 ? p.y + rTR : p.y + h * s;
    const effectiveEndY = e === 1 ? p.y + h - rBR : p.y + h * e;
    
    ctx.moveTo(p.x + w, effectiveStartY);
    ctx.lineTo(p.x + w, effectiveEndY);
    
    // Corner curves already drawn by back/front edges
  }
  ctx.stroke();
}

function drawEdgeSeg(edge, p, w, h, s, e) {
  ctx.beginPath();
  if (edge === 'back') { ctx.moveTo(p.x + w * s, p.y); ctx.lineTo(p.x + w * e, p.y); }
  else if (edge === 'front') { ctx.moveTo(p.x + w * s, p.y + h); ctx.lineTo(p.x + w * e, p.y + h); }
  else if (edge === 'left') { ctx.moveTo(p.x, p.y + h * s); ctx.lineTo(p.x, p.y + h * e); }
  else { ctx.moveTo(p.x + w, p.y + h * s); ctx.lineTo(p.x + w, p.y + h * e); }
  ctx.stroke();
}

function drawUpstand2D(u) {
  // 2D drawing: upstands shown as rectangles on worktop edge
  // Use actual height for visual representation
  const VISUAL_DEPTH = u.height || 100; // Use actual upstand/splash height
  
  let p, w, h;
  
  // Window cills are drawn differently - they project OUT from the edge
  if (u.isWindowCill) {
    const cillDepth = u.depth || 200;
    const edge = u.parentEdge || 'back';
    
    if (u.isContinuous && u.absoluteX !== undefined) {
      if (edge === 'back') {
        // Projects backward (negative Y in 2D)
        p = mmToScreen(u.absoluteX, u.absoluteY - cillDepth);
        w = u.length * scale;
        h = cillDepth * scale;
      } else if (edge === 'front') {
        p = mmToScreen(u.absoluteX, u.absoluteY);
        w = u.length * scale;
        h = cillDepth * scale;
      } else if (edge === 'left') {
        p = mmToScreen(u.absoluteX - cillDepth, u.absoluteY);
        w = cillDepth * scale;
        h = u.length * scale;
      } else {
        p = mmToScreen(u.absoluteX, u.absoluteY);
        w = cillDepth * scale;
        h = u.length * scale;
      }
    } else {
      const parent = worktops.find(wt => wt.id === u.parentId);
      if (parent) {
        const edgeStart = u.edgeStart || 0;
        if (edge === 'back') {
          p = mmToScreen(parent.x + edgeStart, parent.y - cillDepth);
          w = u.length * scale;
          h = cillDepth * scale;
        } else if (edge === 'front') {
          p = mmToScreen(parent.x + edgeStart, parent.y + parent.depth);
          w = u.length * scale;
          h = cillDepth * scale;
        } else if (edge === 'left') {
          p = mmToScreen(parent.x - cillDepth, parent.y + edgeStart);
          w = cillDepth * scale;
          h = u.length * scale;
        } else {
          p = mmToScreen(parent.x + parent.length, parent.y + edgeStart);
          w = cillDepth * scale;
          h = u.length * scale;
        }
      } else {
        p = mmToScreen(u.x, u.y);
        w = u.length * scale;
        h = cillDepth * scale;
      }
    }
  } else if (u.isContinuous && u.absoluteX !== undefined) {
    // For continuous upstands, use absolute position
    const edge = u.parentEdge || 'back';
    
    // Handle stepout edges first
    if (edge.startsWith('stepout_')) {
      // Determine offset direction based on edge type
      let offsetX = 0, offsetY = 0;
      
      if (edge === 'stepout_bottom') {
        offsetY = 0; // Draw below edge
      } else if (edge === 'stepout_top') {
        offsetY = -VISUAL_DEPTH; // Draw above edge
      } else if (edge === 'stepout_left') {
        offsetX = -VISUAL_DEPTH; // Draw left of edge
      } else if (edge === 'stepout_right') {
        offsetX = 0; // Draw right of edge
      } else if (edge === 'stepout_outer') {
        offsetX = -VISUAL_DEPTH;
      } else if (edge === 'stepout_inner') {
        offsetX = 0;
      }
      
      const absX = u.absoluteX + offsetX;
      const absY = u.absoluteY + offsetY;
      p = mmToScreen(absX, absY);
      
      if (u.vertical) {
        w = VISUAL_DEPTH * scale;
        h = u.length * scale;
      } else {
        w = u.length * scale;
        h = VISUAL_DEPTH * scale;
      }
    } else if (edge === 'back') {
      p = mmToScreen(u.absoluteX, u.absoluteY - VISUAL_DEPTH);
      w = u.length * scale;
      h = VISUAL_DEPTH * scale;
    } else if (edge === 'front') {
      p = mmToScreen(u.absoluteX, u.absoluteY);
      w = u.length * scale;
      h = VISUAL_DEPTH * scale;
    } else if (edge === 'left') {
      p = mmToScreen(u.absoluteX - VISUAL_DEPTH, u.absoluteY);
      w = VISUAL_DEPTH * scale;
      h = u.length * scale;
    } else { // right
      p = mmToScreen(u.absoluteX, u.absoluteY);
      w = VISUAL_DEPTH * scale;
      h = u.length * scale;
    }
  } else {
    const parent = worktops.find(wt => wt.id === u.parentId);
    
    if (parent && u.parentEdge) {
      // Positioned relative to parent worktop
      const edge = u.parentEdge;
      const edgeStart = u.edgeStart || 0;
      const depth = VISUAL_DEPTH * scale;
      
      // Handle stepout edges - use absolute position with visual offset
      if (edge.startsWith('stepout_')) {
        const VISUAL_DEPTH = u.isSplash ? u.height : 80;
        // Determine offset direction based on edge type
        let offsetX = 0, offsetY = 0;
        
        if (edge === 'stepout_bottom') {
          offsetY = 0; // Draw below edge
        } else if (edge === 'stepout_top') {
          offsetY = -VISUAL_DEPTH; // Draw above edge
        } else if (edge === 'stepout_left') {
          offsetX = -VISUAL_DEPTH; // Draw left of edge
        } else if (edge === 'stepout_right') {
          offsetX = 0; // Draw right of edge
        } else if (edge === 'stepout_outer') {
          offsetX = -VISUAL_DEPTH; // Draw outside (left for left corners, but drawing handles this)
        } else if (edge === 'stepout_inner') {
          offsetX = 0; // Draw inside
        }
        
        const absX = (u.absoluteX || u.x) + offsetX;
        const absY = (u.absoluteY || u.y) + offsetY;
        p = mmToScreen(absX, absY);
        
        if (u.vertical) {
          w = VISUAL_DEPTH * scale;
          h = u.length * scale;
        } else {
          w = u.length * scale;
          h = VISUAL_DEPTH * scale;
        }
      } else if (edge === 'back') {
        p = mmToScreen(parent.x + edgeStart, parent.y - VISUAL_DEPTH);
        w = u.length * scale;
        h = depth;
      } else if (edge === 'front') {
        p = mmToScreen(parent.x + edgeStart, parent.y + parent.depth);
        w = u.length * scale;
        h = depth;
      } else if (edge === 'left') {
        p = mmToScreen(parent.x - VISUAL_DEPTH, parent.y + edgeStart);
        w = depth;
        h = u.length * scale;
      } else { // right
        p = mmToScreen(parent.x + parent.length, parent.y + edgeStart);
        w = depth;
        h = u.length * scale;
      }
    } else {
      // Free-standing upstand
      p = mmToScreen(u.x, u.y);
      const depth = VISUAL_DEPTH * scale;
      if (u.vertical) {
        w = depth;
        h = u.length * scale;
      } else {
        w = u.length * scale;
        h = depth;
      }
    }
  }
  
  const sel = selectedType === 'upstand' && selectedId === u.id;
  
  // Original colors for 2D - helps distinguish element types
  let fillColor;
  if (sel) {
    fillColor = '#2e7d32';
  } else if (u.isWindowCill) {
    fillColor = '#ffb74d'; // Orange for window cills
  } else if (u.isSplash) {
    fillColor = '#80cbc4'; // Teal for splashbacks
  } else {
    fillColor = '#a5d6a7'; // Green for upstands
  }
  
  ctx.fillStyle = fillColor;
  ctx.fillRect(p.x, p.y, w, h);
  
  // Border
  ctx.strokeStyle = sel ? '#1e4d3a' : '#666';
  ctx.lineWidth = sel ? 3 : 1;
  ctx.strokeRect(p.x, p.y, w, h);
  
  // Draw connection line to worktop (not for cills)
  if (!u.isWindowCill) {
    ctx.strokeStyle = '#4CAF50';
    ctx.lineWidth = 2;
    ctx.setLineDash([4, 2]);
    
    const edge = u.parentEdge || 'back';
    
    // Handle stepout edges
    if (edge.startsWith('stepout_')) {
      // Draw connection line based on whether upstand is vertical or horizontal
      if (u.vertical) {
        // For vertical stepout upstands, connect on the inner side
        if (edge === 'stepout_left' || edge === 'stepout_outer') {
          ctx.beginPath();
          ctx.moveTo(p.x + w, p.y);
          ctx.lineTo(p.x + w, p.y + h);
          ctx.stroke();
        } else {
          ctx.beginPath();
          ctx.moveTo(p.x, p.y);
          ctx.lineTo(p.x, p.y + h);
          ctx.stroke();
        }
      } else {
        // For horizontal stepout upstands, connect on top
        if (edge === 'stepout_top') {
          ctx.beginPath();
          ctx.moveTo(p.x, p.y + h);
          ctx.lineTo(p.x + w, p.y + h);
          ctx.stroke();
        } else {
          ctx.beginPath();
          ctx.moveTo(p.x, p.y);
          ctx.lineTo(p.x + w, p.y);
          ctx.stroke();
        }
      }
    } else if (edge === 'back') {
      ctx.beginPath();
      ctx.moveTo(p.x, p.y + h);
      ctx.lineTo(p.x + w, p.y + h);
      ctx.stroke();
    } else if (edge === 'front') {
      ctx.beginPath();
      ctx.moveTo(p.x, p.y);
      ctx.lineTo(p.x + w, p.y);
      ctx.stroke();
    } else if (edge === 'left') {
      ctx.beginPath();
      ctx.moveTo(p.x + w, p.y);
      ctx.lineTo(p.x + w, p.y + h);
      ctx.stroke();
    } else {
      ctx.beginPath();
      ctx.moveTo(p.x, p.y);
      ctx.lineTo(p.x, p.y + h);
      ctx.stroke();
    }
    ctx.setLineDash([]);
  }
  
  // Label
  ctx.fillStyle = '#333';
  ctx.font = 'bold 10px sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  
  let label;
  if (u.isWindowCill) {
    label = `Cill ${Math.round(u.length)}√ó${Math.round(u.depth || 200)}`;
  } else {
    label = `${Math.round(u.length)}√ó${Math.round(u.height)}`;
  }
  ctx.fillText(label, p.x + w/2, p.y + h/2);
  
  // Draw auto-split line if upstand has one
  if (u.autoSplitPos) {
    ctx.strokeStyle = '#ff5722';
    ctx.lineWidth = 2;
    ctx.setLineDash([6, 3]);
    
    const edge = u.parentEdge || 'back';
    const isVertical = u.vertical || edge === 'left' || edge === 'right';
    
    if (isVertical) {
      // Vertical upstand - split line is horizontal
      const splitY = p.y + (u.autoSplitPos * scale);
      ctx.beginPath();
      ctx.moveTo(p.x, splitY);
      ctx.lineTo(p.x + w, splitY);
      ctx.stroke();
    } else {
      // Horizontal upstand - split line is vertical
      const splitX = p.x + (u.autoSplitPos * scale);
      ctx.beginPath();
      ctx.moveTo(splitX, p.y);
      ctx.lineTo(splitX, p.y + h);
      ctx.stroke();
    }
    
    ctx.setLineDash([]);
    
    // Draw small "joint" indicator
    ctx.fillStyle = '#ff5722';
    ctx.font = '8px sans-serif';
    if (isVertical) {
      const splitY = p.y + (u.autoSplitPos * scale);
      ctx.fillText('joint', p.x + w/2, splitY - 6);
    } else {
      const splitX = p.x + (u.autoSplitPos * scale);
      ctx.save();
      ctx.translate(splitX, p.y + h/2);
      ctx.rotate(-Math.PI/2);
      ctx.fillText('joint', 0, -4);
      ctx.restore();
    }
  }
}

// Find connections between upstands
function findUpstandConnections(u) {
  const connections = [];
  const tol = 20;
  const VISUAL_DEPTH = 80;
  
  // Get actual bounds of this upstand
  let u1x, u1y, u1w, u1h;
  
  if (u.isContinuous && u.absoluteX !== undefined) {
    u1x = u.absoluteX;
    u1y = u.absoluteY - VISUAL_DEPTH;
    u1w = u.length;
    u1h = VISUAL_DEPTH;
  } else {
    const parent1 = worktops.find(w => w.id === u.parentId);
    
    if (parent1 && u.parentEdge) {
      const edgeStart = u.edgeStart || 0;
      if (u.parentEdge === 'back') {
        u1x = parent1.x + edgeStart; u1y = parent1.y - VISUAL_DEPTH;
        u1w = u.length; u1h = VISUAL_DEPTH;
      } else if (u.parentEdge === 'front') {
        u1x = parent1.x + edgeStart; u1y = parent1.y + parent1.depth;
        u1w = u.length; u1h = VISUAL_DEPTH;
      } else if (u.parentEdge === 'left') {
        u1x = parent1.x - VISUAL_DEPTH; u1y = parent1.y + edgeStart;
        u1w = VISUAL_DEPTH; u1h = u.length;
      } else {
        u1x = parent1.x + parent1.length; u1y = parent1.y + edgeStart;
        u1w = VISUAL_DEPTH; u1h = u.length;
      }
    } else {
      u1x = u.x; u1y = u.y;
      u1w = u.vertical ? VISUAL_DEPTH : u.length;
      u1h = u.vertical ? u.length : VISUAL_DEPTH;
    }
  }
  
  const u1Corners = [
    { x: u1x, y: u1y }, { x: u1x + u1w, y: u1y },
    { x: u1x, y: u1y + u1h }, { x: u1x + u1w, y: u1y + u1h }
  ];
  
  upstands.forEach(other => {
    if (other.id === u.id) return;
    
    // Get bounds of other upstand
    let u2x, u2y, u2w, u2h;
    
    if (other.isContinuous && other.absoluteX !== undefined) {
      u2x = other.absoluteX;
      u2y = other.absoluteY - VISUAL_DEPTH;
      u2w = other.length;
      u2h = VISUAL_DEPTH;
    } else {
      const parent2 = worktops.find(w => w.id === other.parentId);
      
      if (parent2 && other.parentEdge) {
        const edgeStart = other.edgeStart || 0;
        if (other.parentEdge === 'back') {
          u2x = parent2.x + edgeStart; u2y = parent2.y - VISUAL_DEPTH;
          u2w = other.length; u2h = VISUAL_DEPTH;
        } else if (other.parentEdge === 'front') {
          u2x = parent2.x + edgeStart; u2y = parent2.y + parent2.depth;
          u2w = other.length; u2h = VISUAL_DEPTH;
        } else if (other.parentEdge === 'left') {
          u2x = parent2.x - VISUAL_DEPTH; u2y = parent2.y + edgeStart;
          u2w = VISUAL_DEPTH; u2h = other.length;
        } else {
          u2x = parent2.x + parent2.length; u2y = parent2.y + edgeStart;
          u2w = VISUAL_DEPTH; u2h = other.length;
        }
      } else {
        u2x = other.x; u2y = other.y;
        u2w = other.vertical ? VISUAL_DEPTH : other.length;
        u2h = other.vertical ? other.length : VISUAL_DEPTH;
      }
    }
    
    const u2Corners = [
      { x: u2x, y: u2y }, { x: u2x + u2w, y: u2y },
      { x: u2x, y: u2y + u2h }, { x: u2x + u2w, y: u2y + u2h }
    ];
    
    u1Corners.forEach(c1 => {
      u2Corners.forEach(c2 => {
        const d = Math.sqrt((c1.x - c2.x) ** 2 + (c1.y - c2.y) ** 2);
        if (d < tol) {
          connections.push({ x: c1.x, y: c1.y, otherId: other.id });
        }
      });
    });
  });
  
  return connections;
}

// Split upstand when splashback is placed on it
function checkAndSplitUpstands() {
  const MAX_LEN = 3200;
  const splashbacks = upstands.filter(u => u.isSplash);
  const regularUpstands = upstands.filter(u => !u.isSplash && !u.isWindowCill);
  const newUpstands = [];
  const toRemove = new Set();
  
  splashbacks.forEach(splash => {
    const splashEdge = splash.parentEdge || 'back';
    const isHorizontal = (splashEdge === 'back' || splashEdge === 'front');
    
    // Get splash position
    let splashPos, splashLen, splashEdgePos;
    if (isHorizontal) {
      splashPos = splash.absoluteX;
      splashEdgePos = splash.absoluteY;
    } else {
      splashPos = splash.absoluteY;
      splashEdgePos = splash.absoluteX;
    }
    splashLen = splash.length;
    const splashEnd = splashPos + splashLen;
    
    // Find ALL upstands on this edge line (to merge them)
    const edgeUpstands = regularUpstands.filter(u => {
      if (u.parentEdge !== splashEdge) return false;
      if (toRemove.has(u.id)) return false;
      
      let uEdgePos;
      if (isHorizontal) {
        uEdgePos = u.absoluteY;
      } else {
        uEdgePos = u.absoluteX;
      }
      return Math.abs(uEdgePos - splashEdgePos) < 30;
    });
    
    if (edgeUpstands.length === 0) return;
    
    // Get the full extent of all upstands on this edge
    let minPos = Infinity, maxPos = -Infinity;
    let storedJoints = [];
    let height = 100;
    
    edgeUpstands.forEach(u => {
      let uPos = isHorizontal ? u.absoluteX : u.absoluteY;
      minPos = Math.min(minPos, uPos);
      maxPos = Math.max(maxPos, uPos + u.length);
      if (u.joints) storedJoints = u.joints;
      height = u.height;
      toRemove.add(u.id);
    });
    
    const totalLen = maxPos - minPos;
    
    // Check if splash is within this range
    if (splashPos >= maxPos || splashEnd <= minPos) return;
    
    // Calculate left and right pieces
    const leftLen = splashPos - minPos;
    const rightLen = maxPos - splashEnd;
    
    console.log('Splash splits edge: left=' + leftLen + 'mm, splash=' + splashLen + 'mm, right=' + rightLen + 'mm');
    
    // Create LEFT piece(s) - only split at seam if > 3200mm
    if (leftLen >= 50) {
      const leftJoints = storedJoints.filter(j => j > minPos && j < splashPos);
      
      if (leftLen > MAX_LEN && leftJoints.length > 0) {
        // Need to split at a seam
        let splitAt = null;
        for (const j of leftJoints) {
          const relJ = j - minPos;
          if (relJ <= MAX_LEN && (leftLen - relJ) <= MAX_LEN) {
            splitAt = j;
            break;
          }
        }
        
        if (splitAt) {
          const len1 = splitAt - minPos;
          const len2 = splashPos - splitAt;
          
          newUpstands.push({
            id: nextId++,
            absoluteX: isHorizontal ? minPos : splashEdgePos,
            absoluteY: isHorizontal ? splashEdgePos : minPos,
            x: isHorizontal ? minPos : splashEdgePos,
            y: isHorizontal ? splashEdgePos : minPos,
            length: len1,
            height: height,
            vertical: !isHorizontal,
            isSplash: false,
            isContinuous: true,
            parentEdge: splashEdge,
            parentId: edgeUpstands[0].parentId,
            edgeStart: 0,
            joints: storedJoints
          });
          
          newUpstands.push({
            id: nextId++,
            absoluteX: isHorizontal ? splitAt : splashEdgePos,
            absoluteY: isHorizontal ? splashEdgePos : splitAt,
            x: isHorizontal ? splitAt : splashEdgePos,
            y: isHorizontal ? splashEdgePos : splitAt,
            length: len2,
            height: height,
            vertical: !isHorizontal,
            isSplash: false,
            isContinuous: true,
            parentEdge: splashEdge,
            parentId: edgeUpstands[0].parentId,
            edgeStart: len1,
            joints: storedJoints
          });
          console.log('Left split at seam: ' + len1 + 'mm + ' + len2 + 'mm');
        } else {
          // No valid seam, create one piece
          newUpstands.push({
            id: nextId++,
            absoluteX: isHorizontal ? minPos : splashEdgePos,
            absoluteY: isHorizontal ? splashEdgePos : minPos,
            x: isHorizontal ? minPos : splashEdgePos,
            y: isHorizontal ? splashEdgePos : minPos,
            length: leftLen,
            height: height,
            vertical: !isHorizontal,
            isSplash: false,
            isContinuous: true,
            parentEdge: splashEdge,
            parentId: edgeUpstands[0].parentId,
            edgeStart: 0,
            joints: storedJoints
          });
        }
      } else {
        // <= 3200mm, create one piece
        newUpstands.push({
          id: nextId++,
          absoluteX: isHorizontal ? minPos : splashEdgePos,
          absoluteY: isHorizontal ? splashEdgePos : minPos,
          x: isHorizontal ? minPos : splashEdgePos,
          y: isHorizontal ? splashEdgePos : minPos,
          length: leftLen,
          height: height,
          vertical: !isHorizontal,
          isSplash: false,
          isContinuous: true,
          parentEdge: splashEdge,
          parentId: edgeUpstands[0].parentId,
          edgeStart: 0,
          joints: storedJoints
        });
      }
    }
    
    // Create RIGHT piece(s)
    if (rightLen >= 50) {
      const rightJoints = storedJoints.filter(j => j > splashEnd && j < maxPos);
      
      if (rightLen > MAX_LEN && rightJoints.length > 0) {
        let splitAt = null;
        for (const j of rightJoints) {
          const relJ = j - splashEnd;
          if (relJ <= MAX_LEN && (rightLen - relJ) <= MAX_LEN) {
            splitAt = j;
            break;
          }
        }
        
        if (splitAt) {
          const len1 = splitAt - splashEnd;
          const len2 = maxPos - splitAt;
          
          newUpstands.push({
            id: nextId++,
            absoluteX: isHorizontal ? splashEnd : splashEdgePos,
            absoluteY: isHorizontal ? splashEdgePos : splashEnd,
            x: isHorizontal ? splashEnd : splashEdgePos,
            y: isHorizontal ? splashEdgePos : splashEnd,
            length: len1,
            height: height,
            vertical: !isHorizontal,
            isSplash: false,
            isContinuous: true,
            parentEdge: splashEdge,
            parentId: edgeUpstands[0].parentId,
            edgeStart: splashEnd - minPos,
            joints: storedJoints
          });
          
          newUpstands.push({
            id: nextId++,
            absoluteX: isHorizontal ? splitAt : splashEdgePos,
            absoluteY: isHorizontal ? splashEdgePos : splitAt,
            x: isHorizontal ? splitAt : splashEdgePos,
            y: isHorizontal ? splashEdgePos : splitAt,
            length: len2,
            height: height,
            vertical: !isHorizontal,
            isSplash: false,
            isContinuous: true,
            parentEdge: splashEdge,
            parentId: edgeUpstands[0].parentId,
            edgeStart: splitAt - minPos,
            joints: storedJoints
          });
          console.log('Right split at seam: ' + len1 + 'mm + ' + len2 + 'mm');
        } else {
          newUpstands.push({
            id: nextId++,
            absoluteX: isHorizontal ? splashEnd : splashEdgePos,
            absoluteY: isHorizontal ? splashEdgePos : splashEnd,
            x: isHorizontal ? splashEnd : splashEdgePos,
            y: isHorizontal ? splashEdgePos : splashEnd,
            length: rightLen,
            height: height,
            vertical: !isHorizontal,
            isSplash: false,
            isContinuous: true,
            parentEdge: splashEdge,
            parentId: edgeUpstands[0].parentId,
            edgeStart: splashEnd - minPos,
            joints: storedJoints
          });
        }
      } else {
        newUpstands.push({
          id: nextId++,
          absoluteX: isHorizontal ? splashEnd : splashEdgePos,
          absoluteY: isHorizontal ? splashEdgePos : splashEnd,
          x: isHorizontal ? splashEnd : splashEdgePos,
          y: isHorizontal ? splashEdgePos : splashEnd,
          length: rightLen,
          height: height,
          vertical: !isHorizontal,
          isSplash: false,
          isContinuous: true,
          parentEdge: splashEdge,
          parentId: edgeUpstands[0].parentId,
          edgeStart: splashEnd - minPos,
          joints: storedJoints
        });
      }
    }
  });
  
  if (toRemove.size > 0) {
    // MIGRATE SOCKETS: Before removing old upstands, migrate any sockets to new upstands
    const socketsToMigrate = cutouts.filter(c => c.type === 'socket' && toRemove.has(c.parentId));
    
    socketsToMigrate.forEach(socket => {
      const oldParent = upstands.find(u => u.id === socket.parentId);
      if (!oldParent) return;
      
      // Calculate socket's absolute position along the edge
      const isHorizontal = oldParent.parentEdge === 'back' || oldParent.parentEdge === 'front';
      const socketAbsPos = isHorizontal 
        ? (oldParent.absoluteX || 0) + socket.centerX
        : (oldParent.absoluteY || 0) + socket.centerX;
      
      // Find which new upstand contains this position
      for (const newU of newUpstands) {
        if (newU.isSplash) continue; // Don't migrate to splashback
        
        const newStart = isHorizontal ? newU.absoluteX : newU.absoluteY;
        const newEnd = newStart + newU.length;
        
        if (socketAbsPos >= newStart && socketAbsPos <= newEnd) {
          // This new upstand contains the socket
          const newCenterX = socketAbsPos - newStart;
          console.log(`Migrating socket ${socket.id} from upstand ${socket.parentId} to ${newU.id}, centerX: ${socket.centerX} -> ${newCenterX}`);
          socket.parentId = newU.id;
          socket.centerX = newCenterX;
          break;
        }
      }
    });
    
    upstands = upstands.filter(u => !toRemove.has(u.id));
    upstands.push(...newUpstands);
    renderLists();
    render();
  }
}

function drawPreview() {
  const s = mmToScreen(drawStart.x, drawStart.y);
  const e = mmToScreen(drawStart.endX ?? drawStart.x, drawStart.endY ?? drawStart.y);
  
  ctx.strokeStyle = '#1e4d3a';
  ctx.lineWidth = 2;
  ctx.setLineDash([6, 4]);
  ctx.strokeRect(Math.min(s.x, e.x), Math.min(s.y, e.y), Math.abs(e.x - s.x), Math.abs(e.y - s.y));
  ctx.setLineDash([]);
  
  const wMm = Math.round(Math.abs((drawStart.endX ?? drawStart.x) - drawStart.x));
  const hMm = Math.round(Math.abs((drawStart.endY ?? drawStart.y) - drawStart.y));
  const cx = (s.x + e.x) / 2, cy = (s.y + e.y) / 2;
  ctx.fillStyle = 'rgba(255,255,255,0.9)';
  ctx.fillRect(cx - 30, cy - 10, 60, 20);
  ctx.fillStyle = '#1e4d3a';
  ctx.font = 'bold 11px sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(`${wMm}√ó${hMm}`, cx, cy);
}

// ========== LISTS ==========
function renderLists() {
  document.getElementById('worktopsList').innerHTML = worktops.map(w => {
    const splitCount = w.splits ? w.splits.length + 1 : 0;
    const splitBadge = splitCount > 1 ? `<span style="background:#ff9800;color:white;font-size:9px;padding:1px 4px;border-radius:3px;margin-left:4px;">${splitCount} pcs</span>` : '';
    const stepoutBadge = w.stepout ? `<span style="background:#9c27b0;color:white;font-size:9px;padding:1px 4px;border-radius:3px;margin-left:4px;">L-shape</span>` : '';
    const dimsText = w.stepout ? `${w.length}√ó${w.depth} + ${w.stepout.length}√ó${w.stepout.depth}` : `${w.length}√ó${w.depth}`;
    return `
    <div class="item-row ${selectedType === 'worktop' && selectedId === w.id ? 'selected' : ''}" onclick="selectItem('worktop',${w.id})">
      <div class="item-icon worktop">${w.stepout ? '‚åê' : '‚ñ≠'}</div>
      <div class="item-info"><div class="item-name">${w.name}${splitBadge}${stepoutBadge}</div><div class="item-dims">${dimsText}</div></div>
      <button class="item-delete" onclick="event.stopPropagation();deleteWorktop(${w.id})">√ó</button>
    </div>
  `}).join('') || '<div style="color:#999;padding:6px;font-size:11px;">No worktops</div>';
  
  document.getElementById('upstandsList').innerHTML = upstands.map(u => {
    let icon, name, dims;
    if (u.isWindowCill) {
      icon = '‚ñî';
      name = 'Window Cill';
      dims = `${u.length}√ó${u.depth || 200}`;
    } else if (u.isSplash) {
      icon = '‚ñà';
      name = 'Splashback';
      dims = `${u.length}√ó${u.height}`;
    } else {
      icon = '‚ñ¨';
      name = 'Upstand';
      dims = `${u.length}√ó${u.height}`;
    }
    return `
      <div class="item-row ${selectedType === 'upstand' && selectedId === u.id ? 'selected' : ''}" onclick="selectItem('upstand',${u.id})">
        <div class="item-icon upstand" style="${u.isWindowCill ? 'color:#ffb74d;' : ''}">${icon}</div>
        <div class="item-info"><div class="item-name">${name}</div><div class="item-dims">${dims}</div></div>
        <button class="item-delete" onclick="event.stopPropagation();deleteUpstand(${u.id})">√ó</button>
      </div>
    `;
  }).join('') || '<div style="color:#999;padding:6px;font-size:11px;">No upstands</div>';
  
  // Render cutouts list
  const cutoutsHtml = cutouts.map(c => {
    let icon, name, dims;
    if (c.type === 'undermount_sink') {
      icon = '‚ñ¢';
      name = c.isButler ? 'Butler Sink' : 'Undermount Sink';
      dims = `${c.width}√ó${c.length}`;
    } else if (c.type === 'overmount_sink') {
      icon = '‚ñ°'; name = 'Overmount Sink'; dims = `${c.width}√ó${c.length}`;
    } else if (c.type === 'hob') {
      icon = '‚ñ¶'; name = 'Hob Cutout'; dims = `${c.width}√ó${c.length}`;
    } else if (c.type === 'recess_hob') {
      icon = '‚ñ¶'; name = 'Recess Hob'; dims = `${c.width}√ó${c.length}`;
    } else if (c.type === 'tap') {
      icon = '‚óã'; name = 'Tap / Socket'; dims = `√ò${c.diameter}`;
    } else if (c.type === 'socket') {
      icon = '‚ñØ'; name = 'Socket Cutout'; dims = `${c.width}√ó${c.height}`;
    } else if (c.type === 'drainer') {
      icon = '‚â°'; name = 'Drainer'; dims = `${c.width}√ó${c.length}`;
    } else if (c.type === 'recess_drainer') {
      icon = '‚ñ§'; name = 'Recess Drainer'; dims = `${c.width}√ó${c.length}`;
    } else {
      icon = '‚ñ°'; name = 'Cutout'; dims = `${c.width}√ó${c.length}`;
    }
    return `
      <div class="item-row ${selectedType === 'cutout' && selectedId === c.id ? 'selected' : ''}" onclick="selectItem('cutout',${c.id})">
        <div class="item-icon" style="color:#e91e63;">${icon}</div>
        <div class="item-info"><div class="item-name">${name}</div><div class="item-dims">${dims}</div></div>
        <button class="item-delete" onclick="event.stopPropagation();deleteCutout(${c.id})">√ó</button>
      </div>
    `;
  }).join('');
  
  // Add cutouts section if there are any
  const cutoutsSection = document.getElementById('cutoutsList');
  if (cutoutsSection) {
    cutoutsSection.innerHTML = cutoutsHtml || '<div style="color:#999;padding:6px;font-size:11px;">No cutouts</div>';
  }
}

function deleteWorktop(id) { selectedType = 'worktop'; selectedId = id; deleteSelected(); }
function deleteUpstand(id) { selectedType = 'upstand'; selectedId = id; deleteSelected(); }

function renderProps() {
  const panel = document.getElementById('propsPanel');
  const form = document.getElementById('propsForm');
  
  if (selectedType === 'worktop') {
    const w = worktops.find(w => w.id === selectedId);
    if (!w) { panel.style.display = 'none'; return; }
    panel.style.display = 'block';
    
    form.innerHTML = `
      <div class="form-group full"><label class="form-label">Name</label><input class="form-input" value="${w.name}" onchange="updateWorktop(${w.id},'name',this.value)"></div>
      <div class="form-row">
        <div class="form-group"><label class="form-label">Length (mm)</label><input class="form-input" type="number" value="${w.length}" onchange="updateWorktop(${w.id},'length',+this.value)"></div>
        <div class="form-group"><label class="form-label">Depth (mm)</label><input class="form-input" type="number" value="${w.depth}" onchange="updateWorktop(${w.id},'depth',+this.value)"></div>
      </div>
      <div class="form-row">
        <div class="form-group"><label class="form-label">X Position</label><input class="form-input" type="number" value="${Math.round(w.x)}" onchange="updateWorktop(${w.id},'x',+this.value)"></div>
        <div class="form-group"><label class="form-label">Y Position</label><input class="form-input" type="number" value="${Math.round(w.y)}" onchange="updateWorktop(${w.id},'y',+this.value)"></div>
      </div>
    `;
  } else if (selectedType === 'upstand') {
    const u = upstands.find(u => u.id === selectedId);
    if (!u) { panel.style.display = 'none'; return; }
    panel.style.display = 'block';
    
    const parent = worktops.find(w => w.id === u.parentId);
    const parentInfo = parent ? `Attached to ${parent.name} (${u.parentEdge})` : 'Free-standing';
    
    form.innerHTML = `
      <div class="form-group full" style="font-size:10px;color:#666;margin-bottom:6px;">${parentInfo}</div>
      <div class="form-row">
        <div class="form-group"><label class="form-label">Length (mm)</label><input class="form-input" type="number" value="${u.length}" onchange="updateUpstand(${u.id},'length',+this.value)"></div>
        <div class="form-group"><label class="form-label">Height (mm)</label><input class="form-input" type="number" value="${u.height}" onchange="updateUpstand(${u.id},'height',+this.value)"></div>
      </div>
      <div class="form-group">
        <label class="form-label">Type</label>
        <select class="form-input" onchange="updateUpstand(${u.id},'isSplash',this.value==='splash')">
          <option value="upstand" ${!u.isSplash ? 'selected' : ''}>Upstand (100mm)</option>
          <option value="splash" ${u.isSplash ? 'selected' : ''}>Splashback</option>
        </select>
      </div>
      ${getAdjacentUpstandButtons(u)}
      <div style="border-top:1px solid #eee;margin:8px 0;padding-top:8px;">
        <div style="font-size:10px;color:#1e4d3a;margin-bottom:6px;font-weight:600;">‚úÇÔ∏è Add Join (for material optimization)</div>
        <button onclick="addUpstandJoin(${u.id})" class="tool-btn" style="width:100%;padding:8px;background:#fff3e0;border-color:#ff9800;color:#e65100;">
          Split at position...
        </button>
        <div style="font-size:9px;color:#999;margin-top:4px;">Splits this piece for better slab utilization (e.g., behind tap hole)</div>
      </div>
    `;
  } else if (selectedType === 'cutout') {
    const c = cutouts.find(c => c.id === selectedId);
    if (!c) { panel.style.display = 'none'; return; }
    panel.style.display = 'block';
    
    const parent = worktops.find(w => w.id === c.parentId);
    const parentInfo = parent ? `On ${parent.name}` : 'Free-standing';
    
    let typeLabel = c.type.replace('_', ' ').replace(/\b\w/g, l => l.toUpperCase());
    
    if (c.type === 'tap') {
      // Calculate distances from worktop edges
      let distFromLeft = 0, distFromBack = 0;
      if (parent) {
        distFromLeft = Math.round(c.x - parent.x);
        distFromBack = Math.round(c.y - parent.y);
      }
      
      form.innerHTML = `
        <div class="form-group full" style="font-size:10px;color:#666;margin-bottom:6px;">${parentInfo} - Tap / Socket</div>
        <div class="form-group"><label class="form-label">Diameter (mm)</label><input class="form-input" type="number" value="${c.diameter}" onchange="updateCutout(${c.id},'diameter',+this.value)"></div>
        <div style="border-top:1px solid #eee;margin:8px 0;padding-top:8px;">
          <div style="font-size:10px;color:#1e4d3a;margin-bottom:6px;font-weight:600;">üìè Position (drag to move)</div>
        </div>
        <div class="form-row">
          <div class="form-group"><label class="form-label">From Left (mm)</label><input class="form-input" type="number" value="${distFromLeft}" onchange="updateTapPosition(${c.id},'left',+this.value)"></div>
          <div class="form-group"><label class="form-label">From Back (mm)</label><input class="form-input" type="number" value="${distFromBack}" onchange="updateTapPosition(${c.id},'back',+this.value)"></div>
        </div>
        <div style="margin-top:10px;"><button onclick="deleteCutout(${c.id})" style="width:100%;padding:8px;background:#ffebee;border:1px solid #c62828;color:#c62828;border-radius:4px;cursor:pointer;font-size:11px;">üóëÔ∏è Delete Tap/Socket</button></div>
      `;
    } else if (c.type === 'socket') {
      // Socket cutout on splashback
      const splashParent = upstands.find(u => u.id === c.parentId);
      const splashInfo = splashParent ? `On Splashback (${splashParent.length}√ó${splashParent.height}mm)` : 'Splashback';
      
      form.innerHTML = `
        <div class="form-group full" style="font-size:10px;color:#666;margin-bottom:6px;">${splashInfo} - Socket Cutout</div>
        <div class="form-row">
          <div class="form-group"><label class="form-label">Width (mm)</label><input class="form-input" type="number" value="${c.width}" onchange="updateCutout(${c.id},'width',+this.value)"></div>
          <div class="form-group"><label class="form-label">Height (mm)</label><input class="form-input" type="number" value="${c.height}" onchange="updateCutout(${c.id},'height',+this.value)"></div>
        </div>
        <div style="border-top:1px solid #eee;margin:8px 0;padding-top:8px;">
          <div style="font-size:10px;color:#1e4d3a;margin-bottom:6px;font-weight:600;">üìè Position (drag to move)</div>
        </div>
        <div class="form-row">
          <div class="form-group"><label class="form-label">Centre from Left (mm)</label><input class="form-input" type="number" value="${Math.round(c.centerX)}" onchange="updateSocketPosition(${c.id},'centerX',+this.value)"></div>
          <div class="form-group"><label class="form-label">Centre from Bottom (mm)</label><input class="form-input" type="number" value="${Math.round(c.centerY)}" onchange="updateSocketPosition(${c.id},'centerY',+this.value)"></div>
        </div>
        <div style="margin-top:10px;"><button onclick="deleteCutout(${c.id})" style="width:100%;padding:8px;background:#ffebee;border:1px solid #c62828;color:#c62828;border-radius:4px;cursor:pointer;font-size:11px;">üóëÔ∏è Delete Socket Cutout</button></div>
      `;
    } else if (c.type === 'drainer' || c.type === 'recess_drainer') {
      let distFromLeft = 0, distFromBack = 0;
      if (parent) {
        distFromLeft = Math.round(c.x - parent.x);
        distFromBack = Math.round(c.y - parent.y);
      }
      const drainerType = c.type === 'recess_drainer' ? 'Recess Drainer' : 'Drainer';
      
      form.innerHTML = `
        <div class="form-group full" style="font-size:10px;color:#666;margin-bottom:6px;">${parentInfo} - ${drainerType}</div>
        <div class="form-row">
          <div class="form-group"><label class="form-label">Width (mm)</label><input class="form-input" type="number" value="${c.width}" onchange="updateCutout(${c.id},'width',+this.value)"></div>
          <div class="form-group"><label class="form-label">Length (mm)</label><input class="form-input" type="number" value="${c.length}" onchange="updateCutout(${c.id},'length',+this.value)"></div>
        </div>
        <div class="form-row">
          <div class="form-group"><label class="form-label">Grooves</label><input class="form-input" type="number" value="${c.grooveCount || 5}" onchange="updateCutout(${c.id},'grooveCount',+this.value)"></div>
          <div class="form-group"><label class="form-label">Side</label><span class="form-input" style="display:block;background:#f5f5f5;">${c.side || 'N/A'}</span></div>
        </div>
        <div style="border-top:1px solid #eee;margin:8px 0;padding-top:8px;">
          <div style="font-size:10px;color:#1e4d3a;margin-bottom:6px;font-weight:600;">üìè Position</div>
        </div>
        <div class="form-row">
          <div class="form-group"><label class="form-label">From Left (mm)</label><input class="form-input" type="number" value="${distFromLeft}" onchange="updateCutoutPosition(${c.id},'left',+this.value)"></div>
          <div class="form-group"><label class="form-label">From Back (mm)</label><input class="form-input" type="number" value="${distFromBack}" onchange="updateCutoutPosition(${c.id},'back',+this.value)"></div>
        </div>
        <div style="margin-top:10px;"><button onclick="deleteCutout(${c.id})" style="width:100%;padding:8px;background:#ffebee;border:1px solid #c62828;color:#c62828;border-radius:4px;cursor:pointer;font-size:11px;">üóëÔ∏è Delete ${drainerType}</button></div>
      `;
    } else {
      // Sinks, hobs, and other cutouts
      let distFromLeft = 0, distFromFront = 0;
      if (parent) {
        distFromLeft = Math.round(c.x - parent.x);
        // Calculate distance from FRONT edge (user stands at front)
        distFromFront = Math.round(parent.y + parent.depth - c.y - c.length);
      }
      
      form.innerHTML = `
        <div class="form-group full" style="font-size:10px;color:#666;margin-bottom:6px;">${parentInfo} - ${typeLabel}</div>
        <div class="form-row">
          <div class="form-group"><label class="form-label">Width (mm)</label><input class="form-input" type="number" value="${c.width}" onchange="updateCutout(${c.id},'width',+this.value)"></div>
          <div class="form-group"><label class="form-label">Length (mm)</label><input class="form-input" type="number" value="${c.length}" onchange="updateCutout(${c.id},'length',+this.value)"></div>
        </div>
        ${c.radius !== undefined ? `<div class="form-group"><label class="form-label">Corner Radius (mm)</label><input class="form-input" type="number" value="${c.radius}" onchange="updateCutout(${c.id},'radius',+this.value)"></div>` : ''}
        <div style="border-top:1px solid #eee;margin:8px 0;padding-top:8px;">
          <div style="font-size:10px;color:#1e4d3a;margin-bottom:6px;font-weight:600;">üìè Position (from front left corner)</div>
        </div>
        <div class="form-row">
          <div class="form-group"><label class="form-label">From Left (mm)</label><input class="form-input" type="number" value="${distFromLeft}" onchange="updateCutoutPosition(${c.id},'left',+this.value)"></div>
          <div class="form-group"><label class="form-label">From Front (mm)</label><input class="form-input" type="number" value="${distFromFront}" onchange="updateCutoutPosition(${c.id},'front',+this.value)"></div>
        </div>
        <div style="margin-top:10px;"><button onclick="deleteCutout(${c.id})" style="width:100%;padding:8px;background:#ffebee;border:1px solid #c62828;color:#c62828;border-radius:4px;cursor:pointer;font-size:11px;">üóëÔ∏è Delete ${typeLabel}</button></div>
      `;
    }
  } else {
    panel.style.display = 'none';
  }
}

function updateCutout(id, prop, val) {
  saveHistory();
  const c = cutouts.find(c => c.id === id);
  if (!c) return;
  c[prop] = val;
  renderProps();
  render();
  if (currentView === '3d') render3D();
}

function updateTapPosition(id, edge, val) {
  saveHistory();
  const c = cutouts.find(c => c.id === id);
  if (!c) return;
  
  const parent = worktops.find(w => w.id === c.parentId);
  if (!parent) return;
  
  if (edge === 'left') {
    c.x = parent.x + val;
  } else if (edge === 'back') {
    c.y = parent.y + val;
  }
  
  renderProps();
  render();
  if (currentView === '3d') render3D();
}

function updateSocketPosition(id, prop, val) {
  saveHistory();
  const c = cutouts.find(c => c.id === id);
  if (!c) return;
  
  const parent = upstands.find(u => u.id === c.parentId);
  if (!parent) return;
  
  // Constrain to splashback bounds
  if (prop === 'centerX') {
    c.centerX = Math.max(c.width/2, Math.min(parent.length - c.width/2, val));
  } else if (prop === 'centerY') {
    c.centerY = Math.max(c.height/2, Math.min(parent.height - c.height/2, val));
  }
  
  renderProps();
  render();
  if (currentView === '3d') render3D();
}

function updateCutoutPosition(id, edge, val) {
  saveHistory();
  const c = cutouts.find(c => c.id === id);
  if (!c) return;
  
  const parent = worktops.find(w => w.id === c.parentId);
  if (!parent) return;
  
  if (edge === 'left') {
    c.x = parent.x + val;
  } else if (edge === 'back') {
    c.y = parent.y + val;
  } else if (edge === 'front') {
    // From front = distance from front edge to front of cutout
    // Front edge is at parent.y + parent.depth
    // Cutout front edge is at c.y + c.length
    // So: c.y + c.length = parent.y + parent.depth - val
    // Therefore: c.y = parent.y + parent.depth - val - c.length
    c.y = parent.y + parent.depth - val - c.length;
  }
  
  renderProps();
  render();
  if (currentView === '3d') render3D();
}

function updateWorktop(id, prop, val) {
  const w = worktops.find(w => w.id === id);
  if (!w) return;
  
  // Get slab dimensions
  const slabWInput = document.getElementById('slabWidthInput');
  const slabHInput = document.getElementById('slabHeightInput');
  const SLAB_W = slabWInput ? parseInt(slabWInput.value) || 3200 : 3200;
  const SLAB_H = slabHInput ? parseInt(slabHInput.value) || 1600 : 1600;
  
  // Check if new size would exceed slab dimensions
  const newLength = prop === 'length' ? val : w.length;
  const newDepth = prop === 'depth' ? val : w.depth;
  
  const canFitNormal = newLength <= SLAB_W && newDepth <= SLAB_H;
  const canFitRotated = newLength <= SLAB_H && newDepth <= SLAB_W;
  
  if (!canFitNormal && !canFitRotated) {
    alert(`‚ö†Ô∏è Worktop too large!\n\nRequested size: ${newLength}mm √ó ${newDepth}mm\nMax slab size: ${SLAB_W}mm √ó ${SLAB_H}mm\n\nPlease use a smaller size or split into multiple pieces with joints.`);
    return;
  }
  
  saveHistory();
  
  const oldLength = w.length;
  const oldDepth = w.depth;
  const oldX = w.x;
  const oldY = w.y;
  const tol = 30;
  
  // Check which sides have joints BEFORE making changes
  const hasJointRight = w.joints.right && w.joints.right.length > 0;
  const hasJointLeft = w.joints.left && w.joints.left.length > 0;
  const hasJointFront = w.joints.front && w.joints.front.length > 0;
  const hasJointBack = w.joints.back && w.joints.back.length > 0;
  
  if (prop === 'length') {
    const diff = val - oldLength;
    
    if (hasJointRight && !hasJointLeft) {
      // Joint on RIGHT - keep right edge fixed, resize from left
      w.length = val;
      w.x = oldX + oldLength - val;
    } else if (hasJointLeft && !hasJointRight) {
      // Joint on LEFT - keep left edge fixed, resize from right
      w.length = val;
      // Move pieces connected to our right edge
      const rightEdge = oldX + oldLength;
      const rightConnected = [];
      worktops.forEach(other => {
        if (other.id === w.id) return;
        if (Math.abs(other.x - rightEdge) <= tol) {
          if (Math.max(w.y, other.y) < Math.min(w.y + w.depth, other.y + other.depth)) {
            rightConnected.push(other);
          }
        }
      });
      if (rightConnected.length > 0) {
        const moved = [w.id];
        rightConnected.forEach(p => moveWithCascade(p, 'x', diff, moved, tol));
      }
    } else if (hasJointLeft && hasJointRight) {
      // Joints on BOTH sides - resize from right, move right-connected pieces
      w.length = val;
      const rightEdge = oldX + oldLength;
      const rightConnected = [];
      worktops.forEach(other => {
        if (other.id === w.id) return;
        if (Math.abs(other.x - rightEdge) <= tol) {
          if (Math.max(w.y, other.y) < Math.min(w.y + w.depth, other.y + other.depth)) {
            rightConnected.push(other);
          }
        }
      });
      if (rightConnected.length > 0) {
        const moved = [w.id];
        rightConnected.forEach(p => moveWithCascade(p, 'x', diff, moved, tol));
      }
    } else {
      // No joints - check for back/front connections on right side (for G-shape W4)
      let backFrontConnectionOnRight = false;
      const frontEdge = w.y + w.depth;
      const backEdge = w.y;
      
      worktops.forEach(other => {
        if (other.id === w.id) return;
        // Back connection
        if (Math.abs((other.y + other.depth) - backEdge) <= tol) {
          const overlapStart = Math.max(w.x, other.x);
          const overlapEnd = Math.min(w.x + w.length, other.x + other.length);
          if (overlapEnd > overlapStart) {
            const overlapCenter = (overlapStart + overlapEnd) / 2;
            const myCenter = w.x + w.length / 2;
            if (overlapCenter > myCenter) backFrontConnectionOnRight = true;
          }
        }
        // Front connection
        if (Math.abs(other.y - frontEdge) <= tol) {
          const overlapStart = Math.max(w.x, other.x);
          const overlapEnd = Math.min(w.x + w.length, other.x + other.length);
          if (overlapEnd > overlapStart) {
            const overlapCenter = (overlapStart + overlapEnd) / 2;
            const myCenter = w.x + w.length / 2;
            if (overlapCenter > myCenter) backFrontConnectionOnRight = true;
          }
        }
      });
      
      if (backFrontConnectionOnRight) {
        // Keep right edge fixed, resize from left
        w.length = val;
        w.x = oldX + oldLength - val;
      } else {
        // Resize from right
        w.length = val;
      }
    }
    
    // Update dropdowns
    updateDropdownsForResize(w, 'length', oldLength, val);
    
  } else if (prop === 'depth') {
    const diff = val - oldDepth;
    const frontEdge = oldY + oldDepth;
    
    // For depth changes, ALWAYS keep back edge fixed (against wall)
    // and move any pieces connected to our front edge
    
    // Find pieces connected to our front edge BEFORE changing depth
    const frontConnected = [];
    worktops.forEach(other => {
      if (other.id === w.id) return;
      const yMatch = Math.abs(other.y - frontEdge) <= tol;
      if (yMatch) {
        const xOverlap = Math.max(w.x, other.x) < Math.min(w.x + w.length, other.x + other.length);
        if (xOverlap) {
          frontConnected.push(other);
        }
      }
    });
    
    // Update depth (back edge stays at y, front edge moves)
    w.depth = val;
    
    // Move front-connected pieces
    if (frontConnected.length > 0) {
      const moved = [w.id];
      frontConnected.forEach(p => moveWithCascade(p, 'y', diff, moved, tol));
    }
    
    // Update dropdowns
    updateDropdownsForResize(w, 'depth', oldDepth, val);
    
  } else if (prop === 'x' || prop === 'y') {
    w[prop] = val;
  } else {
    w[prop] = val;
  }
  
  // Auto-resize attached upstands
  if (prop === 'length' || prop === 'depth') {
    autoResizeUpstands(w, oldLength, oldDepth);
  }
  
  detectAllJoints();
  
  // Realign edge profiles to match current free segments
  if (prop === 'length' || prop === 'depth') {
    realignEdgeProfiles(w);
  }
  
  renderLists(); 
  renderProps();
  render(); 
  updateSummary(); 
}

// Find all pieces connected to a piece (recursively) - skip pieces in skipList
function findAllConnected(startPiece, tol, found, skipList) {
  if (found.includes(startPiece.id)) return;
  if (skipList && skipList.includes(startPiece.id)) return;
  found.push(startPiece.id);
  
  const rightEdge = startPiece.x + startPiece.length;
  const leftEdge = startPiece.x;
  const frontEdge = startPiece.y + startPiece.depth;
  const backEdge = startPiece.y;
  
  worktops.forEach(other => {
    if (found.includes(other.id)) return;
    if (skipList && skipList.includes(other.id)) return;
    
    // Check RIGHT edge connection (other's left at our right, with Y overlap)
    if (Math.abs(other.x - rightEdge) <= tol) {
      if (Math.max(startPiece.y, other.y) < Math.min(startPiece.y + startPiece.depth, other.y + other.depth)) {
        findAllConnected(other, tol, found, skipList);
      }
    }
    
    // Check LEFT edge connection (other's right at our left, with Y overlap)
    if (Math.abs((other.x + other.length) - leftEdge) <= tol) {
      if (Math.max(startPiece.y, other.y) < Math.min(startPiece.y + startPiece.depth, other.y + other.depth)) {
        findAllConnected(other, tol, found, skipList);
      }
    }
    
    // Check FRONT edge connection (other's back at our front, with X overlap)
    if (Math.abs(other.y - frontEdge) <= tol) {
      if (Math.max(startPiece.x, other.x) < Math.min(startPiece.x + startPiece.length, other.x + other.length)) {
        findAllConnected(other, tol, found, skipList);
      }
    }
    
    // Check BACK edge connection (other's front at our back, with X overlap)
    if (Math.abs((other.y + other.depth) - backEdge) <= tol) {
      if (Math.max(startPiece.x, other.x) < Math.min(startPiece.x + startPiece.length, other.x + other.length)) {
        findAllConnected(other, tol, found, skipList);
      }
    }
  });
}

// Move a piece and all pieces connected to it
function moveWithCascade(piece, axis, amount, alreadyMoved, tol) {
  // Find all pieces connected to this one BEFORE moving (skip already moved)
  const connectedIds = [];
  findAllConnected(piece, tol, connectedIds, alreadyMoved);
  
  // Move all found pieces
  connectedIds.forEach(id => {
    const p = worktops.find(w => w.id === id);
    if (p) {
      p[axis] += amount;
      alreadyMoved.push(id);
    }
  });
}

// Update corner radius for worktop
function updateCornerRadius(id, corner, val) {
  saveHistory();
  const w = worktops.find(w => w.id === id);
  if (!w) return;
  
  // Ensure cornerRadii object exists
  if (!w.cornerRadii) w.cornerRadii = { tl: 0, tr: 0, br: 0, bl: 0 };
  
  // Clamp value between 0 and half the smaller dimension
  const maxRadius = Math.min(w.length / 2, w.depth / 2);
  w.cornerRadii[corner] = Math.max(0, Math.min(val, maxRadius));
  
  render();
  if (currentView === '3d') render3D();
  updateSummary();
}

// Update dropdown edge positions when worktop resizes
function updateDropdownsForResize(w, dimension, oldVal, newVal) {
  if (!w.edgeTypes) return;
  
  const newEdgeTypes = {};
  const tol = 5; // Tolerance for detecting full edge
  
  Object.entries(w.edgeTypes).forEach(([key, value]) => {
    const parts = key.split('_');
    const edge = parts[0];
    let start = parseInt(parts[1]);
    let end = parseInt(parts[2]);
    
    // Scale positions for edges that run along the changed dimension
    if (dimension === 'length' && (edge === 'back' || edge === 'front')) {
      // Check if this edge covered the full length before (with tolerance)
      const wasFullLength = (start <= tol && Math.abs(end - oldVal) <= tol);
      
      if (wasFullLength) {
        // Keep as full length
        start = 0;
        end = newVal;
      } else {
        // Scale proportionally
        const ratio = newVal / oldVal;
        start = Math.round(start * ratio);
        end = Math.min(Math.round(end * ratio), newVal);
      }
    } else if (dimension === 'depth' && (edge === 'left' || edge === 'right')) {
      // Check if this edge covered the full depth before (with tolerance)
      const wasFullDepth = (start <= tol && Math.abs(end - oldVal) <= tol);
      
      if (wasFullDepth) {
        // Keep as full depth
        start = 0;
        end = newVal;
      } else {
        // Scale proportionally
        const ratio = newVal / oldVal;
        start = Math.round(start * ratio);
        end = Math.min(Math.round(end * ratio), newVal);
      }
    }
    
    // Only keep if still valid
    if (end > start) {
      newEdgeTypes[`${edge}_${start}_${end}`] = value;
    }
  });
  
  w.edgeTypes = newEdgeTypes;
}

// Realign edge profile keys to match current free segments
// Called after detectAllJoints to fix any misaligned keys
function realignEdgeProfiles(w) {
  if (!w.edgeTypes || Object.keys(w.edgeTypes).length === 0) return;
  
  const newEdgeTypes = {};
  
  ['back', 'front', 'left', 'right'].forEach(edge => {
    const free = getFreeSegments(w, edge);
    
    // Find all edge profiles for this edge
    const edgeProfiles = [];
    Object.entries(w.edgeTypes).forEach(([key, value]) => {
      const parts = key.split('_');
      if (parts[0] === edge) {
        edgeProfiles.push({
          start: parseInt(parts[1]),
          end: parseInt(parts[2]),
          value: value
        });
      }
    });
    
    // For each free segment, find matching profile
    free.forEach(seg => {
      edgeProfiles.forEach(profile => {
        // Check if profile overlaps significantly with this segment
        const overlapStart = Math.max(seg.start, profile.start);
        const overlapEnd = Math.min(seg.end, profile.end);
        const overlapLen = Math.max(0, overlapEnd - overlapStart);
        const segLen = seg.end - seg.start;
        const profileLen = profile.end - profile.start;
        
        // If 80% overlap or profile intended to cover full edge
        if (overlapLen >= segLen * 0.8 || overlapLen >= profileLen * 0.8) {
          // Realign to current free segment
          newEdgeTypes[`${edge}_${seg.start}_${seg.end}`] = profile.value;
        }
      });
    });
  });
  
  // Merge with any edge types we couldn't realign (might be partial segments)
  Object.entries(w.edgeTypes).forEach(([key, value]) => {
    if (!Object.keys(newEdgeTypes).some(k => k.startsWith(key.split('_')[0] + '_'))) {
      // Keep original if we couldn't find a match
      newEdgeTypes[key] = value;
    }
  });
  
  w.edgeTypes = newEdgeTypes;
}

// Auto-resize upstands when their parent worktop changes size
function autoResizeUpstands(w, oldLength, oldDepth) {
  const MAX_LENGTH = 3200;
  
  upstands.forEach(u => {
    // For continuous upstands attached to this worktop
    if (u.parentId === w.id && u.isContinuous) {
      const edge = u.parentEdge;
      
      // Get new edge length for this worktop
      const newEdgeLen = (edge === 'back' || edge === 'front') ? w.length : w.depth;
      const oldEdgeLen = (edge === 'back' || edge === 'front') ? oldLength : oldDepth;
      
      if (oldEdgeLen === newEdgeLen) return;
      
      // Update upstand length to match worktop edge (cap at 3200)
      u.length = Math.round(Math.min(newEdgeLen, MAX_LENGTH));
      
      // Update position
      if (edge === 'back') {
        u.absoluteX = w.x + (u.edgeStart || 0);
        u.x = u.absoluteX;
        u.absoluteY = w.y;
        u.y = u.absoluteY;
      } else if (edge === 'front') {
        u.absoluteX = w.x + (u.edgeStart || 0);
        u.x = u.absoluteX;
        u.absoluteY = w.y + w.depth;
        u.y = u.absoluteY;
      } else if (edge === 'left') {
        u.absoluteX = w.x;
        u.x = u.absoluteX;
        u.absoluteY = w.y + (u.edgeStart || 0);
        u.y = u.absoluteY;
      } else if (edge === 'right') {
        u.absoluteX = w.x + w.length;
        u.x = u.absoluteX;
        u.absoluteY = w.y + (u.edgeStart || 0);
        u.y = u.absoluteY;
      }
      return;
    }
    
    // For continuous upstands, check if this worktop affects the upstand
    if (u.isContinuous) {
      const edge = u.parentEdge;
      
      // Check if this worktop contributes to this continuous upstand
      if (edge === 'back' || edge === 'front') {
        const edgeY = (edge === 'back') ? w.y : w.y + w.depth;
        const upstandY = u.absoluteY !== undefined ? u.absoluteY : u.y;
        
        if (Math.abs(edgeY - upstandY) < 30) {
          // This worktop is part of this continuous upstand - need to recalculate
          // Find all connected worktops at this edge and recalculate upstand length
          const connectedWorktops = findConnectedWorktopsForEdge(w, edge);
          
          let xStart = Infinity, xEnd = -Infinity;
          connectedWorktops.forEach(wt => {
            xStart = Math.min(xStart, wt.x);
            xEnd = Math.max(xEnd, wt.x + wt.length);
          });
          
          // Update upstand to match new range (split if > 3200)
          const newLength = xEnd - xStart;
          u.absoluteX = xStart;
          u.x = xStart;
          u.length = Math.round(Math.min(newLength, MAX_LENGTH));
        }
      } else {
        const edgeX = (edge === 'left') ? w.x : w.x + w.length;
        const upstandX = u.absoluteX !== undefined ? u.absoluteX : u.x;
        
        if (Math.abs(edgeX - upstandX) < 30) {
          // This worktop is part of this continuous upstand
          const connectedWorktops = findConnectedWorktopsForEdge(w, edge);
          
          let yStart = Infinity, yEnd = -Infinity;
          connectedWorktops.forEach(wt => {
            yStart = Math.min(yStart, wt.y);
            yEnd = Math.max(yEnd, wt.y + wt.depth);
          });
          
          const newLength = yEnd - yStart;
          u.absoluteY = yStart;
          u.y = yStart;
          u.length = Math.round(Math.min(newLength, MAX_LENGTH));
        }
      }
      return;
    }
    
    // Original logic for non-continuous upstands
    if (u.parentId !== w.id) return;
    
    const edge = u.parentEdge;
    const newEdgeLen = (edge === 'back' || edge === 'front') ? w.length : w.depth;
    const oldEdgeLen = (edge === 'back' || edge === 'front') ? oldLength : oldDepth;
    
    if (oldEdgeLen === newEdgeLen) return;
    
    // Scale the upstand proportionally or cap at edge length
    const ratio = newEdgeLen / oldEdgeLen;
    
    // If upstand was full length, keep it full length (up to 3200)
    if (Math.abs(u.length - oldEdgeLen) < 50) {
      u.length = Math.round(Math.min(newEdgeLen, MAX_LENGTH));
    } else {
      // Scale proportionally
      u.length = Math.round(Math.min(u.length * ratio, MAX_LENGTH, newEdgeLen));
    }
    
    // Update position based on edge
    if (edge === 'back') {
      u.x = w.x + (u.edgeStart || 0);
      u.absoluteX = u.x;
      u.absoluteY = w.y;
    } else if (edge === 'front') {
      u.x = w.x + (u.edgeStart || 0);
      u.absoluteX = u.x;
      u.absoluteY = w.y + w.depth;
    } else if (edge === 'left') {
      u.y = w.y + (u.edgeStart || 0);
      u.absoluteX = w.x;
      u.absoluteY = u.y;
    } else if (edge === 'right') {
      u.y = w.y + (u.edgeStart || 0);
      u.absoluteX = w.x + w.length;
      u.absoluteY = u.y;
    }
  });
}

// Helper function to find connected worktops for an edge
function findConnectedWorktopsForEdge(startWorktop, edgeType) {
  const connected = [startWorktop];
  const checked = new Set([startWorktop.id]);
  
  let queue = [startWorktop];
  while (queue.length > 0) {
    const current = queue.shift();
    
    worktops.forEach(other => {
      if (checked.has(other.id)) return;
      
      let edgeAligned = false;
      if (edgeType === 'back' || edgeType === 'front') {
        const currentEdgeY = (edgeType === 'back') ? current.y : current.y + current.depth;
        const otherEdgeY = (edgeType === 'back') ? other.y : other.y + other.depth;
        edgeAligned = Math.abs(currentEdgeY - otherEdgeY) < 30;
      } else {
        const currentEdgeX = (edgeType === 'left') ? current.x : current.x + current.length;
        const otherEdgeX = (edgeType === 'left') ? other.x : other.x + other.length;
        edgeAligned = Math.abs(currentEdgeX - otherEdgeX) < 30;
      }
      
      if (!edgeAligned) return;
      
      let touching = false;
      if (edgeType === 'back' || edgeType === 'front') {
        const xOverlap = !(current.x + current.length < other.x - 30 || other.x + other.length < current.x - 30);
        touching = xOverlap;
      } else {
        const yOverlap = !(current.y + current.depth < other.y - 30 || other.y + other.depth < current.y - 30);
        touching = yOverlap;
      }
      
      if (touching) {
        checked.add(other.id);
        connected.push(other);
        queue.push(other);
      }
    });
  }
  
  return connected;
}

function updateUpstand(id, prop, val) {
  saveHistory();
  const u = upstands.find(u => u.id === id);
  if (u) { 
    u[prop] = val; 
    renderLists(); 
    renderProps();
    render(); 
    updateSummary(); 
  }
}

// Add a join to split an upstand into two pieces
let splitUpstandId = null;
let moveJoinData = null;  // For moving join position between adjacent upstands

function showUpstandSplitModal(id) {
  const u = upstands.find(u => u.id === id);
  if (!u) return;
  
  splitUpstandId = id;
  
  // Update modal title based on type
  const typeText = u.isSplash ? 'Splashback' : 'Upstand';
  const modalTitle = document.querySelector('#upstandSplitModal .modal-title');
  if (modalTitle) {
    modalTitle.textContent = u.isSplash ? '‚úÇÔ∏è Edit Splashback' : '‚úÇÔ∏è Split Upstand';
  }
  
  // Update info text
  document.getElementById('upstandSplitInfo').textContent = 
    `${typeText}: ${u.length}mm √ó ${u.height}mm - Split for better material utilization`;
  document.getElementById('upstandSplitEnd').textContent = `${u.length}mm`;
  
  // Show/hide socket button based on whether it's a splashback
  const socketBtn = document.getElementById('addSocketFromModalBtn');
  if (socketBtn) {
    socketBtn.style.display = u.isSplash ? 'block' : 'none';
  }
  
  // Check for adjacent upstands and show move join buttons
  const adjacent = findAdjacentUpstands(u);
  const moveJoinContainer = document.getElementById('moveJoinButtonsContainer');
  const moveJoinButtons = document.getElementById('moveJoinButtons');
  
  if (adjacent.length > 0 && moveJoinContainer && moveJoinButtons) {
    let buttonsHtml = '';
    adjacent.forEach(adj => {
      const otherName = adj.upstand.isSplash ? 'Splashback' : 'Upstand';
      const totalLen = u.length + adj.upstand.length;
      buttonsHtml += `
        <button onclick="showMoveJoinModal(${u.id}, ${adj.upstand.id}, '${adj.side}')" 
                style="width:100%;padding:10px;margin-bottom:6px;background:#e3f2fd;border:1px solid #1976d2;color:#1565c0;border-radius:6px;cursor:pointer;font-size:12px;">
          Move join with ${otherName} (${adj.upstand.length}mm) - Total: ${totalLen}mm
        </button>`;
    });
    moveJoinButtons.innerHTML = buttonsHtml;
    moveJoinContainer.style.display = 'block';
  } else if (moveJoinContainer) {
    moveJoinContainer.style.display = 'none';
  }
  
  // Set default position to middle
  const defaultPos = Math.round(u.length / 2);
  document.getElementById('upstandSplitPosition').value = defaultPos;
  document.getElementById('upstandSplitPosition').max = u.length - 50;
  document.getElementById('upstandSplitPosition').min = 50;
  
  // Update preview
  updateSplitPreview();
  
  document.getElementById('upstandSplitModal').style.display = 'flex';
  setTimeout(() => document.getElementById('upstandSplitPosition').select(), 100);
}

function updateSplitPreview() {
  // Check if in move join mode
  if (moveJoinData) {
    updateMoveJoinPreview();
    return;
  }
  
  const u = upstands.find(u => u.id === splitUpstandId);
  if (!u) return;
  
  const pos = parseInt(document.getElementById('upstandSplitPosition').value) || 0;
  const total = u.length;
  const leftPct = (pos / total) * 100;
  
  // Update visual
  const visual = document.getElementById('upstandSplitVisual');
  visual.innerHTML = `
    <div style="position:absolute;left:0;top:0;bottom:0;width:${leftPct}%;background:#81c784;border-radius:2px 0 0 2px;"></div>
    <div style="position:absolute;left:${leftPct}%;top:-8px;bottom:-8px;width:3px;background:#ff9800;"></div>
    <div style="position:absolute;left:${leftPct}%;top:-20px;transform:translateX(-50%);font-size:10px;color:#ff9800;font-weight:bold;">‚úÇÔ∏è ${pos}mm</div>
    <div style="position:absolute;left:5px;top:50%;transform:translateY(-50%);font-size:18px;">‚óÄ‚îÄ‚îÄ</div>
    <div style="position:absolute;right:5px;top:50%;transform:translateY(-50%);font-size:18px;">‚îÄ‚îÄ‚ñ∂</div>
  `;
  
  // Update size labels
  document.getElementById('splitLeftSize').textContent = `‚óÄ Left: ${pos}mm`;
  document.getElementById('splitRightSize').textContent = `Right: ${total - pos}mm ‚ñ∂`;
}

function cancelUpstandSplit() {
  document.getElementById('upstandSplitModal').style.display = 'none';
  splitUpstandId = null;
  
  // Also reset move join mode if active
  if (moveJoinData) {
    moveJoinData = null;
    // Restore split button
    const splitBtn = document.querySelector('#upstandSplitModal .modal-btn.primary');
    if (splitBtn) {
      splitBtn.textContent = '‚úÇÔ∏è Split';
      splitBtn.onclick = applyUpstandSplit;
    }
  }
}

// Add socket to splashback directly from modal
function addSocketFromModal() {
  if (!splitUpstandId) return;
  
  const u = upstands.find(u => u.id === splitUpstandId);
  if (!u || !u.isSplash) return;
  
  // Close the split modal
  document.getElementById('upstandSplitModal').style.display = 'none';
  
  // Set up for socket placement
  pendingSocketData = { targetSplash: u };
  
  // Show socket size modal
  document.getElementById('socketModal').style.display = 'flex';
}

function deleteUpstandFromModal() {
  if (!splitUpstandId) return;
  
  if (!confirm('Delete this upstand/splashback?')) return;
  
  saveHistory();
  upstands = upstands.filter(u => u.id !== splitUpstandId);
  
  document.getElementById('upstandSplitModal').style.display = 'none';
  splitUpstandId = null;
  
  renderLists();
  render();
  updateSummary();
  if (currentView === '3d') render3D();
}

function applyUpstandSplit() {
  if (!splitUpstandId) return;
  
  const u = upstands.find(u => u.id === splitUpstandId);
  if (!u) return;
  
  const joinPos = parseInt(document.getElementById('upstandSplitPosition').value);
  
  if (isNaN(joinPos) || joinPos <= 50 || joinPos >= u.length - 50) {
    alert('Split position must be at least 50mm from either end');
    return;
  }
  
  saveHistory();
  
  // Create the second piece (right part)
  const rightPiece = {
    id: nextId++,
    length: u.length - joinPos,
    height: u.height,
    vertical: u.vertical,
    isSplash: u.isSplash,
    isContinuous: u.isContinuous,
    parentEdge: u.parentEdge,
    parentId: u.parentId,
    edgeStart: (u.edgeStart || 0) + joinPos
  };
  
  // Update position based on edge
  if (u.parentEdge === 'back' || u.parentEdge === 'front') {
    rightPiece.absoluteX = (u.absoluteX || u.x) + joinPos;
    rightPiece.x = rightPiece.absoluteX;
    rightPiece.absoluteY = u.absoluteY || u.y;
    rightPiece.y = rightPiece.absoluteY;
  } else {
    rightPiece.absoluteX = u.absoluteX || u.x;
    rightPiece.x = rightPiece.absoluteX;
    rightPiece.absoluteY = (u.absoluteY || u.y) + joinPos;
    rightPiece.y = rightPiece.absoluteY;
  }
  
  // Shorten the original (left part)
  u.length = joinPos;
  
  // Add the new piece
  upstands.push(rightPiece);
  
  document.getElementById('upstandSplitModal').style.display = 'none';
  splitUpstandId = null;
  
  renderLists();
  render();
  updateSummary();
}

// Find adjacent upstands (same edge, same height, touching)
function findAdjacentUpstands(u) {
  const tol = 5; // tolerance in mm
  const adjacent = [];
  
  upstands.forEach(other => {
    if (other.id === u.id) return;
    if (other.parentId !== u.parentId) return;
    if (other.parentEdge !== u.parentEdge) return;
    if (Math.abs(other.height - u.height) > tol) return;
    if (other.isSplash !== u.isSplash) return;
    
    // Check if they're touching (end of one meets start of other)
    const uStart = u.edgeStart || 0;
    const uEnd = uStart + u.length;
    const otherStart = other.edgeStart || 0;
    const otherEnd = otherStart + other.length;
    
    // Adjacent on the right (this ends where other starts)
    if (Math.abs(uEnd - otherStart) <= tol) {
      adjacent.push({ upstand: other, side: 'right', joinPos: uEnd });
    }
    // Adjacent on the left (other ends where this starts)
    if (Math.abs(otherEnd - uStart) <= tol) {
      adjacent.push({ upstand: other, side: 'left', joinPos: uStart });
    }
  });
  
  return adjacent;
}

// Generate buttons for adjacent upstands
function getAdjacentUpstandButtons(u) {
  const adjacent = findAdjacentUpstands(u);
  if (adjacent.length === 0) return '';
  
  let html = `<div style="border-top:1px solid #eee;margin:8px 0;padding-top:8px;">
    <div style="font-size:10px;color:#1e4d3a;margin-bottom:6px;font-weight:600;">üîó Move Join Position</div>`;
  
  adjacent.forEach(adj => {
    const otherName = adj.upstand.isSplash ? 'Splashback' : 'Upstand';
    const totalLen = u.length + adj.upstand.length;
    html += `
      <button onclick="showMoveJoinModal(${u.id}, ${adj.upstand.id}, '${adj.side}')" class="tool-btn" style="width:100%;padding:8px;margin-bottom:4px;background:#e3f2fd;border-color:#1976d2;color:#1565c0;">
        Move join with ${otherName} (${adj.upstand.length}mm)
      </button>`;
  });
  
  html += `<div style="font-size:9px;color:#999;margin-top:4px;">Adjust where pieces meet (total: ${u.length + (adjacent[0]?.upstand.length || 0)}mm)</div>
  </div>`;
  
  return html;
}

// Modal for moving join position
function showMoveJoinModal(id1, id2, side) {
  const u1 = upstands.find(u => u.id === id1);
  const u2 = upstands.find(u => u.id === id2);
  if (!u1 || !u2) return;
  
  // Determine which is left and which is right based on edgeStart/absoluteX
  let leftUpstand, rightUpstand;
  
  const u1Start = u1.edgeStart !== undefined ? u1.edgeStart : (u1.absoluteX || u1.x || 0);
  const u2Start = u2.edgeStart !== undefined ? u2.edgeStart : (u2.absoluteX || u2.x || 0);
  
  if (u1Start < u2Start) {
    leftUpstand = u1;
    rightUpstand = u2;
  } else {
    leftUpstand = u2;
    rightUpstand = u1;
  }
  
  const totalLength = leftUpstand.length + rightUpstand.length;
  const currentJoinPos = leftUpstand.length;
  
  console.log('Move join setup:', {
    left: { id: leftUpstand.id, length: leftUpstand.length, edgeStart: leftUpstand.edgeStart, absoluteX: leftUpstand.absoluteX },
    right: { id: rightUpstand.id, length: rightUpstand.length, edgeStart: rightUpstand.edgeStart, absoluteX: rightUpstand.absoluteX },
    totalLength, currentJoinPos
  });
  
  moveJoinData = { leftUpstand, rightUpstand, totalLength };
  
  // Use the split modal but reconfigure it
  splitUpstandId = null; // Clear normal split mode
  
  const typeText = u1.isSplash ? 'Splashback' : 'Upstand';
  document.getElementById('upstandSplitInfo').textContent = 
    `Move join between ${typeText} pieces (Total: ${totalLength}mm)`;
  document.getElementById('upstandSplitEnd').textContent = `${totalLength}mm`;
  
  // Update modal title
  const modalTitle = document.querySelector('#upstandSplitModal .modal-title');
  if (modalTitle) {
    modalTitle.textContent = 'üîó Move Join Position';
  }
  
  // Hide socket button for this mode
  const socketBtn = document.getElementById('addSocketFromModalBtn');
  if (socketBtn) socketBtn.style.display = 'none';
  
  // Hide the move join buttons container (we're already in move join mode)
  const moveJoinContainer = document.getElementById('moveJoinButtonsContainer');
  if (moveJoinContainer) moveJoinContainer.style.display = 'none';
  
  // Change split button to "Apply"
  const splitBtn = document.querySelector('#upstandSplitModal .modal-btn.primary');
  if (splitBtn) {
    splitBtn.textContent = '‚úì Apply';
    splitBtn.onclick = applyMoveJoin;
  }
  
  // Set position input
  document.getElementById('upstandSplitPosition').value = currentJoinPos;
  document.getElementById('upstandSplitPosition').max = totalLength - 50;
  document.getElementById('upstandSplitPosition').min = 50;
  
  // Update preview
  updateMoveJoinPreview();
  
  document.getElementById('upstandSplitModal').style.display = 'flex';
  setTimeout(() => document.getElementById('upstandSplitPosition').select(), 100);
}

function updateMoveJoinPreview() {
  if (!moveJoinData) {
    updateSplitPreview();
    return;
  }
  
  const { totalLength } = moveJoinData;
  const pos = parseInt(document.getElementById('upstandSplitPosition').value) || 0;
  const leftPct = (pos / totalLength) * 100;
  
  // Update visual
  const visual = document.getElementById('upstandSplitVisual');
  visual.innerHTML = `
    <div style="position:absolute;left:0;top:0;bottom:0;width:${leftPct}%;background:#81c784;border-radius:2px 0 0 2px;"></div>
    <div style="position:absolute;left:${leftPct}%;top:-8px;bottom:-8px;width:3px;background:#1976d2;"></div>
    <div style="position:absolute;left:${leftPct}%;top:-20px;transform:translateX(-50%);font-size:10px;color:#1976d2;font-weight:bold;">üîó ${pos}mm</div>
  `;
  
  // Update size labels
  document.getElementById('splitLeftSize').textContent = `‚óÄ Left: ${pos}mm`;
  document.getElementById('splitRightSize').textContent = `Right: ${totalLength - pos}mm ‚ñ∂`;
}

function applyMoveJoin() {
  if (!moveJoinData) {
    applyUpstandSplit();
    return;
  }
  
  const { leftUpstand, rightUpstand, totalLength } = moveJoinData;
  const newJoinPos = parseInt(document.getElementById('upstandSplitPosition').value);
  
  if (newJoinPos < 50 || newJoinPos > totalLength - 50) {
    alert('Join position must leave at least 50mm on each piece.');
    return;
  }
  
  saveHistory();
  
  // Calculate new lengths
  const newLeftLength = newJoinPos;
  const newRightLength = totalLength - newJoinPos;
  
  // Get the base position - where the left upstand starts
  const leftEdgeStart = leftUpstand.edgeStart || 0;
  const edge = leftUpstand.parentEdge || 'back';
  
  // Update the upstands lengths
  leftUpstand.length = newLeftLength;
  rightUpstand.length = newRightLength;
  
  // Update right upstand's edgeStart (for relative positioning)
  rightUpstand.edgeStart = leftEdgeStart + newLeftLength;
  
  // Update absolute positions - use left upstand's position as base
  if (edge === 'back' || edge === 'front') {
    // Horizontal edges - X position changes
    const leftStartX = leftUpstand.absoluteX !== undefined ? leftUpstand.absoluteX : leftUpstand.x;
    if (leftStartX !== undefined) {
      rightUpstand.absoluteX = leftStartX + newLeftLength;
      rightUpstand.x = rightUpstand.absoluteX;
    }
    // Copy Y from left upstand
    if (leftUpstand.absoluteY !== undefined) {
      rightUpstand.absoluteY = leftUpstand.absoluteY;
    }
    if (leftUpstand.y !== undefined) {
      rightUpstand.y = leftUpstand.y;
    }
  } else {
    // Vertical edges (left/right) - Y position changes
    const leftStartY = leftUpstand.absoluteY !== undefined ? leftUpstand.absoluteY : leftUpstand.y;
    if (leftStartY !== undefined) {
      rightUpstand.absoluteY = leftStartY + newLeftLength;
      rightUpstand.y = rightUpstand.absoluteY;
    }
    // Copy X from left upstand
    if (leftUpstand.absoluteX !== undefined) {
      rightUpstand.absoluteX = leftUpstand.absoluteX;
    }
    if (leftUpstand.x !== undefined) {
      rightUpstand.x = leftUpstand.x;
    }
  }
  
  console.log('Move join applied:', {
    edge: edge,
    leftLength: newLeftLength,
    rightLength: newRightLength,
    leftEdgeStart: leftEdgeStart,
    leftAbsoluteX: leftUpstand.absoluteX,
    rightEdgeStart: rightUpstand.edgeStart,
    rightAbsoluteX: rightUpstand.absoluteX,
    rightAbsoluteY: rightUpstand.absoluteY
  });
  
  // Reset modal
  document.getElementById('upstandSplitModal').style.display = 'none';
  
  // Restore split button
  const splitBtn = document.querySelector('#upstandSplitModal .modal-btn.primary');
  if (splitBtn) {
    splitBtn.textContent = '‚úÇÔ∏è Split';
    splitBtn.onclick = applyUpstandSplit;
  }
  
  moveJoinData = null;
  
  renderLists();
  render();
  renderProps();
  updateSummary();
  if (currentView === '3d') render3D();
}

// Keep old function for sidebar button
function addUpstandJoin(id) {
  showUpstandSplitModal(id);
}

// ========== CILL EDIT MODAL ==========
let editingCillId = null;

function showCillEditModal(id) {
  const u = upstands.find(u => u.id === id);
  if (!u || !u.isWindowCill) return;
  
  editingCillId = id;
  
  document.getElementById('editCillLength').value = u.length;
  document.getElementById('editCillDepth').value = u.depth || 200;
  document.getElementById('editCillHeight').value = u.height || 300;
  document.getElementById('cillEditModal').style.display = 'flex';
  
  setTimeout(() => document.getElementById('editCillLength').select(), 100);
}

function cancelCillEdit() {
  document.getElementById('cillEditModal').style.display = 'none';
  editingCillId = null;
}

function applyCillEdit() {
  if (!editingCillId) return;
  
  const u = upstands.find(u => u.id === editingCillId);
  if (!u) return;
  
  saveHistory();
  
  u.length = parseInt(document.getElementById('editCillLength').value) || u.length;
  u.depth = parseInt(document.getElementById('editCillDepth').value) || 200;
  u.height = parseInt(document.getElementById('editCillHeight').value) || 300;
  
  document.getElementById('cillEditModal').style.display = 'none';
  editingCillId = null;
  
  renderLists();
  render();
  renderProps();
  updateSummary();
  if (currentView === '3d') render3D();
}

function deleteCillFromModal() {
  if (!editingCillId) return;
  
  saveHistory();
  upstands = upstands.filter(u => u.id !== editingCillId);
  
  if (selectedType === 'upstand' && selectedId === editingCillId) {
    selectedType = null;
    selectedId = null;
  }
  
  document.getElementById('cillEditModal').style.display = 'none';
  editingCillId = null;
  
  renderLists();
  render();
  renderProps();
  updateSummary();
  if (currentView === '3d') render3D();
}

// ========== SUMMARY ==========
function setWorktopThickness(thickness) {
  worktopThickness = thickness;
  selectedThickness = thickness; // For pricing calculation
  
  // Update modal thickness buttons if present
  updateThicknessButtons();
  
  // Recalculate pricing
  updateSummary();
  
  if (currentView === '3d') render3D();
}

function setMaterialColor(colorKey) {
  if (MATERIAL_COLORS[colorKey]) {
    selectedMaterial = colorKey;
    
    // Re-render 2D
    render();
    
    // Load texture then render 3D
    if (currentView === '3d') {
      loadMaterialTexture(colorKey, () => {
        render3D();
      });
    }
  }
}

// Update the profile legend in 2D view
function updateProfileLegend(profileKeys) {
  const legendEl = document.getElementById('profileLegend');
  if (!legendEl) return;
  
  if (profileKeys.size === 0) {
    legendEl.innerHTML = '<div style="font-size:9px;color:#999;font-style:italic;">None selected</div>';
    return;
  }
  
  let html = '';
  profileKeys.forEach(key => {
    const profile = EDGE_PROFILES[key];
    if (profile) {
      html += `<div class="legend-item"><div class="legend-color" style="background:${profile.color};"></div> ${profile.name}</div>`;
    }
  });
  legendEl.innerHTML = html;
}

function updateSummary() {
  // Auto-splits are calculated during slab packing (getAccurateSlabCount/renderSlabLayout)
  // Clear any stale auto-split positions first
  upstands.forEach(u => delete u.autoSplitPos);
  
  let wa = 0, ua = 0, sa = 0, ca = 0, da = 0, pl = 0, jc = 0;
  let sinkCount = 0, hobCount = 0, tapCount = 0, drainerCount = 0;
  let profilePrice = 0;
  let profileTypes = new Set();
  let profileKeys = new Set(); // Track profile keys for colors
  
  worktops.forEach(w => {
    wa += (w.length / 1000) * (w.depth / 1000);
    ['back', 'front', 'left', 'right'].forEach(e => jc += (w.joints[e] || []).length);
    if (w.edgeTypes) {
      Object.entries(w.edgeTypes).forEach(([k, v]) => {
        // Parse key - format is "edge_start_end" or "stepout_edgename_start_end"
        const parts = k.split('_');
        let start, end;
        if (parts.length >= 3) {
          // Last two parts are always start and end
          end = parseInt(parts[parts.length - 1]);
          start = parseInt(parts[parts.length - 2]);
        } else {
          start = 0;
          end = 0;
        }
        const len = (end - start) / 1000;
        if (v.type === 'profile') {
          pl += len;
          // Track profile types and keys
          if (v.profileName) profileTypes.add(v.profileName);
          if (v.profileKey) profileKeys.add(v.profileKey);
          // Calculate profile price
          const pricePerMeter = v.pricePerMeter || 0;
          profilePrice += len * pricePerMeter;
        }
        else if (v.type === 'dropdown') da += len * (v.height / 1000);
        else if (v.type === 'mitred_edge') {
          da += len * (v.height / 1000); // Add to dropdown area
          profilePrice += len * (v.pricePerMeter || 66.67); // Add mitred edge price
          pl += len; // Add to profile length
          profileTypes.add(`Mitred Edge (${v.height}mm)`);
          profileKeys.add('mitred_edge');
        }
      });
    }
  });
  
  // Update profile legend in 2D view
  updateProfileLegend(profileKeys);
  
  upstands.forEach(u => {
    if (u.isWindowCill) {
      const cillDepth = u.depth || 200;
      ca += (u.length / 1000) * (cillDepth / 1000);
    } else if (u.isSplash) {
      sa += (u.length / 1000) * (u.height / 1000);
    } else {
      ua += (u.length / 1000) * (u.height / 1000);
    }
  });
  
  // Count cutouts
  let socketCount = 0;
  let cutoutPrice = 0;
  
  cutouts.forEach(c => {
    const priceInfo = CUTOUT_PRICES[c.type];
    if (priceInfo) {
      cutoutPrice += priceInfo.price;
    }
    
    if (c.type === 'undermount_sink' || c.type === 'overmount_sink') sinkCount++;
    else if (c.type === 'hob' || c.type === 'recess_hob') hobCount++;
    else if (c.type === 'tap') tapCount++;
    else if (c.type === 'drainer' || c.type === 'recess_drainer') drainerCount++;
    else if (c.type === 'socket') socketCount++;
  });
  
  jc = Math.floor(jc / 2);
  
  // Calculate total material
  const total = wa + ua + sa + ca + da;
  
  // Get quick estimate first for display
  let slabs = calculateActualSlabCount();
  
  // Combine upstands + splashbacks + cills for display
  const upstandTotal = ua + sa + ca;
  
  document.getElementById('sumWorktop').textContent = wa.toFixed(2) + ' m¬≤';
  document.getElementById('sumUpstand').textContent = upstandTotal.toFixed(2) + ' m¬≤';
  document.getElementById('sumDropdown').textContent = da.toFixed(2) + ' m¬≤';
  document.getElementById('sumTotal').textContent = total.toFixed(2) + ' m¬≤';
  document.getElementById('sumProfile').textContent = pl.toFixed(2) + ' m';
  document.getElementById('sumJoints').textContent = jc;
  document.getElementById('sumSlabs').textContent = slabs;
  
  // Run accurate slab packing and check for popup (only if not loading and have pieces)
  if (!isPageLoading && worktops.length > 0) {
    const accurateSlabs = getAccurateSlabCount();
    document.getElementById('sumSlabs').textContent = accurateSlabs;
    
    // Debug logging
    console.log('Slab check - accurate:', accurateSlabs, 'lastKnown:', lastKnownSlabCount, 'suggestions:', slabOptimizationSuggestions.length, 'hasShown:', hasShownSlabWarning, 'materialChanging:', isMaterialChanging, 'pageLoading:', isPageLoading);
    
    // Trigger popup ONLY when slab count INCREASES and we have actionable suggestions
    // NOT on page load, material changes, or when returning from other pages
    const shouldShowPopup = !isPageLoading && !isMaterialChanging && 
                            slabOptimizationSuggestions.length > 0 && 
                            accurateSlabs > lastKnownSlabCount;
    
    if (shouldShowPopup) {
      hasShownSlabWarning = true;
      sessionStorage.setItem('hasShownSlabWarning', 'true');
      setTimeout(() => {
        showSlabOptimizationPopup(accurateSlabs);
      }, 200);
    }
    
    // Reset warning flag if slabs decreased significantly
    if (accurateSlabs < lastKnownSlabCount - 1) {
      hasShownSlabWarning = false;
      sessionStorage.setItem('hasShownSlabWarning', 'false');
    }
    
    // Always update lastKnownSlabCount
    lastKnownSlabCount = accurateSlabs;
    sessionStorage.setItem('lastKnownSlabCount', accurateSlabs.toString());
  }
  
  // Show profile types
  const sumProfileType = document.getElementById('sumProfileType');
  if (sumProfileType) {
    if (profileTypes.size > 0) {
      sumProfileType.textContent = Array.from(profileTypes).join(', ');
    } else {
      sumProfileType.textContent = 'None';
    }
  }
  
  // Update cutouts summary
  const sumCutouts = document.getElementById('sumCutouts');
  if (sumCutouts) {
    const parts = [];
    if (sinkCount) parts.push(`${sinkCount} sink${sinkCount > 1 ? 's' : ''}`);
    if (hobCount) parts.push(`${hobCount} hob${hobCount > 1 ? 's' : ''}`);
    if (tapCount) parts.push(`${tapCount} tap${tapCount > 1 ? 's' : ''}`);
    if (drainerCount) parts.push(`${drainerCount} drainer${drainerCount > 1 ? 's' : ''}`);
    if (socketCount) parts.push(`${socketCount} socket${socketCount > 1 ? 's' : ''}`);
    sumCutouts.textContent = parts.length ? parts.join(', ') : 'None';
  }
}

// Calculate actual slab count using simplified bin packing
// Simplified slab count for quick estimate
function calculateActualSlabCount() {
  const slabWInput = document.getElementById('slabWidthInput');
  const slabHInput = document.getElementById('slabHeightInput');
  const SLAB_W = slabWInput ? parseInt(slabWInput.value) || 3200 : 3200;
  const SLAB_H = slabHInput ? parseInt(slabHInput.value) || 1600 : 1600;
  
  // Quick area-based estimate
  let totalArea = 0;
  worktops.forEach(w => {
    totalArea += w.length * w.depth;
    // Add stepout area if present
    if (w.stepout) {
      totalArea += w.stepout.length * w.stepout.depth;
    }
  });
  upstands.forEach(u => {
    const h = u.isWindowCill ? (u.depth || 200) : u.height;
    totalArea += u.length * h;
  });
  
  const slabArea = SLAB_W * SLAB_H;
  return Math.max(1, Math.ceil(totalArea / (slabArea * 0.7)));
}

// Accurate slab count using EXACT same algorithm as renderSlabLayout
function getAccurateSlabCount() {
  const slabWInput = document.getElementById('slabWidthInput');
  const slabHInput = document.getElementById('slabHeightInput');
  const SLAB_W = slabWInput ? parseInt(slabWInput.value) || 3200 : 3200;
  const SLAB_H = slabHInput ? parseInt(slabHInput.value) || 1600 : 1600;
  
  // Clear suggestions
  slabOptimizationSuggestions = [];
  
  // Collect all pieces with names (same as renderSlabLayout)
  const pieces = [];
  
  worktops.forEach(w => {
    if (w.splits && w.splits.length > 0) {
      const verticalSplits = w.splits.filter(s => s.direction === 'vertical').sort((a, b) => a.position - b.position);
      const horizontalSplits = w.splits.filter(s => s.direction === 'horizontal').sort((a, b) => a.position - b.position);
      
      if (verticalSplits.length > 0) {
        let prevPos = 0;
        verticalSplits.forEach((split, i) => {
          pieces.push({ width: split.position - prevPos, height: w.depth, type: 'worktop', name: `${w.name || 'Worktop'} (${i+1})` });
          prevPos = split.position;
        });
        pieces.push({ width: w.length - prevPos, height: w.depth, type: 'worktop', name: `${w.name || 'Worktop'} (${verticalSplits.length+1})` });
      } else if (horizontalSplits.length > 0) {
        let prevPos = 0;
        horizontalSplits.forEach((split, i) => {
          pieces.push({ width: w.length, height: split.position - prevPos, type: 'worktop', name: `${w.name || 'Worktop'} (${i+1})` });
          prevPos = split.position;
        });
        pieces.push({ width: w.length, height: w.depth - prevPos, type: 'worktop', name: `${w.name || 'Worktop'} (${horizontalSplits.length+1})` });
      }
    } else {
      // No splits - if stepout, use bounding box
      let pw = w.length;
      let ph = w.depth;
      if (w.stepout) {
        const isVertical = w.depth > w.length;
        if (isVertical) {
          pw = w.length + w.stepout.depth;
        } else {
          ph = w.depth + w.stepout.depth;
        }
      }
      pieces.push({ width: pw, height: ph, type: 'worktop', name: w.name || 'Worktop' });
    }
    
    // DON'T add stepout as separate piece - included in bounding box
    
    // Add dropdowns
    if (w.edgeTypes) {
      Object.entries(w.edgeTypes).forEach(([k, v]) => {
        if (v.type === 'dropdown' || v.type === 'mitred_edge') {
          const [, s, e] = k.split('_');
          pieces.push({ width: parseInt(e) - parseInt(s), height: v.height, type: 'dropdown', name: 'Dropdown' });
        }
      });
    }
  });
  
  // Add upstands, splashbacks, cills - DON'T pre-split, will check during placement
  upstands.forEach(u => {
    const ph = u.isWindowCill ? (u.depth || 200) : u.height;
    if (u.length >= 10 && ph >= 10) {
      const typeName = u.isWindowCill ? 'Window Cill' : (u.isSplash ? 'Splashback' : 'Upstand');
      const pieceType = u.isSplash ? 'splash' : (u.isWindowCill ? 'cill' : 'upstand');
      
      pieces.push({ 
        width: u.length, 
        height: ph, 
        type: pieceType, 
        name: typeName,
        upstandRef: u // Reference to original upstand for auto-split marking
      });
    }
  });
  
  if (pieces.length === 0) return 0;
  
  // Sort by area descending (same as renderSlabLayout)
  const sortedPieces = [...pieces].sort((a, b) => (b.width * b.height) - (a.width * a.height));
  
  // === EXACT COPY of renderSlabLayout algorithm ===
  const slabs = [];
  
  function createSlab() {
    return { freeRects: [{ x: 0, y: 0, w: SLAB_W, h: SLAB_H }], pieces: [] };
  }
  
  function rectsOverlap(a, b) {
    return !(a.x >= b.x + b.w || a.x + a.w <= b.x || 
             a.y >= b.y + b.h || a.y + a.h <= b.y);
  }
  
  function isContained(inner, outer) {
    return inner.x >= outer.x && inner.y >= outer.y &&
           inner.x + inner.w <= outer.x + outer.w &&
           inner.y + inner.h <= outer.y + outer.h;
  }
  
  function pruneRects(rects) {
    const result = [];
    for (let i = 0; i < rects.length; i++) {
      let dominated = false;
      for (let j = 0; j < rects.length; j++) {
        if (i !== j && isContained(rects[i], rects[j])) {
          dominated = true;
          break;
        }
      }
      if (!dominated && rects[i].w > 0 && rects[i].h > 0) {
        result.push(rects[i]);
      }
    }
    return result;
  }
  
  function findBestRect(slab, pw, ph) {
    let bestScore = Infinity;
    let bestRect = null;
    let bestRotated = false;
    
    for (const rect of slab.freeRects) {
      // Normal orientation
      if (pw <= rect.w && ph <= rect.h) {
        let score = (rect.w - pw) + (rect.h - ph);
        if (ph > pw) score += 500000; // Penalty for vertical
        if (score < bestScore) {
          bestScore = score;
          bestRect = rect;
          bestRotated = false;
        }
      }
      
      // Rotated
      if (pw !== ph && ph <= rect.w && pw <= rect.h) {
        let score = (rect.w - ph) + (rect.h - pw);
        if (pw > ph) score += 500000; // Penalty for vertical after rotation
        if (score < bestScore) {
          bestScore = score;
          bestRect = rect;
          bestRotated = true;
        }
      }
    }
    
    return bestRect ? { rect: bestRect, rotated: bestRotated } : null;
  }
  
  function placePiece(slab, rect, pw, ph, rotated) {
    const actualW = rotated ? ph : pw;
    const actualH = rotated ? pw : ph;
    
    const placed = { x: rect.x, y: rect.y, w: actualW, h: actualH };
    
    const newRects = [];
    
    for (const freeRect of slab.freeRects) {
      if (rectsOverlap(freeRect, placed)) {
        // Right of placed
        if (placed.x + placed.w < freeRect.x + freeRect.w) {
          newRects.push({
            x: placed.x + placed.w,
            y: freeRect.y,
            w: freeRect.x + freeRect.w - (placed.x + placed.w),
            h: freeRect.h
          });
        }
        // Left of placed
        if (placed.x > freeRect.x) {
          newRects.push({
            x: freeRect.x,
            y: freeRect.y,
            w: placed.x - freeRect.x,
            h: freeRect.h
          });
        }
        // Below placed
        if (placed.y + placed.h < freeRect.y + freeRect.h) {
          newRects.push({
            x: freeRect.x,
            y: placed.y + placed.h,
            w: freeRect.w,
            h: freeRect.y + freeRect.h - (placed.y + placed.h)
          });
        }
        // Above placed
        if (placed.y > freeRect.y) {
          newRects.push({
            x: freeRect.x,
            y: freeRect.y,
            w: freeRect.w,
            h: placed.y - freeRect.y
          });
        }
      } else {
        newRects.push(freeRect);
      }
    }
    
    slab.freeRects = pruneRects(newRects);
    return placed;
  }
  
  function tryPlacePiece(slab, pw, ph) {
    const best = findBestRect(slab, pw, ph);
    if (!best) return null;
    return placePiece(slab, best.rect, pw, ph, best.rotated);
  }
  
  // Check if a piece can fit on any existing slab
  function canFitOnExistingSlabs(pw, ph) {
    for (const slab of slabs) {
      if (findBestRect(slab, pw, ph)) return true;
    }
    return false;
  }
  
  // Track placed upstands so we can potentially swap splits to longer ones
  const placedUpstands = [];
  let needsRepack = false;
  
  // Place all pieces and track which cause new slabs
  sortedPieces.forEach(piece => {
    const pw = piece.width;
    const ph = piece.height;
    
    // Check if fits
    const fitsNormal = (pw <= SLAB_W && ph <= SLAB_H);
    const fitsRotated = (ph <= SLAB_W && pw <= SLAB_H);
    
    if (!fitsNormal && !fitsRotated) {
      slabs.push(createSlab()); // Oversized
      return;
    }
    
    // Try existing slabs
    let placed = null;
    for (const slab of slabs) {
      placed = tryPlacePiece(slab, pw, ph);
      if (placed) break;
    }
    
    // Track placed upstands for potential swap
    if (placed && ['upstand', 'splash', 'cill'].includes(piece.type) && piece.upstandRef) {
      placedUpstands.push({ piece, pw, ph });
    }
    
    // Need new slab - but check if we can AUTO-SPLIT to avoid it
    if (!placed) {
      // Only try auto-split for upstands/splashbacks/cills that are long enough
      const canSplit = ['upstand', 'splash', 'cill'].includes(piece.type) && 
                       piece.upstandRef && 
                       pw > 1000; // Only split if > 1000mm
      
      if (canSplit) {
        // First check if splitting THIS piece would save a slab
        const halfLen = Math.floor((pw - 3) / 2);
        const piece1W = halfLen;
        const piece2W = pw - halfLen - 3; // 3mm joint
        
        const half1Fits = canFitOnExistingSlabs(piece1W, ph);
        const half2Fits = canFitOnExistingSlabs(piece2W, ph);
        
        if (half1Fits && half2Fits) {
          // Splitting this piece would save a slab!
          // But check if there's a LONGER upstand we could split instead
          // (prefer joint on longer piece for aesthetics)
          const longerCandidate = placedUpstands
            .filter(p => p.piece.type === piece.type && p.pw > pw && !p.piece.upstandRef.autoSplitPos)
            .sort((a, b) => b.pw - a.pw)[0];
          
          if (longerCandidate) {
            // Check if splitting the longer one would ALSO let this piece fit
            const longerW = longerCandidate.pw;
            const longerHalf = Math.floor((longerW - 3) / 2);
            const longer1Fits = canFitOnExistingSlabs(longerHalf, longerCandidate.ph);
            const longer2Fits = canFitOnExistingSlabs(longerW - longerHalf - 3, longerCandidate.ph);
            
            // If splitting longer would also work, prefer that
            if (longer1Fits && longer2Fits) {
              longerCandidate.piece.upstandRef.autoSplitPos = longerHalf;
              console.log(`Auto-split LONGER ${longerCandidate.piece.name}: ${longerW}mm (instead of ${pw}mm) - prefer longer`);
              needsRepack = true;
              return;
            }
          }
          
          // No longer candidate that works, split this piece
          piece.upstandRef.autoSplitPos = halfLen;
          console.log(`Auto-split ${piece.name}: ${pw}mm ‚Üí ${piece1W}mm + ${piece2W}mm (saves a slab)`);
          needsRepack = true;
          return;
        }
      }
      
      // Couldn't avoid new slab
      const newSlabNum = slabs.length + 1;
      const newSlab = createSlab();
      placed = tryPlacePiece(newSlab, pw, ph);
      if (placed) {
        slabs.push(newSlab);
        
        // Generate suggestion for the piece that caused this new slab
        // Only keep suggestion for the HIGHEST slab (most relevant)
        const maxDim = Math.max(pw, ph);
        if (newSlabNum >= 2 && maxDim > 1500) {
          // Clear previous suggestions - only care about the latest slab increase
          slabOptimizationSuggestions = [];
          
          if (['upstand', 'splash', 'cill'].includes(piece.type)) {
            // Only suggest if splitting would actually help (we already tried auto-split above)
            // If we're here, auto-split didn't work, so don't suggest it
            // (The auto-split check happens earlier and returns if successful)
            const halfLen = Math.floor((pw - 3) / 2);
            const half1Fits = canFitOnExistingSlabs(halfLen, ph);
            const half2Fits = canFitOnExistingSlabs(pw - halfLen - 3, ph);
            
            if (half1Fits && half2Fits) {
              // This shouldn't happen since auto-split should have caught it
              slabOptimizationSuggestions.push({
                piece: piece,
                message: `${piece.name} (${maxDim}mm) pushed design to slab ${newSlabNum}. Splitting it could save a slab.`,
                type: piece.type
              });
            }
            // If splitting wouldn't help, don't mislead the user
          } else if (piece.type === 'worktop' && maxDim > SLAB_W * 0.6) {
            // Only suggest join if splitting would actually help
            // Check if two halves would fit on existing slabs
            const halfW = Math.floor((pw - 3) / 2);
            const half1Fits = canFitOnExistingSlabs(halfW, ph);
            const half2Fits = canFitOnExistingSlabs(pw - halfW - 3, ph);
            
            if (half1Fits && half2Fits) {
              slabOptimizationSuggestions.push({
                piece: piece,
                message: `${piece.name} (${maxDim}mm) pushed design to slab ${newSlabNum}. Adding a join could save a slab.`,
                type: piece.type
              });
            }
            // If splitting wouldn't help, don't show any suggestion
          } else if (piece.type === 'dropdown') {
            // Dropdowns can't really be split, so just note it pushed to new slab
            // Don't suggest anything since there's no action user can take
          }
        }
      }
    }
  });
  
  // Repack with auto-splits applied (may need multiple passes)
  let repackIteration = 0;
  const MAX_REPACK = 5;
  
  while (needsRepack && repackIteration < MAX_REPACK) {
    repackIteration++;
    needsRepack = false;
    
    // Rebuild pieces with splits
    const repackPieces = [];
    sortedPieces.forEach(p => {
      if (['upstand', 'splash', 'cill'].includes(p.type) && p.upstandRef && p.upstandRef.autoSplitPos) {
        const splitPos = p.upstandRef.autoSplitPos;
        repackPieces.push({ ...p, width: splitPos, name: `${p.name} (1/2)`, autoSplit: true });
        repackPieces.push({ ...p, width: p.width - splitPos - 3, name: `${p.name} (2/2)`, autoSplit: true });
      } else {
        repackPieces.push(p);
      }
    });
    
    repackPieces.sort((a, b) => (b.width * b.height) - (a.width * a.height));
    slabs.length = 0;
    const repackPlaced = [];
    
    repackPieces.forEach(piece => {
      const pw = piece.width, ph = piece.height;
      const fitsNormal = (pw <= SLAB_W && ph <= SLAB_H);
      const fitsRotated = (ph <= SLAB_W && pw <= SLAB_H);
      
      if (!fitsNormal && !fitsRotated) {
        slabs.push(createSlab());
        return;
      }
      
      let placed = null;
      for (const slab of slabs) {
        placed = tryPlacePiece(slab, pw, ph);
        if (placed) break;
      }
      
      if (placed && ['upstand', 'splash', 'cill'].includes(piece.type) && piece.upstandRef && !piece.autoSplit) {
        repackPlaced.push({ piece, pw, ph });
      }
      
      if (!placed) {
        const canSplit = ['upstand', 'splash', 'cill'].includes(piece.type) && 
                         piece.upstandRef && !piece.autoSplit && pw > 1000;
        
        if (canSplit && slabs.length > 0) {
          const halfLen = Math.floor((pw - 3) / 2);
          const half1Fits = canFitOnExistingSlabs(halfLen, ph);
          const half2Fits = canFitOnExistingSlabs(pw - halfLen - 3, ph);
          
          if (half1Fits && half2Fits) {
            // Check for longer candidate
            const longerCandidate = repackPlaced
              .filter(p => p.piece.type === piece.type && p.pw > pw && !p.piece.upstandRef.autoSplitPos)
              .sort((a, b) => b.pw - a.pw)[0];
            
            if (longerCandidate) {
              const longerW = longerCandidate.pw;
              const longerHalf = Math.floor((longerW - 3) / 2);
              if (canFitOnExistingSlabs(longerHalf, longerCandidate.ph) && 
                  canFitOnExistingSlabs(longerW - longerHalf - 3, longerCandidate.ph)) {
                longerCandidate.piece.upstandRef.autoSplitPos = longerHalf;
                needsRepack = true;
                return;
              }
            }
            
            piece.upstandRef.autoSplitPos = halfLen;
            needsRepack = true;
            return;
          }
        }
        
        const newSlab = createSlab();
        placed = tryPlacePiece(newSlab, pw, ph);
        if (placed) slabs.push(newSlab);
      }
    });
  }
  
  // Update the warning display
  updateSlabWarning(slabs.length);
  
  return slabs.length;
}

// Enable slab warnings after page load
function enableSlabWarnings() {
  isPageLoading = false;
  console.log('Slab warnings enabled');
}

// Reset warning flag if user reduced slabs (so warning can show again)
function resetSlabWarningIfNeeded(currentSlabCount) {
  if (currentSlabCount < lastKnownSlabCount) {
    hasShownSlabWarning = false;
    sessionStorage.setItem('hasShownSlabWarning', 'false');
  }
  lastKnownSlabCount = currentSlabCount;
  sessionStorage.setItem('lastKnownSlabCount', currentSlabCount.toString());
}

function updateSlabWarning(currentSlabCount) {
  const warningDiv = document.getElementById('slabWarning');
  const warningText = document.getElementById('slabWarningText');
  
  // Update sidebar warning only
  if (warningDiv && warningText) {
    if (slabOptimizationSuggestions.length > 0 && currentSlabCount >= 2) {
      warningDiv.style.display = 'block';
      let html = '';
      slabOptimizationSuggestions.forEach(s => {
        html += `<div style="margin-bottom:4px;">‚Ä¢ ${s.message}</div>`;
      });
      warningText.innerHTML = html;
    } else {
      warningDiv.style.display = 'none';
    }
  }
}

function showSlabOptimizationPopup(slabCount) {
  const modal = document.getElementById('slabOptimizationModal');
  const content = document.getElementById('slabOptimizationContent');
  
  if (!modal || !content) {
    // Fallback to alert if modal not found
    alert('üí° Your design now requires ' + slabCount + ' slabs.\n\nConsider adding joins to long pieces to reduce material costs.\n\nClick on a worktop edge and select "Add Split/Join Here".');
    return;
  }
  
  let html = `<p style="margin-bottom:12px;"><strong>Your design now requires ${slabCount} slabs.</strong></p>`;
  
  if (slabOptimizationSuggestions.length > 0) {
    html += '<p style="margin-bottom:8px;">These pieces may benefit from splitting:</p>';
    html += '<ul style="margin:0;padding-left:20px;">';
    slabOptimizationSuggestions.forEach(s => {
      html += `<li style="margin-bottom:6px;">${s.message}</li>`;
    });
    html += '</ul>';
  } else {
    html += '<p>Consider adding joins to long pieces (worktops, upstands, splashbacks) to fit more on each slab and reduce material costs.</p>';
  }
  
  content.innerHTML = html;
  modal.style.display = 'flex';
}

function closeSlabOptimizationModal() {
  const modal = document.getElementById('slabOptimizationModal');
  if (modal) modal.style.display = 'none';
}

// ========== 3D VIEW ==========
let scene, camera, renderer, controls;
let materialTextures = {};  // Cache loaded textures

// Helper function to get crop settings for a material
function getTextureCropConfig(materialKey) {
  // Check for material-specific override first
  if (MATERIAL_CROP_OVERRIDE && MATERIAL_CROP_OVERRIDE[materialKey]) {
    return MATERIAL_CROP_OVERRIDE[materialKey];
  }
  // Fall back to brand default
  const mat = MATERIAL_COLORS[materialKey];
  if (mat && mat.brand && TEXTURE_CROP_CONFIG[mat.brand]) {
    return TEXTURE_CROP_CONFIG[mat.brand];
  }
  return TEXTURE_CROP_CONFIG['default'];
}

// Load material texture from Google Drive
function loadMaterialTexture(materialKey, callback) {
  const mat = MATERIAL_COLORS[materialKey];
  if (!mat || !mat.textureId) {
    console.log('No texture ID for', materialKey);
    callback(null);
    return;
  }
  
  // Check cache first
  if (materialTextures[materialKey]) {
    callback(materialTextures[materialKey]);
    return;
  }
  
  // Use lh3.googleusercontent.com format (works for Google Drive images)
  const url = `https://lh3.googleusercontent.com/d/${mat.textureId}`;
  console.log('Loading texture from:', url);
  
  // Get crop config for this material's brand
  const cropConfig = getTextureCropConfig(materialKey);
  console.log('Crop config for', materialKey, ':', cropConfig);
  
  // First test if image loads at all
  const testImg = new Image();
  testImg.crossOrigin = 'anonymous';
  testImg.onload = function() {
    console.log('Test image loaded for', materialKey, '- now loading as texture');
    
    const loader = new THREE.TextureLoader();
    loader.crossOrigin = 'anonymous';
    
    loader.load(
      url,
      function(texture) {
        console.log('‚úì Texture loaded successfully for', materialKey);
        texture.wrapS = THREE.RepeatWrapping;
        texture.wrapT = THREE.RepeatWrapping;
        
        // Apply crop offset and repeat (for brands with borders/text in images)
        if (cropConfig.crop > 0) {
          texture.offset.set(cropConfig.offset, cropConfig.offset);
          texture.repeat.set(cropConfig.repeat * 0.0003, cropConfig.repeat * 0.0003);  // Scale for mm dimensions
          console.log('  Applied', (cropConfig.crop * 100) + '% crop for', materialKey);
        } else {
          texture.repeat.set(0.0003, 0.0003);  // Scale for mm dimensions
        }
        
        materialTextures[materialKey] = texture;
        callback(texture);
      },
      undefined,
      function(err) {
        console.error('THREE.js texture load failed for', materialKey, err);
        callback(null);
      }
    );
  };
  testImg.onerror = function() {
    console.error('‚úó Image failed to load for', materialKey, '- URL:', url);
    console.log('Falling back to color');
    callback(null);
  };
  testImg.src = url;
}

// Get material for 3D rendering - creates new material each time but uses cached texture
function getMaterial3D() {
  // Check for custom material first
  if (customMaterial.active && customMaterial.texture) {
    console.log('getMaterial3D using custom material texture:', customMaterial.name);
    // Clone the texture for this material
    const newTexture = customMaterial.texture.clone();
    newTexture.wrapS = THREE.RepeatWrapping;
    newTexture.wrapT = THREE.RepeatWrapping;
    newTexture.repeat.set(0.0003, 0.0003);  // Scale for mm dimensions
    newTexture.needsUpdate = true;
    return new THREE.MeshStandardMaterial({ 
      map: newTexture,
      roughness: 0.3,
      side: THREE.DoubleSide
    });
  } else if (customMaterial.active) {
    console.log('Custom material active but texture not loaded yet, using fallback color');
    return new THREE.MeshStandardMaterial({ 
      color: 0xd4a574,  // Brown stone color
      roughness: 0.3,
      side: THREE.DoubleSide
    });
  }
  
  const matColor = MATERIAL_COLORS[selectedMaterial] || MATERIAL_COLORS.white_storm;
  const texture = materialTextures[selectedMaterial];
  const cropConfig = getTextureCropConfig(selectedMaterial);
  
  console.log('getMaterial3D called - selectedMaterial:', selectedMaterial, 'texture exists:', !!texture, 'image:', texture?.image ? 'loaded' : 'not loaded');
  
  if (texture && texture.image) {
    // Create a NEW texture from the same image for proper UV mapping
    const newTexture = new THREE.Texture(texture.image);
    newTexture.wrapS = THREE.RepeatWrapping;
    newTexture.wrapT = THREE.RepeatWrapping;
    
    // Apply crop offset and repeat based on brand
    if (cropConfig.crop > 0) {
      newTexture.offset.set(cropConfig.offset, cropConfig.offset);
      newTexture.repeat.set(cropConfig.repeat * 0.0003, cropConfig.repeat * 0.0003);
    } else {
      newTexture.repeat.set(0.0003, 0.0003);  // Scale for mm dimensions
    }
    newTexture.needsUpdate = true;
    return new THREE.MeshStandardMaterial({ 
      map: newTexture,
      roughness: matColor.roughness,
      side: THREE.DoubleSide
    });
  } else {
    // Fallback to color
    console.log('  -> Using fallback color:', matColor.color);
    return new THREE.MeshStandardMaterial({ 
      color: matColor.color, 
      roughness: matColor.roughness,
      side: THREE.DoubleSide
    });
  }
}

// Get material for upstands/splashbacks - scale texture appropriately
function getMaterial3DForUpstand(upstandLength, upstandHeight) {
  // Check for custom material first
  if (customMaterial.active && customMaterial.texture) {
    const newTexture = customMaterial.texture.clone();
    newTexture.wrapS = THREE.RepeatWrapping;
    newTexture.wrapT = THREE.RepeatWrapping;
    const scaleX = (upstandLength || 1000) / 3200;
    const scaleY = (upstandHeight || 100) / 1600;
    newTexture.repeat.set(scaleX, scaleY);
    newTexture.needsUpdate = true;
    return new THREE.MeshStandardMaterial({ 
      map: newTexture,
      roughness: 0.3,
      emissive: 0x222222,
      emissiveIntensity: 0.3,
      side: THREE.DoubleSide
    });
  } else if (customMaterial.active) {
    return new THREE.MeshStandardMaterial({ 
      color: 0xd4a574,
      roughness: 0.3,
      emissive: 0x222222,
      emissiveIntensity: 0.3,
      side: THREE.DoubleSide
    });
  }
  
  const matColor = MATERIAL_COLORS[selectedMaterial] || MATERIAL_COLORS.white_storm;
  const texture = materialTextures[selectedMaterial];
  const cropConfig = getTextureCropConfig(selectedMaterial);
  
  if (texture && texture.image) {
    // Create a NEW texture from the same image
    const newTexture = new THREE.Texture(texture.image);
    newTexture.wrapS = THREE.RepeatWrapping;
    newTexture.wrapT = THREE.RepeatWrapping;
    
    // For BoxGeometry, UVs go 0-1 on each face
    // Scale texture based on slab size (3200x1600) so it matches worktop
    const scaleX = (upstandLength || 1000) / 3200;
    const scaleY = (upstandHeight || 100) / 1600;
    
    // Apply crop offset and repeat based on brand
    if (cropConfig.crop > 0) {
      newTexture.offset.set(cropConfig.offset, cropConfig.offset);
      newTexture.repeat.set(scaleX * cropConfig.repeat, scaleY * cropConfig.repeat);
    } else {
      newTexture.repeat.set(scaleX, scaleY);
    }
    newTexture.needsUpdate = true;
    
    return new THREE.MeshStandardMaterial({ 
      map: newTexture,
      roughness: matColor.roughness,
      emissive: 0x222222,
      emissiveIntensity: 0.3,
      side: THREE.DoubleSide
    });
  } else {
    return new THREE.MeshStandardMaterial({ 
      color: matColor.color, 
      roughness: matColor.roughness,
      emissive: 0x222222,
      emissiveIntensity: 0.3,
      side: THREE.DoubleSide
    });
  }
}

// Get material for window cills - horizontal surface like worktop
function getMaterial3DForCill(cillLength, cillDepth) {
  // Check for custom material first
  if (customMaterial.active && customMaterial.texture) {
    const newTexture = customMaterial.texture.clone();
    newTexture.wrapS = THREE.RepeatWrapping;
    newTexture.wrapT = THREE.RepeatWrapping;
    const scaleX = (cillLength || 1000) / 3200;
    const scaleY = (cillDepth || 200) / 1600;
    newTexture.repeat.set(scaleX, scaleY);
    newTexture.needsUpdate = true;
    return new THREE.MeshStandardMaterial({ 
      map: newTexture,
      roughness: 0.3,
      side: THREE.DoubleSide
    });
  } else if (customMaterial.active) {
    return new THREE.MeshStandardMaterial({ 
      color: 0xd4a574,
      roughness: 0.3,
      side: THREE.DoubleSide
    });
  }
  
  const matColor = MATERIAL_COLORS[selectedMaterial] || MATERIAL_COLORS.white_storm;
  const texture = materialTextures[selectedMaterial];
  const cropConfig = getTextureCropConfig(selectedMaterial);
  
  if (texture && texture.image) {
    const newTexture = new THREE.Texture(texture.image);
    newTexture.wrapS = THREE.RepeatWrapping;
    newTexture.wrapT = THREE.RepeatWrapping;
    
    // For BoxGeometry, UVs go 0-1 on each face
    // Scale texture based on slab size (3200x1600) so it matches worktop
    const scaleX = (cillLength || 1000) / 3200;
    const scaleY = (cillDepth || 200) / 1600;
    
    // Apply crop offset and repeat based on brand
    if (cropConfig.crop > 0) {
      newTexture.offset.set(cropConfig.offset, cropConfig.offset);
      newTexture.repeat.set(scaleX * cropConfig.repeat, scaleY * cropConfig.repeat);
    } else {
      newTexture.repeat.set(scaleX, scaleY);
    }
    newTexture.needsUpdate = true;
    
    return new THREE.MeshStandardMaterial({ 
      map: newTexture,
      roughness: matColor.roughness,
      side: THREE.DoubleSide
    });
  } else {
    return new THREE.MeshStandardMaterial({ 
      color: matColor.color, 
      roughness: matColor.roughness,
      side: THREE.DoubleSide
    });
  }
}

// Get material for dropdowns - vertical surface
function getMaterial3DForDropdown(dropdownLength, dropdownHeight) {
  // Check for custom material first
  if (customMaterial.active && customMaterial.texture) {
    const newTexture = customMaterial.texture.clone();
    newTexture.wrapS = THREE.RepeatWrapping;
    newTexture.wrapT = THREE.RepeatWrapping;
    const scaleX = (dropdownLength || 1000) / 3200;
    const scaleY = (dropdownHeight || 100) / 1600;
    newTexture.repeat.set(scaleX, scaleY);
    newTexture.needsUpdate = true;
    return new THREE.MeshStandardMaterial({ 
      map: newTexture,
      roughness: 0.3,
      side: THREE.DoubleSide
    });
  } else if (customMaterial.active) {
    return new THREE.MeshStandardMaterial({ 
      color: 0xd4a574,
      roughness: 0.3,
      side: THREE.DoubleSide
    });
  }
  
  const matColor = MATERIAL_COLORS[selectedMaterial] || MATERIAL_COLORS.white_storm;
  const texture = materialTextures[selectedMaterial];
  const cropConfig = getTextureCropConfig(selectedMaterial);
  
  if (texture && texture.image) {
    const newTexture = new THREE.Texture(texture.image);
    newTexture.wrapS = THREE.RepeatWrapping;
    newTexture.wrapT = THREE.RepeatWrapping;
    
    // For BoxGeometry, UVs go 0-1 on each face
    // Scale texture based on slab size (3200x1600) so it matches worktop
    const scaleX = (dropdownLength || 1000) / 3200;
    const scaleY = (dropdownHeight || 900) / 1600;
    
    // Apply crop offset and repeat based on brand
    if (cropConfig.crop > 0) {
      newTexture.offset.set(cropConfig.offset, cropConfig.offset);
      newTexture.repeat.set(scaleX * cropConfig.repeat, scaleY * cropConfig.repeat);
    } else {
      newTexture.repeat.set(scaleX, scaleY);
    }
    newTexture.needsUpdate = true;
    
    return new THREE.MeshStandardMaterial({ 
      map: newTexture,
      roughness: matColor.roughness,
      side: THREE.DoubleSide
    });
  } else {
    return new THREE.MeshStandardMaterial({ 
      color: matColor.color, 
      roughness: matColor.roughness,
      side: THREE.DoubleSide
    });
  }
}

function init3D() {
  const container3d = document.getElementById('canvas3d');
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0xe8ecef);
  
  camera = new THREE.PerspectiveCamera(50, container3d.clientWidth / container3d.clientHeight, 1, 50000);
  camera.position.set(2000, 2500, 3000);
  camera.lookAt(0, 0, 0);
  
  renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
  renderer.setSize(container3d.clientWidth, container3d.clientHeight);
  renderer.shadowMap.enabled = true;
  container3d.appendChild(renderer.domElement);
  
  // Lights - reduced intensity for more natural appearance of white materials
  const ambient = new THREE.AmbientLight(0xffffff, 0.4);
  scene.add(ambient);
  const dir = new THREE.DirectionalLight(0xffffff, 0.6);
  dir.position.set(1000, 3000, 1500);
  dir.castShadow = true;
  scene.add(dir);
  
  // Floor - lower it so dropdowns are visible
  const floor = new THREE.Mesh(
    new THREE.PlaneGeometry(15000, 15000),
    new THREE.MeshStandardMaterial({ color: 0xaaaaaa })
  );
  floor.rotation.x = -Math.PI / 2;
  floor.position.y = -1000; // Floor 1m below worktops
  floor.receiveShadow = true;
  scene.add(floor);
  
  // Pre-load current material texture
  loadMaterialTexture(selectedMaterial, () => {
    render3D();
  });
  
  // Simple orbit with mouse
  let isDragging3d = false, prevMouse = { x: 0, y: 0 };
  renderer.domElement.addEventListener('mousedown', e => { isDragging3d = true; prevMouse = { x: e.clientX, y: e.clientY }; });
  renderer.domElement.addEventListener('mouseup', () => isDragging3d = false);
  renderer.domElement.addEventListener('mouseleave', () => isDragging3d = false);
  renderer.domElement.addEventListener('mousemove', e => {
    if (!isDragging3d) return;
    const dx = e.clientX - prevMouse.x, dy = e.clientY - prevMouse.y;
    // Horizontal rotation
    camera.position.applyAxisAngle(new THREE.Vector3(0, 1, 0), -dx * 0.005);
    // Vertical rotation (limited)
    const currentY = camera.position.y;
    camera.position.y = Math.max(500, Math.min(5000, currentY - dy * 5));
    camera.lookAt(0, 0, 0);
    prevMouse = { x: e.clientX, y: e.clientY };
  });
  renderer.domElement.addEventListener('wheel', e => {
    const factor = e.deltaY > 0 ? 1.1 : 0.9;
    camera.position.multiplyScalar(factor);
    camera.position.y = Math.max(500, camera.position.y);
  });
}

function render3D() {
  console.log('render3D called, worktops:', worktops.length, 'upstands:', upstands.length, 'cutouts:', cutouts.length);
  
  // Load custom material texture if active but not yet loaded
  if (customMaterial.active && customMaterial.imageData && !customMaterial.texture) {
    console.log('Loading custom material texture for 3D...');
    const loader = new THREE.TextureLoader();
    loader.load(customMaterial.imageData, function(texture) {
      console.log('Custom material texture loaded in render3D');
      customMaterial.texture = texture;
      texture.wrapS = THREE.RepeatWrapping;
      texture.wrapT = THREE.RepeatWrapping;
      // Re-render with texture now loaded
      render3D();
    }, undefined, function(err) {
      console.error('Failed to load custom material texture:', err);
    });
    return; // Wait for texture to load
  }
  
  // Clear old meshes (keep lights and floor)
  while (scene.children.length > 3) scene.remove(scene.children[3]);
  
  // Center offset
  let cx = 0, cz = 0;
  if (worktops.length > 0) {
    let minX = Infinity, maxX = -Infinity, minZ = Infinity, maxZ = -Infinity;
    worktops.forEach(w => {
      minX = Math.min(minX, w.x); maxX = Math.max(maxX, w.x + w.length);
      minZ = Math.min(minZ, w.y); maxZ = Math.max(maxZ, w.y + w.depth);
    });
    cx = (minX + maxX) / 2;
    cz = (minZ + maxZ) / 2;
    console.log('3D center offset:', cx, cz);
  } else {
    console.log('No worktops to render in 3D');
  }
  
  const WORKTOP_THICKNESS = worktopThickness; // Use global setting (20mm or 30mm)
  const WORKTOP_Y = 0; // Worktop top surface at Y=0
  
  // Worktops - create with cutout holes using ExtrudeGeometry
  worktops.forEach(w => {
    // Get cutouts for this worktop (sinks and taps only - they go through)
    const wCutouts = cutouts.filter(c => c.parentId === w.id && 
      (c.type === 'undermount_sink' || c.type === 'overmount_sink' || c.type === 'tap'));
    
    // Get corner radii
    // In 2D: tl=back-left, tr=back-right, br=front-right, bl=front-left
    const radii = w.cornerRadii || { tl: 0, tr: 0, br: 0, bl: 0 };
    
    // Check if this is a vertical worktop (taller than wide in 2D view)
    const isVerticalWorktop = w.depth > w.length;
    
    // Shape coords: X = length, Y = depth
    // After mesh rotation (-PI/2) and flipYtoZ positioning:
    // - Shape's high Y (top) becomes 3D BACK (far from camera)
    // - Shape's low Y (bottom) becomes 3D FRONT (close to camera)
    // So we need to SWAP front/back:
    // - 2D back corners ‚Üí Shape TOP (becomes 3D front)
    // - 2D front corners ‚Üí Shape BOTTOM (becomes 3D back)
    let rShapeBL, rShapeBR, rShapeTR, rShapeTL;
    
    // Correct mapping with Y-flip compensation:
    rShapeTL = radii.tl || 0;  // 2D back-left ‚Üí Shape top-left ‚Üí 3D front-left
    rShapeTR = radii.tr || 0;  // 2D back-right ‚Üí Shape top-right ‚Üí 3D front-right
    rShapeBR = radii.br || 0;  // 2D front-right ‚Üí Shape bottom-right ‚Üí 3D back-right
    rShapeBL = radii.bl || 0;  // 2D front-left ‚Üí Shape bottom-left ‚Üí 3D back-left
    
    // Create worktop shape with rounded corners
    // Shape coords: X = length, Y = depth
    const shape = new THREE.Shape();
    
    // Check for stepout
    const stepout = w.stepout;
    const isVertical = w.depth > w.length;
    
    // Debug corner radii
    const hasRadii = radii.tl > 0 || radii.tr > 0 || radii.br > 0 || radii.bl > 0;
    console.log('3D Worktop:', w.name || w.id, 'hasStepout:', !!stepout, 'hasRadii:', hasRadii, 'dimensions:', w.length, 'x', w.depth);
    if (hasRadii) {
      console.log('  Radii from worktop:', JSON.stringify(radii));
      console.log('  Shape radii mapped: BL=', rShapeBL, 'BR=', rShapeBR, 'TR=', rShapeTR, 'TL=', rShapeTL);
      if (stepout) {
        console.log('  Stepout corner:', stepout.corner, '- radii will be applied to outer corners only');
      }
    }
    
    if (stepout) {
      // Create L-shape for stepout WITH corner radii on outer corners
      // Inner corners (where L meets) have no radius
      const sLen = stepout.length;
      const sDepth = stepout.depth;
      
      // Standard corner arc angles (counterclockwise path):
      // BL: œÄ to 1.5œÄ, BR: -œÄ/2 to 0, TR: 0 to œÄ/2, TL: œÄ/2 to œÄ
      
      if (isVertical) {
        // VERTICAL worktop - stepout extends left/right (X direction in shape)
        if (stepout.corner === 'front-left') {
          // Stepout extends LEFT from bottom-left
          shape.moveTo(-sDepth + rShapeBL, 0);
          if (rShapeBL > 0) shape.absarc(-sDepth + rShapeBL, rShapeBL, rShapeBL, Math.PI * 1.5, Math.PI, true);
          shape.lineTo(-sDepth, sLen);                 // Up stepout left edge
          shape.lineTo(0, sLen);                       // Right to main (inner corner)
          shape.lineTo(0, w.depth - rShapeTL);         // Up to near top-left
          if (rShapeTL > 0) shape.absarc(rShapeTL, w.depth - rShapeTL, rShapeTL, Math.PI, Math.PI/2, true);
          shape.lineTo(w.length - rShapeTR, w.depth);  // Right to near top-right
          if (rShapeTR > 0) shape.absarc(w.length - rShapeTR, w.depth - rShapeTR, rShapeTR, Math.PI/2, 0, true);
          shape.lineTo(w.length, rShapeBR);            // Down to near bottom-right
          if (rShapeBR > 0) shape.absarc(w.length - rShapeBR, rShapeBR, rShapeBR, 0, -Math.PI/2, true);
          shape.lineTo(0, 0);                          // Left along bottom to inner
          shape.closePath();
        } else if (stepout.corner === 'front-right') {
          // Stepout extends RIGHT from bottom-right
          shape.moveTo(rShapeBL, 0);
          if (rShapeBL > 0) shape.absarc(rShapeBL, rShapeBL, rShapeBL, -Math.PI/2, Math.PI, false);
          shape.lineTo(0, w.depth - rShapeTL);
          if (rShapeTL > 0) shape.absarc(rShapeTL, w.depth - rShapeTL, rShapeTL, Math.PI, Math.PI/2, true);
          shape.lineTo(w.length - rShapeTR, w.depth);
          if (rShapeTR > 0) shape.absarc(w.length - rShapeTR, w.depth - rShapeTR, rShapeTR, Math.PI/2, 0, true);
          shape.lineTo(w.length, sLen);                // Down to stepout inner
          shape.lineTo(w.length + sDepth, sLen);       // Right to stepout outer
          shape.lineTo(w.length + sDepth, rShapeBR);   // Down stepout right edge
          if (rShapeBR > 0) shape.absarc(w.length + sDepth - rShapeBR, rShapeBR, rShapeBR, 0, -Math.PI/2, true);
          shape.closePath();
        } else if (stepout.corner === 'back-left') {
          // Stepout extends LEFT from top-left
          shape.moveTo(rShapeBL, 0);
          if (rShapeBL > 0) shape.absarc(rShapeBL, rShapeBL, rShapeBL, -Math.PI/2, Math.PI, false);
          shape.lineTo(0, w.depth - sLen);             // Up to stepout inner
          shape.lineTo(-sDepth, w.depth - sLen);       // Left to stepout outer
          shape.lineTo(-sDepth, w.depth - rShapeTL);   // Up stepout left edge
          if (rShapeTL > 0) shape.absarc(-sDepth + rShapeTL, w.depth - rShapeTL, rShapeTL, Math.PI, Math.PI/2, true);
          shape.lineTo(w.length - rShapeTR, w.depth);
          if (rShapeTR > 0) shape.absarc(w.length - rShapeTR, w.depth - rShapeTR, rShapeTR, Math.PI/2, 0, true);
          shape.lineTo(w.length, rShapeBR);
          if (rShapeBR > 0) shape.absarc(w.length - rShapeBR, rShapeBR, rShapeBR, 0, -Math.PI/2, true);
          shape.closePath();
        } else if (stepout.corner === 'back-right') {
          // Stepout extends RIGHT from top-right
          shape.moveTo(rShapeBL, 0);
          if (rShapeBL > 0) shape.absarc(rShapeBL, rShapeBL, rShapeBL, -Math.PI/2, Math.PI, false);
          shape.lineTo(0, w.depth - rShapeTL);
          if (rShapeTL > 0) shape.absarc(rShapeTL, w.depth - rShapeTL, rShapeTL, Math.PI, Math.PI/2, true);
          shape.lineTo(w.length, w.depth);             // Right to main top-right (inner)
          shape.lineTo(w.length + sDepth, w.depth);    // Right to stepout outer
          shape.lineTo(w.length + sDepth, w.depth - sLen + rShapeTR); // Down stepout
          if (rShapeTR > 0) shape.absarc(w.length + sDepth - rShapeTR, w.depth - sLen + rShapeTR, rShapeTR, 0, -Math.PI/2, true);
          shape.lineTo(w.length, w.depth - sLen);      // Left to inner
          shape.lineTo(w.length, rShapeBR);
          if (rShapeBR > 0) shape.absarc(w.length - rShapeBR, rShapeBR, rShapeBR, 0, -Math.PI/2, true);
          shape.closePath();
        }
      } else {
        // HORIZONTAL worktop - stepout extends down/up (Y direction in shape)
        if (stepout.corner === 'front-left') {
          // Stepout extends DOWN from front-left
          // Path: stepout BL outer ‚Üí up left of stepout ‚Üí inner corner ‚Üí up main left ‚Üí 
          //       TL corner ‚Üí across top ‚Üí TR corner ‚Üí down right ‚Üí BR corner ‚Üí across front ‚Üí inner ‚Üí close
          shape.moveTo(rShapeBL, -sDepth);             // Start at stepout outer bottom
          if (rShapeBL > 0) shape.absarc(rShapeBL, -sDepth + rShapeBL, rShapeBL, -Math.PI/2, Math.PI, false);
          shape.lineTo(0, 0);                          // Up to inner corner
          shape.lineTo(0, w.depth - rShapeTL);         // Up main left edge
          if (rShapeTL > 0) shape.absarc(rShapeTL, w.depth - rShapeTL, rShapeTL, Math.PI, Math.PI/2, true);
          shape.lineTo(w.length - rShapeTR, w.depth);  // Across top
          if (rShapeTR > 0) shape.absarc(w.length - rShapeTR, w.depth - rShapeTR, rShapeTR, Math.PI/2, 0, true);
          shape.lineTo(w.length, rShapeBR);            // Down right edge
          if (rShapeBR > 0) shape.absarc(w.length - rShapeBR, rShapeBR, rShapeBR, 0, -Math.PI/2, true);
          shape.lineTo(sLen, 0);                       // Left to stepout inner
          shape.lineTo(sLen, -sDepth);                 // Down stepout inner edge
          shape.closePath();
        } else if (stepout.corner === 'front-right') {
          // Stepout extends DOWN from front-right
          shape.moveTo(rShapeBL, 0);                   // Front-left
          if (rShapeBL > 0) shape.absarc(rShapeBL, rShapeBL, rShapeBL, -Math.PI/2, Math.PI, false);
          shape.lineTo(0, w.depth - rShapeTL);         // Up to near back-left
          if (rShapeTL > 0) shape.absarc(rShapeTL, w.depth - rShapeTL, rShapeTL, Math.PI, Math.PI/2, true);
          shape.lineTo(w.length - rShapeTR, w.depth);  // Right to near back-right
          if (rShapeTR > 0) shape.absarc(w.length - rShapeTR, w.depth - rShapeTR, rShapeTR, Math.PI/2, 0, true);
          shape.lineTo(w.length, -sDepth + rShapeBR);  // Down to stepout outer
          if (rShapeBR > 0) shape.absarc(w.length - rShapeBR, -sDepth + rShapeBR, rShapeBR, 0, -Math.PI/2, true);
          shape.lineTo(w.length - sLen, -sDepth);      // Left along stepout bottom
          shape.lineTo(w.length - sLen, 0);            // Up to inner corner
          shape.closePath();
        } else if (stepout.corner === 'back-left') {
          // Stepout extends UP from back-left
          shape.moveTo(rShapeBL, 0);                   // Front-left
          if (rShapeBL > 0) shape.absarc(rShapeBL, rShapeBL, rShapeBL, -Math.PI/2, Math.PI, false);
          shape.lineTo(0, w.depth + sDepth - rShapeTL); // Up to stepout outer
          if (rShapeTL > 0) shape.absarc(rShapeTL, w.depth + sDepth - rShapeTL, rShapeTL, Math.PI, Math.PI/2, true);
          shape.lineTo(sLen, w.depth + sDepth);        // Right along stepout top
          shape.lineTo(sLen, w.depth);                 // Down to inner corner
          shape.lineTo(w.length - rShapeTR, w.depth);  // Right to near back-right
          if (rShapeTR > 0) shape.absarc(w.length - rShapeTR, w.depth - rShapeTR, rShapeTR, Math.PI/2, 0, true);
          shape.lineTo(w.length, rShapeBR);            // Down to near front-right
          if (rShapeBR > 0) shape.absarc(w.length - rShapeBR, rShapeBR, rShapeBR, 0, -Math.PI/2, true);
          shape.closePath();
        } else if (stepout.corner === 'back-right') {
          // Stepout extends UP from back-right
          shape.moveTo(rShapeBL, 0);                   // Front-left
          if (rShapeBL > 0) shape.absarc(rShapeBL, rShapeBL, rShapeBL, -Math.PI/2, Math.PI, false);
          shape.lineTo(0, w.depth - rShapeTL);         // Up to near back-left
          if (rShapeTL > 0) shape.absarc(rShapeTL, w.depth - rShapeTL, rShapeTL, Math.PI, Math.PI/2, true);
          shape.lineTo(w.length - sLen, w.depth);      // Right to inner corner
          shape.lineTo(w.length - sLen, w.depth + sDepth); // Up stepout inner
          shape.lineTo(w.length - rShapeTR, w.depth + sDepth); // Right to near stepout outer
          if (rShapeTR > 0) shape.absarc(w.length - rShapeTR, w.depth + sDepth - rShapeTR, rShapeTR, Math.PI/2, 0, true);
          shape.lineTo(w.length, rShapeBR);            // Down to near front-right
          if (rShapeBR > 0) shape.absarc(w.length - rShapeBR, rShapeBR, rShapeBR, 0, -Math.PI/2, true);
          shape.closePath();
        }
      }
    } else {
      // Standard rectangle with rounded corners
      // Start at bottom-left corner
      shape.moveTo(rShapeBL, 0);
      // Bottom edge to bottom-right
      shape.lineTo(w.length - rShapeBR, 0);
      // Bottom-right corner
      if (rShapeBR > 0) shape.absarc(w.length - rShapeBR, rShapeBR, rShapeBR, -Math.PI/2, 0, false);
      else shape.lineTo(w.length, 0);
      // Right edge to top-right
      shape.lineTo(w.length, w.depth - rShapeTR);
      // Top-right corner
      if (rShapeTR > 0) shape.absarc(w.length - rShapeTR, w.depth - rShapeTR, rShapeTR, 0, Math.PI/2, false);
      else shape.lineTo(w.length, w.depth);
      // Top edge to top-left
      shape.lineTo(rShapeTL, w.depth);
      // Top-left corner
      if (rShapeTL > 0) shape.absarc(rShapeTL, w.depth - rShapeTL, rShapeTL, Math.PI/2, Math.PI, false);
      else shape.lineTo(0, w.depth);
      // Left edge to bottom-left
      shape.lineTo(0, rShapeBL);
      // Bottom-left corner
      if (rShapeBL > 0) shape.absarc(rShapeBL, rShapeBL, rShapeBL, Math.PI, Math.PI * 1.5, false);
      else shape.lineTo(0, 0);
      shape.closePath();
    };
    
    // Add cutout holes to the shape
    // NOTE: The Shape is created with X = w.length, Y = w.depth
    // After rotation.x = -PI/2: Shape X ‚Üí World X, Shape Y ‚Üí World Z
    // For vertical worktops, the cutout position (c.x, c.y) was already placed correctly
    // We need to use the DRAWN dimensions (which may be swapped from stored width/length)
    // isVerticalWorktop already defined above
    
    wCutouts.forEach(c => {
      const hole = new THREE.Path();
      const localX = c.x - w.x;
      
      if (c.type === 'tap') {
        // Circular hole for tap - flip Y coordinate
        const localY = w.depth - (c.y - w.y);
        const r = c.diameter / 2;
        hole.absarc(localX, localY, r, 0, Math.PI * 2, false);
      } else {
        // Rectangular hole for sink
        // The cutout was POSITIONED with swapped dimensions on vertical worktops
        // So we need to calculate the actual bounds from position + stored dims
        // On vertical: drawn X = c.length, drawn Y = c.width
        // On horizontal: drawn X = c.width, drawn Y = c.length
        const holeW = isVerticalWorktop ? c.length : c.width;  // X dimension
        const holeL = isVerticalWorktop ? c.width : c.length;  // Y dimension (becomes Z)
        
        // Calculate Y position in shape coords (flipped)
        const sinkTopY = c.y - w.y;
        const sinkBottomY = sinkTopY + holeL;
        const localY = w.depth - sinkBottomY;
        
        console.log('3D Sink hole:', { isVerticalWorktop, holeW, holeL, localX, localY, storedW: c.width, storedL: c.length });
        
        const rad = Math.min(c.radius || 25, holeW/2, holeL/2);
        hole.moveTo(localX + rad, localY);
        hole.lineTo(localX + holeW - rad, localY);
        hole.absarc(localX + holeW - rad, localY + rad, rad, -Math.PI/2, 0, false);
        hole.lineTo(localX + holeW, localY + holeL - rad);
        hole.absarc(localX + holeW - rad, localY + holeL - rad, rad, 0, Math.PI/2, false);
        hole.lineTo(localX + rad, localY + holeL);
        hole.absarc(localX + rad, localY + holeL - rad, rad, Math.PI/2, Math.PI, false);
        hole.lineTo(localX, localY + rad);
        hole.absarc(localX + rad, localY + rad, rad, Math.PI, Math.PI * 1.5, false);
      }
      shape.holes.push(hole);
    });
    
    // Extrude the shape
    const extrudeSettings = {
      depth: WORKTOP_THICKNESS,
      bevelEnabled: false,
      curveSegments: 16  // More segments for smoother rounded corners
    };
    
    const geo = new THREE.ExtrudeGeometry(shape, extrudeSettings);
    
    // Create material with texture or color
    const mat = getMaterial3D();
    const mesh = new THREE.Mesh(geo, mat);
    
    // Rotate to lie flat (XY shape becomes XZ plane)
    // After rotation.x = -PI/2: local Y -> world -Z, local Z -> world Y
    mesh.rotation.x = -Math.PI / 2;
    
    // Position: we want top surface at WORKTOP_Y
    // Extrusion goes from z=0 to z=THICKNESS in local
    // After rotation, that's y=0 to y=THICKNESS in world (relative to mesh position)
    // So mesh.y + THICKNESS = WORKTOP_Y => mesh.y = WORKTOP_Y - THICKNESS + THICKNESS = WORKTOP_Y
    // But actually extrusion goes BACKWARDS (negative) after rotation
    mesh.position.set(
      w.x - cx,
      WORKTOP_Y - WORKTOP_THICKNESS,
      w.y + w.depth - cz
    );
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    scene.add(mesh);
    
    // Check which edges have dropdowns (mitre) or mitred edges
    const hasDropdown = { back: false, front: false, left: false, right: false };
    if (w.edgeTypes) {
      Object.entries(w.edgeTypes).forEach(([k, v]) => {
        if (v.type === 'dropdown' || v.type === 'mitred_edge') {
          const edge = k.split('_')[0];
          hasDropdown[edge] = true;
        }
      });
    }
    
    // Draw edge lines manually, skipping edges with dropdowns
    const lineMat = new THREE.LineBasicMaterial({ color: 0x999999 });
    const wx = w.x - cx;
    const wz_back = w.y - cz;
    const wz_front = w.y + w.depth - cz;
    const topY = WORKTOP_Y;
    const botY = WORKTOP_Y - WORKTOP_THICKNESS;
    
    // Helper to add a line
    const addLine = (x1, y1, z1, x2, y2, z2) => {
      const lineGeo = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(x1, y1, z1),
        new THREE.Vector3(x2, y2, z2)
      ]);
      scene.add(new THREE.Line(lineGeo, lineMat));
    };
    
    // Top surface edges
    if (!hasDropdown.back) {
      addLine(wx, topY, wz_back, wx + w.length, topY, wz_back); // Back top
    }
    if (!hasDropdown.front) {
      addLine(wx, topY, wz_front, wx + w.length, topY, wz_front); // Front top
    }
    if (!hasDropdown.left) {
      addLine(wx, topY, wz_back, wx, topY, wz_front); // Left top
    }
    if (!hasDropdown.right) {
      addLine(wx + w.length, topY, wz_back, wx + w.length, topY, wz_front); // Right top
    }
    
    // Bottom surface edges
    if (!hasDropdown.back) {
      addLine(wx, botY, wz_back, wx + w.length, botY, wz_back); // Back bottom
    }
    if (!hasDropdown.front) {
      addLine(wx, botY, wz_front, wx + w.length, botY, wz_front); // Front bottom
    }
    if (!hasDropdown.left) {
      addLine(wx, botY, wz_back, wx, botY, wz_front); // Left bottom
    }
    if (!hasDropdown.right) {
      addLine(wx + w.length, botY, wz_back, wx + w.length, botY, wz_front); // Right bottom
    }
    
    // Vertical edges (corners) - only draw if neither adjacent edge has dropdown
    if (!hasDropdown.back && !hasDropdown.left) {
      addLine(wx, topY, wz_back, wx, botY, wz_back); // Back-left vertical
    }
    if (!hasDropdown.back && !hasDropdown.right) {
      addLine(wx + w.length, topY, wz_back, wx + w.length, botY, wz_back); // Back-right vertical
    }
    if (!hasDropdown.front && !hasDropdown.left) {
      addLine(wx, topY, wz_front, wx, botY, wz_front); // Front-left vertical
    }
    if (!hasDropdown.front && !hasDropdown.right) {
      addLine(wx + w.length, topY, wz_front, wx + w.length, botY, wz_front); // Front-right vertical
    }
    
    // Dropdowns - sit directly under worktop edge with mitre
    if (w.edgeTypes) {
      Object.entries(w.edgeTypes).forEach(([k, v]) => {
        if (v.type === 'dropdown' || v.type === 'mitred_edge') {
          // Parse key - handle both normal edges (front_0_3000) and stepout edges (stepout_bottom_0_620)
          const parts = k.split('_');
          let edge, s, e;
          if (parts[0] === 'stepout') {
            edge = parts[0] + '_' + parts[1]; // e.g., 'stepout_bottom'
            s = parts[2];
            e = parts[3];
          } else {
            edge = parts[0];
            s = parts[1];
            e = parts[2];
          }
          
          const segLen = parseInt(e) - parseInt(s);
          const dropH = v.height;
          const dropThickness = WORKTOP_THICKNESS;
          
          // Overlap amount to hide the joint line
          const OVERLAP = 3;
          
          let dx, dz;
          
          // Position dropdown directly under the worktop edge
          if (edge === 'back') {
            dx = w.x + parseInt(s) + segLen/2 - cx;
            dz = w.y + dropThickness/2 - cz;
          } else if (edge === 'front') {
            dx = w.x + parseInt(s) + segLen/2 - cx;
            dz = w.y + w.depth - dropThickness/2 - cz;
          } else if (edge === 'left') {
            dx = w.x + dropThickness/2 - cx;
            dz = w.y + parseInt(s) + segLen/2 - cz;
          } else if (edge === 'right') {
            dx = w.x + w.length - dropThickness/2 - cx;
            dz = w.y + parseInt(s) + segLen/2 - cz;
          } else if (edge === 'stepout_bottom') {
            // Bottom of stepout
            const stepout = w.stepout;
            if (stepout) {
              if (stepout.corner === 'front-left') {
                dx = w.x + parseInt(s) + segLen/2 - cx;
                dz = w.y + w.depth + stepout.depth - dropThickness/2 - cz;
              } else if (stepout.corner === 'front-right') {
                dx = w.x + w.length - stepout.length + parseInt(s) + segLen/2 - cx;
                dz = w.y + w.depth + stepout.depth - dropThickness/2 - cz;
              }
            }
          } else if (edge === 'stepout_left') {
            const stepout = w.stepout;
            if (stepout && stepout.corner === 'front-left') {
              dx = w.x + dropThickness/2 - cx;
              dz = w.y + w.depth + parseInt(s) + segLen/2 - cz;
            }
          } else if (edge === 'stepout_right') {
            const stepout = w.stepout;
            if (stepout) {
              if (stepout.corner === 'front-left') {
                dx = w.x + stepout.length - dropThickness/2 - cx;
                dz = w.y + w.depth + parseInt(s) + segLen/2 - cz;
              } else if (stepout.corner === 'front-right') {
                dx = w.x + w.length - dropThickness/2 - cx;
                dz = w.y + w.depth + parseInt(s) + segLen/2 - cz;
              }
            }
          }
          
          if (dx !== undefined && dz !== undefined) {
            // Create dropdown panel with proper material
            // Make it slightly taller to overlap into worktop
            const isHorizontalEdge = edge === 'back' || edge === 'front' || edge === 'stepout_bottom' || edge === 'stepout_top';
            const dGeo = isHorizontalEdge
              ? new THREE.BoxGeometry(segLen, dropH + OVERLAP, dropThickness)
              : new THREE.BoxGeometry(dropThickness, dropH + OVERLAP, segLen);
            
            const dropdownMat = getMaterial3DForDropdown(segLen, dropH);
            const dMesh = new THREE.Mesh(dGeo, dropdownMat);
            
            // Position: dropdown hangs from bottom of worktop
            // Worktop bottom is at Y = -WORKTOP_THICKNESS
            // Dropdown center should be at: worktop_bottom - dropH/2 + OVERLAP/2
            // This makes dropdown top extend OVERLAP into the worktop
            const dropdownCenterY = -WORKTOP_THICKNESS - dropH/2 + OVERLAP/2;
            dMesh.position.set(dx, dropdownCenterY, dz);
            dMesh.castShadow = true;
            scene.add(dMesh);
          }
        }
      });
    }
  });
  
  // Upstands - sit ON worktops, vertical
  console.log('Rendering upstands:', upstands.length);
  upstands.forEach((u, idx) => {
    console.log(`  Upstand ${idx}: id=${u.id}, isSplash=${u.isSplash}, isWindowCill=${u.isWindowCill}`);
    const UPSTAND_DEPTH_3D = 20; // Visual thickness in 3D
    const CILL_THICKNESS = 20; // Window cill thickness
    let geo, px, py, pz;
    
    // Get parent worktop for proper positioning
    const parent = worktops.find(w => w.id === u.parentId);
    
    // Window cills are horizontal shelves at window height
    if (u.isWindowCill) {
      const cillDepth = u.depth || 200;
      const cillHeight = u.height || 300; // Height from worktop to cill
      const overhang = u.overhang || 20;
      
      const edge = u.parentEdge || 'back';
      const edgeStart = u.edgeStart || 0;
      
      // Track if cill is rotated (left/right edges)
      let cillRotated = false;
      
      // Cill geometry: length √ó thickness √ó depth
      geo = new THREE.BoxGeometry(u.length, CILL_THICKNESS, cillDepth);
      
      if (parent) {
        if (edge === 'back') {
          px = parent.x + edgeStart + u.length/2 - cx;
          // Cill overhangs PAST the upstand/splashback by 'overhang' amount
          // Upstand front face is at parent.y + UPSTAND_DEPTH_3D
          // Cill front face should be at parent.y + UPSTAND_DEPTH_3D + overhang
          pz = parent.y + UPSTAND_DEPTH_3D + overhang - cillDepth/2 - cz;
        } else if (edge === 'front') {
          px = parent.x + edgeStart + u.length/2 - cx;
          pz = parent.y + parent.depth - UPSTAND_DEPTH_3D - overhang + cillDepth/2 - cz;
        } else if (edge === 'left') {
          // For left/right, swap dimensions
          cillRotated = true;
          geo = new THREE.BoxGeometry(cillDepth, CILL_THICKNESS, u.length);
          px = parent.x + UPSTAND_DEPTH_3D + overhang - cillDepth/2 - cx;
          pz = parent.y + edgeStart + u.length/2 - cz;
        } else { // right
          cillRotated = true;
          geo = new THREE.BoxGeometry(cillDepth, CILL_THICKNESS, u.length);
          px = parent.x + parent.length - UPSTAND_DEPTH_3D - overhang + cillDepth/2 - cx;
          pz = parent.y + edgeStart + u.length/2 - cz;
        }
      } else {
        px = u.absoluteX + u.length/2 - cx;
        pz = u.absoluteY + UPSTAND_DEPTH_3D + overhang - cillDepth/2 - cz;
      }
      
      // Y position: cill sits at splashback height (on top of splashback)
      py = WORKTOP_Y + cillHeight + CILL_THICKNESS/2;
      
      // Use material with correct dimensions based on rotation
      const texW = cillRotated ? cillDepth : u.length;
      const texD = cillRotated ? u.length : cillDepth;
      const mat = getMaterial3DForCill(texW, texD);
      console.log(`  Cill material: rotated=${cillRotated}, texW=${texW}, texD=${texD}`);
      const mesh = new THREE.Mesh(geo, mat);
      
      mesh.position.set(px, py, pz);
      mesh.castShadow = true;
      scene.add(mesh);
      
      // Edge lines on cills
      const edges = new THREE.EdgesGeometry(geo);
      const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x666666 }));
      line.position.copy(mesh.position);
      scene.add(line);
      
    } else {
      // Regular upstands and splashbacks
      if (u.vertical) {
        // Vertical in 2D = runs along Z in 3D
        geo = new THREE.BoxGeometry(UPSTAND_DEPTH_3D, u.height, u.length);
      } else {
        // Horizontal in 2D = runs along X in 3D
        geo = new THREE.BoxGeometry(u.length, u.height, UPSTAND_DEPTH_3D);
      }
      
      // For continuous upstands, use absolute position based on edge
      // Upstands sit ON the worktop edge (not behind it)
      if (u.isContinuous && u.absoluteX !== undefined) {
        const edge = u.parentEdge || 'back';
        
        if (edge === 'back') {
          px = u.absoluteX + u.length/2 - cx;
          pz = u.absoluteY + UPSTAND_DEPTH_3D/2 - cz;  // Sit ON back edge
        } else if (edge === 'front') {
          px = u.absoluteX + u.length/2 - cx;
          pz = u.absoluteY - UPSTAND_DEPTH_3D/2 - cz;  // Sit ON front edge
        } else if (edge === 'left') {
          px = u.absoluteX + UPSTAND_DEPTH_3D/2 - cx;  // Sit ON left edge
          pz = u.absoluteY + u.length/2 - cz;
        } else { // right
          px = u.absoluteX - UPSTAND_DEPTH_3D/2 - cx;  // Sit ON right edge
          pz = u.absoluteY + u.length/2 - cz;
        }
      } else if (parent && u.parentEdge && u.parentEdge.startsWith('stepout_')) {
        // Stepout edge upstands - use absolute position
        const edge = u.parentEdge;
        const absX = u.absoluteX || u.x;
        const absY = u.absoluteY || u.y;
        
        console.log(`  Stepout upstand: edge=${edge}, absX=${absX}, absY=${absY}, vertical=${u.vertical}`);
        
        if (edge === 'stepout_bottom') {
          // Bottom of stepout - horizontal upstand
          px = absX + u.length/2 - cx;
          pz = absY - UPSTAND_DEPTH_3D/2 - cz;  // Behind the edge
        } else if (edge === 'stepout_top') {
          px = absX + u.length/2 - cx;
          pz = absY + UPSTAND_DEPTH_3D/2 - cz;
        } else if (edge === 'stepout_left') {
          // Left side of stepout - vertical upstand
          px = absX + UPSTAND_DEPTH_3D/2 - cx;
          pz = absY + u.length/2 - cz;
        } else if (edge === 'stepout_right') {
          px = absX - UPSTAND_DEPTH_3D/2 - cx;
          pz = absY + u.length/2 - cz;
        } else if (edge === 'stepout_outer') {
          // Outer edge of vertical worktop stepout
          px = absX + UPSTAND_DEPTH_3D/2 - cx;
          pz = absY + u.length/2 - cz;
        } else if (edge === 'stepout_inner') {
          px = absX - UPSTAND_DEPTH_3D/2 - cx;
          pz = absY + u.length/2 - cz;
        }
      } else if (parent && u.parentEdge) {
        // Position based on parent worktop edge
        const edge = u.parentEdge;
        const edgeStart = u.edgeStart || 0;
        
        if (edge === 'back') {
          px = parent.x + edgeStart + u.length/2 - cx;
          pz = parent.y + UPSTAND_DEPTH_3D/2 - cz;  // Sit ON back edge
        } else if (edge === 'front') {
          px = parent.x + edgeStart + u.length/2 - cx;
          pz = parent.y + parent.depth - UPSTAND_DEPTH_3D/2 - cz;  // Sit ON front edge
        } else if (edge === 'left') {
          px = parent.x + UPSTAND_DEPTH_3D/2 - cx;  // Sit ON left edge
          pz = parent.y + edgeStart + u.length/2 - cz;
        } else { // right
          px = parent.x + parent.length - UPSTAND_DEPTH_3D/2 - cx;  // Sit ON right edge
          pz = parent.y + edgeStart + u.length/2 - cz;
        }
      } else {
        // Free-standing upstand - use 2D position
        if (u.vertical) {
          px = u.x + UPSTAND_DEPTH_3D/2 - cx;
          pz = u.y + u.length/2 - cz;
        } else {
          px = u.x + u.length/2 - cx;
          pz = u.y + UPSTAND_DEPTH_3D/2 - cz;
        }
      }
      
      // Y position: bottom of upstand sits ON worktop surface (Y=0)
      py = WORKTOP_Y + u.height/2;
      
      // Use material with appropriate texture scale for upstands
      const mat = getMaterial3DForUpstand(u.length, u.height);
      console.log(`  Upstand ${idx} material:`, mat.map ? 'HAS TEXTURE' : 'NO TEXTURE (color only)');
      const mesh = new THREE.Mesh(geo, mat);
      
      mesh.position.set(px, py, pz);
      mesh.castShadow = true;
      scene.add(mesh);
      
      // Edge lines on upstands
      const edges = new THREE.EdgesGeometry(geo);
      const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x666666 }));
      line.position.copy(mesh.position);
      scene.add(line);
    }
  });
  
  // Cutouts - hobs and drainers only (sinks/taps are actual holes in worktop geometry)
  // NOTE: 3D Z coordinate is inverted from 2D Y (smaller 2D Y = larger 3D Z)
  // Formula: 3D_Z = parent.y + parent.depth - 2D_Y - cz
  cutouts.forEach(c => {
    const parent = worktops.find(w => w.id === c.parentId);
    if (!parent) return;
    
    // Helper to flip Y coordinate to Z
    // Convert 2D Y coordinate to 3D Z coordinate
    // In 2D: smaller Y = back (wall), larger Y = front (user)
    // In 3D: smaller Z = back, larger Z = front
    const flipYtoZ = (y2d) => y2d - cz;
    
    if (c.type === 'hob' || c.type === 'recess_hob') {
      // Hob cutout - black surface (hob sits here)
      // Check if on vertical worktop
      const isVerticalWorktop = parent && parent.depth > parent.length;
      const geoW = isVerticalWorktop ? c.length : c.width;
      const geoL = isVerticalWorktop ? c.width : c.length;
      
      const geo = new THREE.BoxGeometry(geoW, 3, geoL);
      const mat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.3 });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.position.set(c.x + geoW/2 - cx, WORKTOP_Y - 1, flipYtoZ(c.y + geoL/2));
      scene.add(mesh);
      
    } else if (c.type === 'drainer') {
      // Standard drainer grooves - perpendicular to sink edge
      const isVerticalWorktop = parent && parent.depth > parent.length;
      const grooveCount = c.grooveCount || 5;
      
      // On vertical worktop: c.width and c.length are user-entered values
      // but drawing swapped them, so drawn dimensions are swapped
      const drawnW = isVerticalWorktop ? c.length : c.width;
      const drawnL = isVerticalWorktop ? c.width : c.length;
      
      for (let i = 1; i <= grooveCount; i++) {
        let grooveGeo, groovePos;
        
        if (isVerticalWorktop) {
          // Vertical worktop: grooves run along Z axis (perpendicular to sink)
          // Grooves are thin in X, long in Z
          const grooveLen = drawnL - 20;  // Length along Z
          const spacing = drawnW / (grooveCount + 1);  // Spacing along X
          grooveGeo = new THREE.BoxGeometry(8, 4, grooveLen);
          groovePos = new THREE.Vector3(
            c.x + (i * spacing) - cx,
            WORKTOP_Y - 2,
            flipYtoZ(c.y + drawnL/2)
          );
        } else {
          // Horizontal worktop: grooves run along X axis 
          // Grooves are long in X, thin in Z
          const grooveLen = drawnW - 20;  // Length along X
          const spacing = drawnL / (grooveCount + 1);  // Spacing along Z
          grooveGeo = new THREE.BoxGeometry(grooveLen, 4, 8);
          groovePos = new THREE.Vector3(
            c.x + drawnW/2 - cx,
            WORKTOP_Y - 2,
            flipYtoZ(c.y + (i * spacing))
          );
        }
        
        const grooveMat = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.3 });
        const groove = new THREE.Mesh(grooveGeo, grooveMat);
        groove.position.copy(groovePos);
        scene.add(groove);
      }
      
    } else if (c.type === 'recess_drainer') {
      // Recess drainer - sunken area with rounded corners
      const recessDepth = 35;
      const cornerRadius = 20; // Rounded corners
      
      // Check if on vertical worktop
      const isVerticalWorktop = parent && parent.depth > parent.length;
      
      // Use drawn dimensions (swapped on vertical worktops)
      const drawnW = isVerticalWorktop ? c.length : c.width;
      const drawnL = isVerticalWorktop ? c.width : c.length;
      
      // Inner wall color - much darker for contrast
      const innerWallColor = 0x3a3a3a;
      const baseColor = 0x2a2a2a;
      const grooveColor = 0x1a1a1a;
      
      // Create rounded rectangle shape for the base
      const baseShape = new THREE.Shape();
      const bw = drawnW - 4;
      const bl = drawnL - 4;
      const br = Math.min(cornerRadius, bw/2, bl/2);
      
      baseShape.moveTo(br, 0);
      baseShape.lineTo(bw - br, 0);
      baseShape.quadraticCurveTo(bw, 0, bw, br);
      baseShape.lineTo(bw, bl - br);
      baseShape.quadraticCurveTo(bw, bl, bw - br, bl);
      baseShape.lineTo(br, bl);
      baseShape.quadraticCurveTo(0, bl, 0, bl - br);
      baseShape.lineTo(0, br);
      baseShape.quadraticCurveTo(0, 0, br, 0);
      
      const baseExtrudeSettings = { depth: 3, bevelEnabled: false };
      const baseGeo = new THREE.ExtrudeGeometry(baseShape, baseExtrudeSettings);
      const baseMat = new THREE.MeshStandardMaterial({ color: baseColor, roughness: 0.5 });
      const base = new THREE.Mesh(baseGeo, baseMat);
      base.rotation.x = -Math.PI / 2;
      base.position.set(c.x + 2 - cx, WORKTOP_Y - recessDepth, flipYtoZ(c.y + 2 + bl));
      scene.add(base);
      
      // Inner walls - dark to show depth clearly
      const innerMat = new THREE.MeshStandardMaterial({ color: innerWallColor, roughness: 0.5, side: THREE.DoubleSide });
      
      // Straight wall sections (between rounded corners)
      const straightW = drawnW - 2 * cornerRadius;
      const straightL = drawnL - 2 * cornerRadius;
      
      if (straightW > 0) {
        // Front wall (straight section)
        const fwGeo = new THREE.PlaneGeometry(straightW, recessDepth);
        const fw = new THREE.Mesh(fwGeo, innerMat);
        fw.position.set(c.x + drawnW/2 - cx, WORKTOP_Y - recessDepth/2, flipYtoZ(c.y + drawnL));
        scene.add(fw);
        
        // Back wall (straight section)
        const bw = new THREE.Mesh(fwGeo, innerMat);
        bw.rotation.y = Math.PI;
        bw.position.set(c.x + drawnW/2 - cx, WORKTOP_Y - recessDepth/2, flipYtoZ(c.y));
        scene.add(bw);
      }
      
      if (straightL > 0) {
        // Left wall (straight section)
        const swGeo = new THREE.PlaneGeometry(straightL, recessDepth);
        const lw = new THREE.Mesh(swGeo, innerMat);
        lw.rotation.y = Math.PI / 2;
        lw.position.set(c.x - cx, WORKTOP_Y - recessDepth/2, flipYtoZ(c.y + drawnL/2));
        scene.add(lw);
        
        // Right wall (straight section)
        const rw = new THREE.Mesh(swGeo, innerMat);
        rw.rotation.y = -Math.PI / 2;
        rw.position.set(c.x + drawnW - cx, WORKTOP_Y - recessDepth/2, flipYtoZ(c.y + drawnL/2));
        scene.add(rw);
      }
      
      // Corner cylinders (quarter cylinders for rounded corners)
      const cornerGeo = new THREE.CylinderGeometry(cornerRadius, cornerRadius, recessDepth, 16, 1, true, 0, Math.PI/2);
      const cornerPositions = [
        // Front-left corner
        { x: c.x + cornerRadius - cx, z: flipYtoZ(c.y + drawnL - cornerRadius), rotY: Math.PI },
        // Front-right corner
        { x: c.x + drawnW - cornerRadius - cx, z: flipYtoZ(c.y + drawnL - cornerRadius), rotY: Math.PI/2 },
        // Back-left corner
        { x: c.x + cornerRadius - cx, z: flipYtoZ(c.y + cornerRadius), rotY: -Math.PI/2 },
        // Back-right corner
        { x: c.x + drawnW - cornerRadius - cx, z: flipYtoZ(c.y + cornerRadius), rotY: 0 }
      ];
      
      cornerPositions.forEach(pos => {
        const corner = new THREE.Mesh(cornerGeo, innerMat);
        corner.position.set(pos.x, WORKTOP_Y - recessDepth/2, pos.z);
        corner.rotation.y = pos.rotY;
        scene.add(corner);
      });
      
      // Grooves inside recess - orientation depends on worktop
      const grooveCount = c.grooveCount || 5;
      
      if (isVerticalWorktop) {
        // Vertical worktop: grooves run along Z
        const spacing = drawnW / (grooveCount + 1);
        for (let i = 1; i <= grooveCount; i++) {
          const grooveGeo = new THREE.BoxGeometry(10, 6, drawnL - 40);
          const grooveMat = new THREE.MeshStandardMaterial({ color: grooveColor, roughness: 0.3 });
          const groove = new THREE.Mesh(grooveGeo, grooveMat);
          groove.position.set(
            c.x + (i * spacing) - cx,
            WORKTOP_Y - recessDepth - 3,
            flipYtoZ(c.y + drawnL/2)
          );
          scene.add(groove);
        }
      } else {
        // Horizontal worktop: grooves run along X
        const spacing = drawnL / (grooveCount + 1);
        for (let i = 1; i <= grooveCount; i++) {
          const grooveGeo = new THREE.BoxGeometry(drawnW - 40, 6, 10);
          const grooveMat = new THREE.MeshStandardMaterial({ color: grooveColor, roughness: 0.3 });
          const groove = new THREE.Mesh(grooveGeo, grooveMat);
          groove.position.set(
            c.x + drawnW/2 - cx,
            WORKTOP_Y - recessDepth - 3,
            flipYtoZ(c.y + (i * spacing))
          );
          scene.add(groove);
        }
      }
      
      // Top edge highlight - stone material rim (use drawn dimensions)
      const rimMat = getMaterial3D();
      const rimWidth = 15;
      const rimHeight = 5;
      
      // Front rim
      const frontRimGeo = new THREE.BoxGeometry(drawnW + rimWidth*2, rimHeight, rimWidth);
      const frontRim = new THREE.Mesh(frontRimGeo, rimMat);
      frontRim.position.set(c.x + drawnW/2 - cx, WORKTOP_Y - rimHeight/2, flipYtoZ(c.y + drawnL) + rimWidth/2);
      scene.add(frontRim);
      
      // Back rim
      const backRim = new THREE.Mesh(frontRimGeo, rimMat);
      backRim.position.set(c.x + drawnW/2 - cx, WORKTOP_Y - rimHeight/2, flipYtoZ(c.y) - rimWidth/2);
      scene.add(backRim);
      
      // Left rim
      const sideRimGeo = new THREE.BoxGeometry(rimWidth, rimHeight, drawnL);
      const leftRim = new THREE.Mesh(sideRimGeo, rimMat);
      leftRim.position.set(c.x - rimWidth/2 - cx, WORKTOP_Y - rimHeight/2, flipYtoZ(c.y + drawnL/2));
      scene.add(leftRim);
      
      // Right rim
      const rightRim = new THREE.Mesh(sideRimGeo, rimMat);
      rightRim.position.set(c.x + drawnW + rimWidth/2 - cx, WORKTOP_Y - rimHeight/2, flipYtoZ(c.y + drawnL/2));
      scene.add(rightRim);
      
      // Dark outline at top edge
      const edgeMat = new THREE.LineBasicMaterial({ color: 0x222222, linewidth: 2 });
      const edgePoints = [
        new THREE.Vector3(c.x - cx, WORKTOP_Y + 0.5, flipYtoZ(c.y)),
        new THREE.Vector3(c.x + drawnW - cx, WORKTOP_Y + 0.5, flipYtoZ(c.y)),
        new THREE.Vector3(c.x + drawnW - cx, WORKTOP_Y + 0.5, flipYtoZ(c.y + drawnL)),
        new THREE.Vector3(c.x - cx, WORKTOP_Y + 0.5, flipYtoZ(c.y + drawnL)),
        new THREE.Vector3(c.x - cx, WORKTOP_Y + 0.5, flipYtoZ(c.y))
      ];
      const edgeGeo = new THREE.BufferGeometry().setFromPoints(edgePoints);
      const edgeLine = new THREE.Line(edgeGeo, edgeMat);
      scene.add(edgeLine);
    }
  });
  
  // Socket cutouts on upstands and splashbacks (rendered as rectangular openings)
  const socketCutouts = cutouts.filter(c => c.type === 'socket');
  console.log('Socket cutouts found:', socketCutouts.length);
  
  socketCutouts.forEach(c => {
    const parent = upstands.find(u => u.id === c.parentId);
    console.log('Socket parent:', c.parentId, 'found:', !!parent);
    if (!parent) return;
    
    // Get upstand/splashback 3D position (must match upstand positioning exactly)
    const UPSTAND_DEPTH_3D = 20;
    const pw = worktops.find(w => w.id === parent.parentId);
    const edge = parent.parentEdge || 'back';
    
    // Calculate splashback position exactly as upstands do
    let splashPx, splashPz;
    let isVertical = (edge === 'left' || edge === 'right');
    
    if (parent.isContinuous && parent.absoluteX !== undefined) {
      if (edge === 'back') {
        splashPx = parent.absoluteX + parent.length/2 - cx;
        splashPz = parent.absoluteY + UPSTAND_DEPTH_3D/2 - cz;
      } else if (edge === 'front') {
        splashPx = parent.absoluteX + parent.length/2 - cx;
        splashPz = parent.absoluteY - UPSTAND_DEPTH_3D/2 - cz;
      } else if (edge === 'left') {
        splashPx = parent.absoluteX + UPSTAND_DEPTH_3D/2 - cx;
        splashPz = parent.absoluteY + parent.length/2 - cz;
      } else { // right
        splashPx = parent.absoluteX - UPSTAND_DEPTH_3D/2 - cx;
        splashPz = parent.absoluteY + parent.length/2 - cz;
      }
    } else if (pw) {
      const edgeStart = parent.edgeStart || 0;
      if (edge === 'back') {
        splashPx = pw.x + edgeStart + parent.length/2 - cx;
        splashPz = pw.y + UPSTAND_DEPTH_3D/2 - cz;
      } else if (edge === 'front') {
        splashPx = pw.x + edgeStart + parent.length/2 - cx;
        splashPz = pw.y + pw.depth - UPSTAND_DEPTH_3D/2 - cz;
      } else if (edge === 'left') {
        splashPx = pw.x + UPSTAND_DEPTH_3D/2 - cx;
        splashPz = pw.y + edgeStart + parent.length/2 - cz;
      } else { // right
        splashPx = pw.x + pw.length - UPSTAND_DEPTH_3D/2 - cx;
        splashPz = pw.y + edgeStart + parent.length/2 - cz;
      }
    } else {
      console.warn('Cannot position socket - no parent worktop found');
      return;
    }
    
    // Position socket on the splashback
    // c.centerX is position along the splashback length (from start)
    // c.centerY is height from bottom of splashback
    let px, pz;
    
    if (edge === 'back' || edge === 'front') {
      // Horizontal splashback - socket moves along X, splashPz stays same
      px = splashPx - parent.length/2 + c.centerX;
      pz = splashPz;
    } else {
      // Vertical splashback (left/right) - socket moves along Z
      px = splashPx;
      pz = splashPz - parent.length/2 + c.centerX;
    }
    
    // Y position: centerY from bottom of splashback (above worktop surface)
    const py = WORKTOP_Y + c.centerY;
    
    console.log(`Socket on ${edge} edge: px=${px.toFixed(0)}, py=${py.toFixed(0)}, pz=${pz.toFixed(0)}, centerX=${c.centerX}`);
    
    // Create socket cutout visualization - dark hole through the splashback
    // Geometry orientation depends on splashback orientation
    let holeGeo;
    if (isVertical) {
      // Left/right edge - splashback runs along Z, socket punches through X
      holeGeo = new THREE.BoxGeometry(UPSTAND_DEPTH_3D + 4, c.height, c.width);
    } else {
      // Back/front edge - splashback runs along X, socket punches through Z
      holeGeo = new THREE.BoxGeometry(c.width, c.height, UPSTAND_DEPTH_3D + 4);
    }
    
    const holeMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 1.0 });
    const holeMesh = new THREE.Mesh(holeGeo, holeMat);
    holeMesh.position.set(px, py, pz);
    scene.add(holeMesh);
  });
  
  renderer.render(scene, camera);
}

function promptAdminUnlock() {
  if (adminUnlocked) {
    // Already unlocked - just show confirmation
    alert('Admin mode is already unlocked!');
    return;
  }
  
  const pin = prompt('Enter Admin PIN:');
  if (pin === ADMIN_PIN) {
    adminUnlocked = true;
    sessionStorage.setItem('adminUnlocked', 'true');
    
    // Show slab layout tab
    const slabTab = document.getElementById('slabLayoutTab');
    if (slabTab) slabTab.style.display = 'block';
    
    // Update admin button
    const btn = document.getElementById('adminTabBtn');
    if (btn) {
      btn.textContent = 'üîì Admin ‚úì';
      btn.style.background = '#e8f5e9';
      btn.style.borderColor = '#1e4d3a';
    }
    
    alert('Admin mode unlocked! Slab Layout tab is now visible.');
  } else if (pin !== null) {
    alert('Incorrect PIN');
  }
}

function tryOpenSlabLayout() {
  if (!adminUnlocked) {
    promptAdminUnlock();
    if (!adminUnlocked) return; // Still not unlocked
  }
  switchView('slab');
}

function toggleAdminPanel() {
  // Legacy function - just toggle slab config visibility
  const panel = document.getElementById('slabConfig');
  if (panel) {
    panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
  }
}

function switchView(view) {
  currentView = view;
  document.querySelectorAll('.view-tab').forEach((t, i) => {
    if (i === 0) t.classList.toggle('active', view === '2d');
    else if (i === 1) t.classList.toggle('active', view === '3d');
    else if (i === 2) t.classList.toggle('active', view === 'slab');
  });
  
  const container = document.getElementById('canvasContainer');
  document.getElementById('canvas2d').style.display = view === '2d' ? 'block' : 'none';
  document.getElementById('canvas3d').style.display = view === '3d' ? 'block' : 'none';
  document.getElementById('canvasSlab').style.display = view === 'slab' ? 'block' : 'none';
  document.getElementById('legend2d').style.display = view === '2d' ? 'block' : 'none';
  document.getElementById('nav2d').style.display = view === '2d' ? 'flex' : 'none';
  document.getElementById('nav3d').style.display = view === '3d' ? 'flex' : 'none';
  // Admin panel shows in slab view if unlocked
  document.getElementById('slabConfig').style.display = (view === 'slab' && adminUnlocked) ? 'block' : 'none';
  
  document.getElementById('disclaimer3d').style.display = view === '3d' ? 'block' : 'none';
  
  // Show Generate Quote button only in 2D view
  document.getElementById('generateQuoteBtn').style.display = view === '2d' ? 'flex' : 'none';
  document.getElementById('clearDesignBtn').style.display = view === '2d' ? 'block' : 'none';
  
  // Handle scrolling for slab view
  container.style.overflowY = view === 'slab' ? 'auto' : 'hidden';
  
  if (view === '2d') {
    render();
  } else if (view === '3d') {
    if (!renderer) init3D();
    // Load texture then render
    loadMaterialTexture(selectedMaterial, () => {
      render3D();
      animate3D();
    });
  } else if (view === 'slab') {
    renderSlabLayout();
  }
}

function rotate3D(h, v) {
  if (!camera) return;
  // Horizontal rotation around Y axis
  if (h !== 0) {
    camera.position.applyAxisAngle(new THREE.Vector3(0, 1, 0), h * 0.3);
  }
  // Vertical - move camera up/down
  if (v !== 0) {
    camera.position.y = Math.max(500, Math.min(5000, camera.position.y + v * 300));
  }
  camera.lookAt(0, 0, 0);
}

function reset3DView() {
  if (!camera) return;
  camera.position.set(2000, 2500, 3000);
  camera.lookAt(0, 0, 0);
}

function view3DTop() {
  if (!camera) return;
  // Look straight down from above
  camera.position.set(0, 4000, 0);
  camera.lookAt(0, 0, 0);
}

function view3DFront() {
  if (!camera) return;
  // Look from front (positive Z looking at negative Z)
  camera.position.set(0, 1000, 4000);
  camera.lookAt(0, 0, 0);
}

function zoom3D(factor) {
  if (!camera) return;
  camera.position.multiplyScalar(factor);
  // Keep within reasonable bounds
  const dist = camera.position.length();
  if (dist < 1000) camera.position.setLength(1000);
  if (dist > 10000) camera.position.setLength(10000);
}

// Capture current 3D view for quote gallery
function captureCurrentView() {
  if (!renderer || !scene || !camera) {
    alert('Please wait for 3D view to load');
    return;
  }
  
  try {
    renderer.render(scene, camera);
    const dataUrl = renderer.domElement.toDataURL('image/jpeg', 0.7);
    const captureNum = customCaptures.length + 1;
    customCaptures.push({ 
      name: `Custom ${captureNum}`, 
      image: dataUrl 
    });
    
    // Update UI
    updateCaptureCount();
    
    // Brief visual feedback
    const btn = document.querySelector('[onclick="captureCurrentView()"]');
    if (btn) {
      const originalBg = btn.style.background;
      btn.style.background = '#4CAF50';
      btn.style.color = 'white';
      setTimeout(() => {
        btn.style.background = originalBg;
        btn.style.color = '';
      }, 300);
    }
    
    console.log('Captured view:', captureNum, 'Total:', customCaptures.length);
  } catch (e) {
    console.error('Failed to capture view:', e);
    alert('Failed to capture view');
  }
}

function clearCaptures() {
  if (customCaptures.length === 0) return;
  if (confirm('Clear all ' + customCaptures.length + ' captured views?')) {
    customCaptures = [];
    updateCaptureCount();
    console.log('Cleared all captures');
  }
}

function updateCaptureCount() {
  const countEl = document.getElementById('captureCount');
  const clearBtn = document.getElementById('clearCapturesBtn');
  
  if (customCaptures.length > 0) {
    countEl.textContent = customCaptures.length;
    countEl.style.display = 'inline';
    clearBtn.style.display = 'inline';
  } else {
    countEl.style.display = 'none';
    clearBtn.style.display = 'none';
  }
}

function animate3D() {
  if (currentView !== '3d') return;
  requestAnimationFrame(animate3D);
  renderer.render(scene, camera);
}

// ========== SLAB LAYOUT VIEW ==========
function renderSlabLayout() {
  const slabCanvas = document.getElementById('canvasSlab');
  const container = document.getElementById('canvasContainer');
  
  // Clear any existing autoSplitPos - will be recalculated fresh
  upstands.forEach(u => delete u.autoSplitPos);
  
  // Get slab dimensions from inputs (default 3200x1600)
  const slabWInput = document.getElementById('slabWidthInput');
  const slabHInput = document.getElementById('slabHeightInput');
  const SLAB_W = slabWInput ? parseInt(slabWInput.value) || 3200 : 3200;
  const SLAB_H = slabHInput ? parseInt(slabHInput.value) || 1600 : 1600;
  const BLADE = 0; // User provides workable area (blade already deducted from actual slab size)
  
  console.log('SLAB PACKING: Using slab size', SLAB_W, '√ó', SLAB_H);
  
  // Get fabrication prices - check admin inputs first, then fall back to material defaults
  const materialBrand = selectedMaterial ? (MATERIAL_COLORS[selectedMaterial]?.brand || 'MOD') : 'MOD';
  const defaultFabPrices = FABRICATION_PRICES[materialBrand] || FABRICATION_PRICES.quartz;
  
  const profit1stEl = document.getElementById('profit1stSlab');
  const profitAddEl = document.getElementById('profitAddSlab');
  
  // Use admin input values if set, otherwise use material defaults
  let profit1st, profitPerSqFt;
  if (profit1stEl && profit1stEl.dataset.manuallySet === 'true') {
    profit1st = parseFloat(profit1stEl.value) || 1300;
  } else {
    profit1st = getFabricationPrices(materialBrand).firstSlab;
    if (profit1stEl) profit1stEl.value = profit1st;
  }
  
  if (profitAddEl && profitAddEl.dataset.manuallySet === 'true') {
    profitPerSqFt = parseFloat(profitAddEl.value) || 12.50;
  } else {
    profitPerSqFt = getFabricationPrices(materialBrand).additionalSlabPerSqFt;
    if (profitAddEl) profitAddEl.value = profitPerSqFt;
  }
  
  // Collect all pieces
  const pieces = [];
  let oversizedPieces = [];
  
  worktops.forEach(w => {
    // Check if worktop has splits
    if (w.splits && w.splits.length > 0) {
      // Split worktop into pieces
      const verticalSplits = w.splits.filter(s => s.direction === 'vertical').sort((a, b) => a.position - b.position);
      const horizontalSplits = w.splits.filter(s => s.direction === 'horizontal').sort((a, b) => a.position - b.position);
      
      if (verticalSplits.length > 0) {
        // Vertical splits divide the length
        let prevPos = 0;
        verticalSplits.forEach((split, i) => {
          const pieceLength = Math.round(split.position - prevPos);
          const fits = (pieceLength <= SLAB_W && w.depth <= SLAB_H) || (w.depth <= SLAB_W && pieceLength <= SLAB_H);
          pieces.push({
            name: `${w.name || 'Worktop'} (${i + 1})`,
            width: pieceLength,
            height: Math.round(w.depth),
            type: 'worktop',
            color: '#e3f2fd',
            error: !fits
          });
          if (!fits) oversizedPieces.push(`${w.name} part ${i + 1} (${pieceLength}√ó${Math.round(w.depth)}mm)`);
          prevPos = split.position;
        });
        // Last piece
        const lastLength = Math.round(w.length - prevPos);
        const fits = (lastLength <= SLAB_W && w.depth <= SLAB_H) || (w.depth <= SLAB_W && lastLength <= SLAB_H);
        pieces.push({
          name: `${w.name || 'Worktop'} (${verticalSplits.length + 1})`,
          width: lastLength,
          height: Math.round(w.depth),
          type: 'worktop',
          color: '#e3f2fd',
          error: !fits
        });
        if (!fits) oversizedPieces.push(`${w.name} part ${verticalSplits.length + 1} (${lastLength}√ó${Math.round(w.depth)}mm)`);
      } else if (horizontalSplits.length > 0) {
        // Horizontal splits divide the depth
        let prevPos = 0;
        horizontalSplits.forEach((split, i) => {
          const pieceDepth = Math.round(split.position - prevPos);
          const fits = (w.length <= SLAB_W && pieceDepth <= SLAB_H) || (pieceDepth <= SLAB_W && w.length <= SLAB_H);
          pieces.push({
            name: `${w.name || 'Worktop'} (${i + 1})`,
            width: Math.round(w.length),
            height: pieceDepth,
            type: 'worktop',
            color: '#e3f2fd',
            error: !fits
          });
          if (!fits) oversizedPieces.push(`${w.name} part ${i + 1} (${Math.round(w.length)}√ó${pieceDepth}mm)`);
          prevPos = split.position;
        });
        // Last piece
        const lastDepth = Math.round(w.depth - prevPos);
        const fits = (w.length <= SLAB_W && lastDepth <= SLAB_H) || (lastDepth <= SLAB_W && w.length <= SLAB_H);
        pieces.push({
          name: `${w.name || 'Worktop'} (${horizontalSplits.length + 1})`,
          width: Math.round(w.length),
          height: lastDepth,
          type: 'worktop',
          color: '#e3f2fd',
          error: !fits
        });
        if (!fits) oversizedPieces.push(`${w.name} part ${horizontalSplits.length + 1} (${Math.round(w.length)}√ó${lastDepth}mm)`);
      }
    } else {
      // No splits - add whole worktop
      const pw = Math.round(w.length);
      const ph = Math.round(w.depth);
      
      // If worktop has stepout, use bounding box dimensions
      let actualW = pw;
      let actualH = ph;
      let isLShape = false;
      
      if (w.stepout) {
        isLShape = true;
        const isVertical = w.depth > w.length;
        if (isVertical) {
          // Stepout extends left/right, adds to width
          actualW = pw + Math.round(w.stepout.depth);
        } else {
          // Stepout extends down/up, adds to height
          actualH = ph + Math.round(w.stepout.depth);
        }
      }
      
      const fits = (actualW <= SLAB_W && actualH <= SLAB_H) || (actualH <= SLAB_W && actualW <= SLAB_H);
      if (!fits) {
        oversizedPieces.push(`${w.name} (${actualW}√ó${actualH}mm)`);
      }
      pieces.push({
        name: isLShape ? `${w.name} (L)` : w.name,
        width: actualW,
        height: actualH,
        type: 'worktop',
        color: isLShape ? '#d4e6f1' : '#e3f2fd', // Slightly different blue for L-shapes
        error: !fits,
        isLShape: isLShape,
        stepout: w.stepout
      });
    }
    
    // DON'T add stepout as separate piece - it's part of the L-shape bounding box
  });
  
  upstands.forEach(u => {
    const pw = Math.round(u.length);
    const ph = Math.round(u.isWindowCill ? (u.depth || 200) : u.height);
    
    // Skip pieces with invalid dimensions (less than 10mm)
    if (pw < 10 || ph < 10) {
      console.warn('Skipping invalid upstand piece:', pw, '√ó', ph);
      return;
    }
    
    // Determine piece type and color
    let typeName, pieceType, color;
    if (u.isWindowCill) {
      typeName = 'Cill';
      pieceType = 'cill';
      color = '#fff3e0';
    } else if (u.isSplash) {
      typeName = 'Splash';
      pieceType = 'splash';
      color = '#e0f7fa';
    } else {
      typeName = 'Upstand';
      pieceType = 'upstand';
      color = '#e8f5e9';
    }
    
    const fits = (pw <= SLAB_W && ph <= SLAB_H) || (ph <= SLAB_W && pw <= SLAB_H);
    pieces.push({ 
      name: typeName, 
      width: pw, 
      height: ph, 
      type: pieceType, 
      color: color, 
      error: !fits,
      upstandRef: u // Reference for auto-split marking
    });
    if (!fits) oversizedPieces.push(`${typeName} (${pw}√ó${ph}mm)`);
  });
  
  worktops.forEach(w => {
    if (w.edgeTypes) {
      Object.entries(w.edgeTypes).forEach(([k, v]) => {
        if (v.type === 'dropdown' || v.type === 'mitred_edge') {
          // Parse key - handle both normal edges (front_0_3000) and stepout edges (stepout_bottom_0_620)
          const parts = k.split('_');
          let s, e;
          if (parts[0] === 'stepout') {
            s = parts[2];
            e = parts[3];
          } else {
            s = parts[1];
            e = parts[2];
          }
          
          const pw = Math.round(parseInt(e) - parseInt(s));
          const ph = Math.round(v.height);
          const fits = (pw <= SLAB_W && ph <= SLAB_H) || (ph <= SLAB_W && pw <= SLAB_H);
          
          if (v.type === 'dropdown') {
            pieces.push({ name: 'Dropdown (Mitre)', width: pw, height: ph, type: 'dropdown', color: '#f3e5f5', error: !fits });
            if (!fits) oversizedPieces.push(`Dropdown (${pw}√ó${ph}mm)`);
          } else {
            pieces.push({ name: 'Mitred Edge', width: pw, height: ph, type: 'mitred_edge', color: '#d7ccc8', error: !fits });
            if (!fits) oversizedPieces.push(`Mitred Edge (${pw}√ó${ph}mm)`);
          }
        }
      });
    }
  });
  
  // TWO-PHASE PACKING: Bulk pieces first, thin accessories second
  // This ensures thin pieces fill gaps left by larger pieces
  
  // PRE-ROTATE: Make all pieces "horizontal" (wider than tall) before packing
  // This ensures consistent layout on the slab
  const normalizedPieces = pieces.map(p => {
    if (p.height > p.width) {
      // Rotate to be horizontal
      return { ...p, width: p.height, height: p.width, preRotated: true };
    }
    return { ...p, preRotated: false };
  });
  
  // Classify pieces: bulk (large) vs thin (small accessories)
  // Large splashbacks/cills should be treated as bulk pieces
  const BULK_AREA_THRESHOLD = 200000; // 200,000 sq mm (e.g., 500√ó400)
  
  const bulkPieces = normalizedPieces.filter(p => {
    // Worktops, dropdowns, mitred edges are always bulk
    if (p.type === 'worktop' || p.type === 'dropdown' || p.type === 'mitred_edge') return true;
    // Large splashbacks/cills/upstands should also be bulk
    const area = p.width * p.height;
    return area >= BULK_AREA_THRESHOLD;
  });
  
  const thinPieces = normalizedPieces.filter(p => {
    if (p.type === 'worktop' || p.type === 'dropdown' || p.type === 'mitred_edge') return false;
    const area = p.width * p.height;
    return area < BULK_AREA_THRESHOLD;
  });
  
  // Sort bulk pieces by area (largest first)
  bulkPieces.sort((a, b) => {
    if (a.error && !b.error) return 1;
    if (!a.error && b.error) return -1;
    return (b.width * b.height) - (a.width * a.height);
  });
  
  // Sort thin pieces by area (smallest first - they fill gaps better)
  thinPieces.sort((a, b) => {
    if (a.error && !b.error) return 1;
    if (!a.error && b.error) return -1;
    return (a.width * a.height) - (b.width * b.height);
  });
  
  // Combine: bulk first, then thin
  const sortedPieces = [...bulkPieces, ...thinPieces];
  
  const slabs = [];
  
  // MaxRects bin packing algorithm - much better at filling gaps
  function createSlab() {
    return {
      pieces: [],
      freeRects: [{ x: 0, y: 0, w: SLAB_W, h: SLAB_H }]
    };
  }
  
  function findBestRect(slab, pw, ph) {
    let bestScore = Infinity;
    let bestRect = null;
    let bestRotated = false;
    
    for (const rect of slab.freeRects) {
      // Try normal orientation
      if (pw <= rect.w && ph <= rect.h) {
        // Score = how much space is wasted, prefer tighter fits
        let score = (rect.w - pw) + (rect.h - ph);
        
        // Strong penalty if piece would be taller than wide (vertical)
        if (ph > pw) {
          score += 500000;
        }
        
        if (score < bestScore) {
          bestScore = score;
          bestRect = rect;
          bestRotated = false;
        }
      }
      
      // Try rotated (if different dimensions)
      if (pw !== ph && ph <= rect.w && pw <= rect.h) {
        // After rotation: width=ph, height=pw
        let score = (rect.w - ph) + (rect.h - pw);
        
        // Strong penalty if rotated piece would be taller than wide
        if (pw > ph) {
          score += 500000;
        }
        
        if (score < bestScore) {
          bestScore = score;
          bestRect = rect;
          bestRotated = true;
        }
      }
    }
    
    return bestRect ? { rect: bestRect, rotated: bestRotated } : null;
  }
  
  function placePiece(slab, rect, pw, ph, rotated) {
    const actualW = rotated ? ph : pw;
    const actualH = rotated ? pw : ph;
    
    const placed = {
      x: rect.x,
      y: rect.y,
      w: actualW,
      h: actualH,
      rotated: rotated
    };
    
    // Remove the used rect and split remaining space
    const newRects = [];
    
    for (const freeRect of slab.freeRects) {
      // Check if this free rect overlaps with the placed piece
      if (rectsOverlap(freeRect, placed)) {
        // Split into up to 4 new rectangles around the placed piece
        
        // Right of placed piece
        if (placed.x + placed.w < freeRect.x + freeRect.w) {
          newRects.push({
            x: placed.x + placed.w,
            y: freeRect.y,
            w: freeRect.x + freeRect.w - (placed.x + placed.w),
            h: freeRect.h
          });
        }
        
        // Left of placed piece
        if (placed.x > freeRect.x) {
          newRects.push({
            x: freeRect.x,
            y: freeRect.y,
            w: placed.x - freeRect.x,
            h: freeRect.h
          });
        }
        
        // Below placed piece
        if (placed.y + placed.h < freeRect.y + freeRect.h) {
          newRects.push({
            x: freeRect.x,
            y: placed.y + placed.h,
            w: freeRect.w,
            h: freeRect.y + freeRect.h - (placed.y + placed.h)
          });
        }
        
        // Above placed piece
        if (placed.y > freeRect.y) {
          newRects.push({
            x: freeRect.x,
            y: freeRect.y,
            w: freeRect.w,
            h: placed.y - freeRect.y
          });
        }
      } else {
        // No overlap, keep this rect
        newRects.push(freeRect);
      }
    }
    
    // Remove duplicates and contained rectangles
    slab.freeRects = pruneRects(newRects);
    
    return placed;
  }
  
  function rectsOverlap(a, b) {
    return !(a.x >= b.x + b.w || a.x + a.w <= b.x || 
             a.y >= b.y + b.h || a.y + a.h <= b.y);
  }
  
  function pruneRects(rects) {
    // Remove rectangles that are fully contained within others
    const result = [];
    for (let i = 0; i < rects.length; i++) {
      let dominated = false;
      for (let j = 0; j < rects.length; j++) {
        if (i !== j && isContained(rects[i], rects[j])) {
          dominated = true;
          break;
        }
      }
      if (!dominated && rects[i].w > 0 && rects[i].h > 0) {
        result.push(rects[i]);
      }
    }
    return result;
  }
  
  function isContained(inner, outer) {
    return inner.x >= outer.x && inner.y >= outer.y &&
           inner.x + inner.w <= outer.x + outer.w &&
           inner.y + inner.h <= outer.y + outer.h;
  }
  
  function tryPlacePiece(slab, pw, ph) {
    const best = findBestRect(slab, pw, ph);
    if (!best) return null;
    return placePiece(slab, best.rect, pw, ph, best.rotated);
  }
  
  // Check if a piece can fit on any existing slab (without placing it)
  function canFitOnExistingSlabs(pw, ph) {
    for (const slab of slabs) {
      if (findBestRect(slab, pw, ph)) return true;
    }
    return false;
  }
  
  // Track placed upstands for potential swap
  const placedUpstands = [];
  let needsRepack = false;
  
  sortedPieces.forEach(piece => {
    if (piece.error) {
      // Oversized piece - create its own slab with error
      const newSlab = createSlab();
      newSlab.pieces.push({ ...piece, x: 0, y: 0, pw: piece.width, ph: piece.height, rotated: false });
      slabs.push(newSlab);
      return;
    }
    
    let placed = null;
    let placedSlab = null;
    
    // Try each existing slab
    for (let slab of slabs) {
      placed = tryPlacePiece(slab, piece.width, piece.height);
      if (placed) {
        placedSlab = slab;
        break;
      }
    }
    
    // Track placed upstands for potential swap
    if (placed && ['upstand', 'splash', 'cill'].includes(piece.type) && piece.upstandRef) {
      placedUpstands.push({ piece, placed, placedSlab });
    }
    
    // Need new slab? Try auto-split first for upstands/splashbacks/cills
    if (!placed) {
      const pw = piece.width;
      const ph = piece.height;
      const canSplit = ['upstand', 'splash', 'cill'].includes(piece.type) && 
                       piece.upstandRef && 
                       pw > 1000;
      
      if (canSplit && slabs.length > 0) {
        // First check if splitting THIS piece would save a slab
        const halfLen = Math.floor((pw - 3) / 2);
        const piece1W = halfLen;
        const piece2W = pw - halfLen - 3;
        
        const half1Fits = canFitOnExistingSlabs(piece1W, ph);
        const half2Fits = canFitOnExistingSlabs(piece2W, ph);
        
        if (half1Fits && half2Fits) {
          // Splitting this piece would save a slab!
          // But check if there's a LONGER upstand we could split instead
          const longerCandidate = placedUpstands
            .filter(p => p.piece.type === piece.type && p.piece.width > pw && !p.piece.upstandRef.autoSplitPos)
            .sort((a, b) => b.piece.width - a.piece.width)[0];
          
          if (longerCandidate) {
            const longerW = longerCandidate.piece.width;
            const longerH = longerCandidate.piece.height;
            const longerHalf = Math.floor((longerW - 3) / 2);
            const longer1Fits = canFitOnExistingSlabs(longerHalf, longerH);
            const longer2Fits = canFitOnExistingSlabs(longerW - longerHalf - 3, longerH);
            
            if (longer1Fits && longer2Fits) {
              longerCandidate.piece.upstandRef.autoSplitPos = longerHalf;
              console.log(`Auto-split LONGER ${longerCandidate.piece.name}: ${longerW}mm (instead of ${pw}mm) - prefer longer`);
              needsRepack = true;
              return;
            }
          }
          
          // No longer candidate, split this piece
          piece.upstandRef.autoSplitPos = halfLen;
          console.log(`Auto-split ${piece.name}: ${pw}mm ‚Üí ${piece1W}mm + ${piece2W}mm - will repack`);
          needsRepack = true;
          return;
        }
      }
      
      // Couldn't auto-split, create new slab
      const newSlab = createSlab();
      placed = tryPlacePiece(newSlab, piece.width, piece.height);
      
      if (placed) {
        placedSlab = newSlab;
        slabs.push(newSlab);
        console.log(`NEW SLAB ${slabs.length} created for ${piece.name} (${piece.width}√ó${piece.height})`);
      } else {
        // Shouldn't happen if error check worked
        console.log(`ERROR: Could not place ${piece.name} (${piece.width}√ó${piece.height}) - creating error slab`);
        newSlab.pieces.push({ ...piece, x: 0, y: 0, pw: piece.width, ph: piece.height, rotated: false, error: true });
        slabs.push(newSlab);
        return;
      }
    }
    
    placedSlab.pieces.push({
      ...piece,
      x: placed.x,
      y: placed.y,
      pw: placed.w,
      ph: placed.h,
      rotated: placed.rotated
    });
    
    // For L-shapes with LARGER stepouts, add the empty corner back as usable space
    // Small stepouts (<=150mm) are cut as simple rectangles, no corner recovery needed
    // Need 100mm gap from L-shape for cutting separation
    const MIN_STEPOUT_FOR_LSHAPE = 150; // Only recover corner for stepouts larger than this
    const CUTTING_GAP = 100; // Gap needed between L-shape and other pieces
    
    if (piece.isLShape && piece.stepout && piece.stepout.depth > MIN_STEPOUT_FOR_LSHAPE) {
      const s = piece.stepout;
      
      // Check if piece was rotated on slab (in addition to preRotation)
      const totalRotation = (piece.preRotated ? 1 : 0) + (placed.rotated ? 1 : 0);
      const effectivelyRotated = totalRotation % 2 === 1;
      
      console.log(`L-SHAPE: corner=${s.corner}, preRotated=${piece.preRotated}, slabRotated=${placed.rotated}, effectivelyRotated=${effectivelyRotated}`);
      console.log(`  Placed at (${placed.x}, ${placed.y}) size ${placed.w}√ó${placed.h}`);
      console.log(`  Stepout: length=${s.length}, depth=${s.depth}`);
      
      let cornerX, cornerY, cornerW, cornerH;
      
      if (!effectivelyRotated) {
        // No effective rotation - standard orientation
        // L-shape: main worktop on top, stepout extends down on one side
        // Gap needs to be between main worktop edge and the recovered corner
        if (s.corner === 'front-left') {
          // Stepout at bottom-left, empty corner at bottom-right of main worktop level
          // Main worktop bottom edge is at placed.y + (placed.h - s.depth)
          // Gap goes between main worktop and corner area
          cornerX = placed.x + s.length + CUTTING_GAP;  // Gap from stepout right edge
          cornerY = placed.y + placed.h - s.depth + CUTTING_GAP;  // Gap from main worktop bottom
          cornerW = placed.w - s.length - CUTTING_GAP;
          cornerH = s.depth - CUTTING_GAP;
        } else if (s.corner === 'front-right') {
          // Stepout at bottom-right
          cornerX = placed.x;
          cornerY = placed.y + placed.h - s.depth + CUTTING_GAP;
          cornerW = placed.w - s.length - CUTTING_GAP;
          cornerH = s.depth - CUTTING_GAP;
        } else if (s.corner === 'back-left') {
          // Stepout at top-left, corner at top-right
          cornerX = placed.x + s.length + CUTTING_GAP;
          cornerY = placed.y;
          cornerW = placed.w - s.length - CUTTING_GAP;
          cornerH = s.depth - CUTTING_GAP;
        } else if (s.corner === 'back-right') {
          // Stepout at top-right, corner at top-left
          cornerX = placed.x;
          cornerY = placed.y;
          cornerW = placed.w - s.length - CUTTING_GAP;
          cornerH = s.depth - CUTTING_GAP;
        }
      } else {
        // Effectively rotated 90¬∞
        if (s.corner === 'front-left') {
          cornerX = placed.x + placed.w - s.depth + CUTTING_GAP;
          cornerY = placed.y + s.length + CUTTING_GAP;
          cornerW = s.depth - CUTTING_GAP;
          cornerH = placed.h - s.length - CUTTING_GAP;
        } else if (s.corner === 'front-right') {
          cornerX = placed.x + placed.w - s.depth + CUTTING_GAP;
          cornerY = placed.y;
          cornerW = s.depth - CUTTING_GAP;
          cornerH = placed.h - s.length - CUTTING_GAP;
        } else if (s.corner === 'back-left') {
          cornerX = placed.x;
          cornerY = placed.y + s.length + CUTTING_GAP;
          cornerW = s.depth - CUTTING_GAP;
          cornerH = placed.h - s.length - CUTTING_GAP;
        } else if (s.corner === 'back-right') {
          cornerX = placed.x;
          cornerY = placed.y;
          cornerW = s.depth - CUTTING_GAP;
          cornerH = placed.h - s.length - CUTTING_GAP;
        }
      }
      
      // Add the empty corner as a free rectangle
      if (cornerW > 50 && cornerH > 50) {
        placedSlab.freeRects.push({
          x: cornerX,
          y: cornerY,
          w: cornerW,
          h: cornerH
        });
        console.log(`  L-SHAPE CORNER RECOVERED: ${cornerW}√ó${cornerH} at (${cornerX},${cornerY})`);
        
        // IMPORTANT: Also create a MERGED rectangle that extends from the corner
        // down to the bottom of the slab (or to existing free space below)
        // This captures the large area the user highlighted in red
        
        const spaceBelow = SLAB_H - (cornerY + cornerH);
        if (spaceBelow > 50) {
          // Create merged rectangle from corner top to slab bottom
          const mergedH = cornerH + spaceBelow;
          placedSlab.freeRects.push({
            x: cornerX,
            y: cornerY,
            w: cornerW,
            h: mergedH
          });
          console.log(`  L-SHAPE MERGED SPACE: ${cornerW}√ó${mergedH} at (${cornerX},${cornerY})`);
        }
        
        // Prune and merge free rectangles
        placedSlab.freeRects = pruneRects(placedSlab.freeRects);
      } else {
        console.log(`  L-SHAPE CORNER TOO SMALL: ${cornerW}√ó${cornerH}`);
      }
    }
    
    console.log(`PLACED: ${piece.name} (${piece.width}√ó${piece.height}) at (${placed.x},${placed.y}) as ${placed.w}√ó${placed.h} rotated=${placed.rotated} on slab ${slabs.indexOf(placedSlab) + 1}`);
    console.log(`  Free rects remaining:`, placedSlab.freeRects.length);
  });
  
  // If auto-splits were detected, we need to repack with the split pieces
  // If auto-splits were detected, we need to repack with the split pieces
  // This may need multiple passes if splitting one enables fitting more
  let repackIteration = 0;
  const MAX_REPACK_ITERATIONS = 5;
  
  while (needsRepack && repackIteration < MAX_REPACK_ITERATIONS) {
    repackIteration++;
    needsRepack = false; // Reset - will be set again if more splits needed
    
    console.log(`=== REPACKING SLAB LAYOUT (iteration ${repackIteration}) ===`);
    
    // Rebuild pieces array with splits applied
    const repackPieces = [];
    
    // Re-add worktops and dropdowns (unchanged)
    pieces.filter(p => !['upstand', 'splash', 'cill'].includes(p.type)).forEach(p => {
      repackPieces.push(p);
    });
    
    // Re-add upstands with splits applied
    pieces.filter(p => ['upstand', 'splash', 'cill'].includes(p.type)).forEach(p => {
      if (p.upstandRef && p.upstandRef.autoSplitPos) {
        const splitPos = p.upstandRef.autoSplitPos;
        const piece1W = splitPos;
        const piece2W = p.width - splitPos - 3;
        
        repackPieces.push({
          ...p,
          name: `${p.name} (1/2)`,
          width: piece1W,
          autoSplit: true
        });
        repackPieces.push({
          ...p,
          name: `${p.name} (2/2)`,
          width: piece2W,
          autoSplit: true
        });
      } else {
        repackPieces.push(p);
      }
    });
    
    // Sort by area descending
    repackPieces.sort((a, b) => (b.width * b.height) - (a.width * a.height));
    
    // Clear slabs and repack
    slabs.length = 0;
    const repackPlacedUpstands = [];
    
    repackPieces.forEach(piece => {
      if (piece.error) {
        const newSlab = createSlab();
        newSlab.pieces.push({ ...piece, x: 0, y: 0, pw: piece.width, ph: piece.height, rotated: false });
        slabs.push(newSlab);
        return;
      }
      
      let placed = null;
      let placedSlab = null;
      
      for (let slab of slabs) {
        placed = tryPlacePiece(slab, piece.width, piece.height);
        if (placed) {
          placedSlab = slab;
          break;
        }
      }
      
      // Track placed upstands for potential further splits
      if (placed && ['upstand', 'splash', 'cill'].includes(piece.type) && piece.upstandRef && !piece.autoSplit) {
        repackPlacedUpstands.push({ piece, pw: piece.width, ph: piece.height });
      }
      
      // Need new slab? Check for auto-split opportunity
      if (!placed) {
        const pw = piece.width;
        const ph = piece.height;
        const canSplit = ['upstand', 'splash', 'cill'].includes(piece.type) && 
                         piece.upstandRef && 
                         !piece.autoSplit && // Don't split already-split pieces
                         pw > 1000;
        
        if (canSplit && slabs.length > 0) {
          const halfLen = Math.floor((pw - 3) / 2);
          const piece1W = halfLen;
          const piece2W = pw - halfLen - 3;
          
          const half1Fits = canFitOnExistingSlabs(piece1W, ph);
          const half2Fits = canFitOnExistingSlabs(piece2W, ph);
          
          if (half1Fits && half2Fits) {
            // Check for longer candidate to split instead
            const longerCandidate = repackPlacedUpstands
              .filter(p => p.piece.type === piece.type && p.pw > pw && !p.piece.upstandRef.autoSplitPos)
              .sort((a, b) => b.pw - a.pw)[0];
            
            if (longerCandidate) {
              const longerW = longerCandidate.pw;
              const longerHalf = Math.floor((longerW - 3) / 2);
              const longer1Fits = canFitOnExistingSlabs(longerHalf, longerCandidate.ph);
              const longer2Fits = canFitOnExistingSlabs(longerW - longerHalf - 3, longerCandidate.ph);
              
              if (longer1Fits && longer2Fits) {
                longerCandidate.piece.upstandRef.autoSplitPos = longerHalf;
                console.log(`Repack: Auto-split LONGER ${longerCandidate.piece.name}: ${longerW}mm (instead of ${pw}mm)`);
                needsRepack = true;
                return;
              }
            }
            
            piece.upstandRef.autoSplitPos = halfLen;
            console.log(`Repack: Auto-split ${piece.name}: ${pw}mm ‚Üí ${piece1W}mm + ${piece2W}mm`);
            needsRepack = true;
            return;
          }
        }
        
        // Couldn't auto-split, create new slab
        const newSlab = createSlab();
        placed = tryPlacePiece(newSlab, piece.width, piece.height);
        if (placed) {
          placedSlab = newSlab;
          slabs.push(newSlab);
        }
      }
      
      if (placedSlab && placed) {
        placedSlab.pieces.push({
          ...piece,
          x: placed.x,
          y: placed.y,
          pw: placed.w,
          ph: placed.h,
          rotated: placed.rotated
        });
      }
    });
    
    console.log(`Repack iteration ${repackIteration} complete: ${slabs.length} slabs`);
  }
  
  // Calculate canvas size for scrolling - use FIXED height per slab
  const PADDING = 30;
  const FIXED_SLAB_H = 260; // Fixed display height per slab
  const GAP_BETWEEN = 70; // Clear gap between slabs
  const slabDisplayScale = FIXED_SLAB_H / SLAB_H;
  const SLAB_DISPLAY_W = SLAB_W * slabDisplayScale;
  
  // Calculate total height needed
  const totalHeight = PADDING * 2 + slabs.length * (FIXED_SLAB_H + GAP_BETWEEN) + 60;
  
  // Use fixed width if container is hidden (tab not visible)
  // Minimum width should fit the slab display plus padding
  const minWidth = SLAB_DISPLAY_W + PADDING * 2 + 20;
  const canvasWidth = container.clientWidth > 0 ? container.clientWidth : minWidth;
  const canvasHeight = Math.max(container.clientHeight > 0 ? container.clientHeight : totalHeight, totalHeight);
  
  slabCanvas.width = canvasWidth;
  slabCanvas.height = canvasHeight;
  slabCanvas.style.height = slabCanvas.height + 'px';
  
  const ctx = slabCanvas.getContext('2d');
  ctx.fillStyle = '#e8e8e8';
  ctx.fillRect(0, 0, slabCanvas.width, slabCanvas.height);
  
  let totalArea = 0, usedArea = 0;
  
  slabs.forEach((slab, idx) => {
    const sx = PADDING;
    const sy = PADDING + idx * (FIXED_SLAB_H + GAP_BETWEEN);
    
    // Slab label ABOVE the white box
    ctx.fillStyle = '#1e4d3a';
    ctx.font = 'bold 13px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText(`Slab ${idx + 1} (${SLAB_W}√ó${SLAB_H}mm)`, sx, sy - 8);
    
    // White slab background
    ctx.fillStyle = '#fff';
    ctx.fillRect(sx, sy, SLAB_DISPLAY_W, FIXED_SLAB_H);
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 2;
    ctx.strokeRect(sx, sy, SLAB_DISPLAY_W, FIXED_SLAB_H);
    
    totalArea += SLAB_W * SLAB_H;
    
    // Draw pieces within this slab
    slab.pieces.forEach(p => {
      const px = sx + p.x * slabDisplayScale;
      const py = sy + p.y * slabDisplayScale;
      const pw = p.pw * slabDisplayScale;
      const ph = p.ph * slabDisplayScale;
      
      usedArea += p.width * p.height;
      
      ctx.fillStyle = p.error ? '#ffcdd2' : p.color;
      ctx.strokeStyle = p.error ? '#c00' : '#555';
      ctx.lineWidth = 1;
      
      // Draw L-shape if this piece has stepout info
      if (p.isLShape && p.stepout) {
        const stepout = p.stepout;
        const isVertical = (p.height - stepout.depth) > (p.width - stepout.depth); // Original was taller
        const sLen = stepout.length * slabDisplayScale;
        const sDepth = stepout.depth * slabDisplayScale;
        
        // Calculate main worktop dimensions (before stepout was added)
        let mainW, mainH;
        if (isVertical) {
          mainW = pw - sDepth;
          mainH = ph;
        } else {
          mainW = pw;
          mainH = ph - sDepth;
        }
        
        ctx.beginPath();
        if (p.rotated) {
          // When rotated, the L-shape orientation changes
          if (isVertical) {
            // Was vertical, now horizontal after rotation
            // Stepout on bottom
            ctx.moveTo(px, py);
            ctx.lineTo(px + ph, py); // top edge (was height, now width)
            ctx.lineTo(px + ph, py + mainW); // right edge partial
            ctx.lineTo(px + sLen, py + mainW); // step in
            ctx.lineTo(px + sLen, py + pw); // down to bottom of stepout
            ctx.lineTo(px, py + pw); // left along bottom
            ctx.closePath();
          } else {
            // Was horizontal, now vertical after rotation
            // Stepout on right
            ctx.moveTo(px, py);
            ctx.lineTo(px + mainH, py); // top edge
            ctx.lineTo(px + mainH, py + sLen); // right partial
            ctx.lineTo(px + ph, py + sLen); // step out
            ctx.lineTo(px + ph, py + pw); // down right edge
            ctx.lineTo(px, py + pw); // bottom edge
            ctx.closePath();
          }
        } else {
          // Not rotated - draw based on corner
          const corner = stepout.corner || 'front-left';
          if (isVertical) {
            // Vertical worktop - stepout extends left/right
            if (corner === 'front-left' || corner === 'back-left') {
              // Stepout on left side, at bottom
              ctx.moveTo(px + sDepth, py);
              ctx.lineTo(px + pw, py);
              ctx.lineTo(px + pw, py + ph);
              ctx.lineTo(px, py + ph);
              ctx.lineTo(px, py + ph - sLen);
              ctx.lineTo(px + sDepth, py + ph - sLen);
              ctx.closePath();
            } else {
              // Stepout on right side, at bottom
              ctx.moveTo(px, py);
              ctx.lineTo(px + pw - sDepth, py);
              ctx.lineTo(px + pw - sDepth, py + ph - sLen);
              ctx.lineTo(px + pw, py + ph - sLen);
              ctx.lineTo(px + pw, py + ph);
              ctx.lineTo(px, py + ph);
              ctx.closePath();
            }
          } else {
            // Horizontal worktop - stepout extends down/up
            if (corner === 'front-left') {
              // Stepout at bottom-left
              ctx.moveTo(px, py);
              ctx.lineTo(px + pw, py);
              ctx.lineTo(px + pw, py + mainH);
              ctx.lineTo(px + sLen, py + mainH);
              ctx.lineTo(px + sLen, py + ph);
              ctx.lineTo(px, py + ph);
              ctx.closePath();
            } else if (corner === 'front-right') {
              // Stepout at bottom-right
              ctx.moveTo(px, py);
              ctx.lineTo(px + pw, py);
              ctx.lineTo(px + pw, py + ph);
              ctx.lineTo(px + pw - sLen, py + ph);
              ctx.lineTo(px + pw - sLen, py + mainH);
              ctx.lineTo(px, py + mainH);
              ctx.closePath();
            } else if (corner === 'back-left') {
              // Stepout at top-left
              ctx.moveTo(px, py);
              ctx.lineTo(px + sLen, py);
              ctx.lineTo(px + sLen, py + sDepth);
              ctx.lineTo(px + pw, py + sDepth);
              ctx.lineTo(px + pw, py + ph);
              ctx.lineTo(px, py + ph);
              ctx.closePath();
            } else {
              // Stepout at top-right
              ctx.moveTo(px, py + sDepth);
              ctx.lineTo(px + pw - sLen, py + sDepth);
              ctx.lineTo(px + pw - sLen, py);
              ctx.lineTo(px + pw, py);
              ctx.lineTo(px + pw, py + ph);
              ctx.lineTo(px, py + ph);
              ctx.closePath();
            }
          }
        }
        ctx.fill();
        ctx.stroke();
      } else {
        // Regular rectangle
        ctx.fillRect(px, py, pw, ph);
        ctx.strokeRect(px, py, pw, ph);
      }
      
      // Label
      ctx.fillStyle = '#333';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      
      if (pw > 70 && ph > 30) {
        ctx.font = 'bold 10px sans-serif';
        ctx.fillText(p.name, px + pw/2, py + ph/2 - 6);
        ctx.font = '9px sans-serif';
        ctx.fillText(`${p.width}√ó${p.height}`, px + pw/2, py + ph/2 + 6);
      } else if (pw > 40 && ph > 16) {
        ctx.font = '8px sans-serif';
        ctx.fillText(`${p.width}√ó${p.height}`, px + pw/2, py + ph/2);
      }
    });
  });
  
  // Summary at bottom
  const sumY = PADDING + slabs.length * (FIXED_SLAB_H + GAP_BETWEEN) + 10;
  const eff = totalArea > 0 ? ((usedArea / totalArea) * 100).toFixed(1) : 0;
  
  // Calculate profit using new model:
  // 1st slab: fixed profit
  // Additional slabs: ¬£ per sq ft of pieces placed on those slabs
  const slabCount = slabs.length;
  let additionalSlabsSqFt = 0;
  
  // Calculate total sq ft of pieces on slabs 2, 3, 4, etc.
  slabs.forEach((slab, slabIndex) => {
    if (slabIndex >= 1) { // Skip slab 1 (index 0)
      slab.pieces.forEach(p => {
        // Convert mm¬≤ to sq ft (1 sq ft = 92903.04 mm¬≤)
        const pieceSqFt = (p.pw * p.ph) / 92903.04;
        additionalSlabsSqFt += pieceSqFt;
      });
    }
  });
  
  const additionalSlabsProfit = additionalSlabsSqFt * profitPerSqFt;
  const profit = slabCount > 0 ? profit1st + additionalSlabsProfit : 0;
  
  // Store data for quote generation (slabCanvas already defined at top of function)
  if (slabCanvas) {
    slabCanvas._lastSlabData = {
      slabCount: slabCount,
      additionalSlabsSqFt: additionalSlabsSqFt,
      profit1st: profit1st,
      profitPerSqFt: profitPerSqFt,
      totalProfit: profit
    };
    console.log('Stored slab data:', slabCanvas._lastSlabData);
  } else {
    console.log('WARNING: slabCanvas not found, cannot store slab data');
  }
  
  ctx.fillStyle = '#1e4d3a';
  ctx.font = 'bold 13px sans-serif';
  ctx.textAlign = 'left';
  ctx.fillText('Summary', PADDING, sumY);
  
  ctx.fillStyle = '#333';
  ctx.font = '12px sans-serif';
  ctx.fillText(`Pieces: ${pieces.length}  |  Slabs: ${slabs.length}  |  Utilisation: ${eff}%  |  Slab: ${SLAB_W}√ó${SLAB_H}mm (workable)`, PADDING, sumY + 16);
  ctx.fillText(`Used: ${(usedArea / 1000000).toFixed(3)} m¬≤  |  Slab Area: ${(totalArea / 1000000).toFixed(2)} m¬≤`, PADDING, sumY + 32);
  
  // Show oversized warning
  if (oversizedPieces.length > 0) {
    ctx.fillStyle = '#c62828';
    ctx.font = 'bold 11px sans-serif';
    ctx.fillText(`‚ö†Ô∏è Oversized pieces (exceed ${SLAB_W}√ó${SLAB_H}mm): ${oversizedPieces.join(', ')}`, PADDING, sumY + 50);
  }
  
  // Update profit estimate in admin panel
  const profitEl = document.getElementById('slabPriceEstimate');
  if (profitEl) {
    if (slabCount > 1) {
      profitEl.innerHTML = `<strong>Fabrication Profit:</strong> ¬£${profit.toFixed(2)}<br>` +
        `<span style="font-size:10px;color:#666;">(¬£${profit1st} first slab + ${additionalSlabsSqFt.toFixed(1)} sq ft √ó ¬£${profitPerSqFt} = ¬£${additionalSlabsProfit.toFixed(2)})</span>`;
    } else {
      profitEl.innerHTML = `<strong>Fabrication Profit:</strong> ¬£${profit.toFixed(2)}<br>` +
        `<span style="font-size:10px;color:#666;">(¬£${profit1st} first slab)</span>`;
    }
  }
  
  // Legend on right
  const lx = PADDING + SLAB_DISPLAY_W + 30;
  ctx.fillStyle = '#333';
  ctx.font = 'bold 11px sans-serif';
  ctx.fillText('Legend:', lx, PADDING + 10);
  
  [
    { c: '#e3f2fd', l: 'Worktop' },
    { c: '#d4e6f1', l: 'L-Shape Worktop' },
    { c: '#e8f5e9', l: 'Upstand' },
    { c: '#e0f7fa', l: 'Splashback' },
    { c: '#fff3e0', l: 'Window Cill' },
    { c: '#f3e5f5', l: 'Dropdown (Mitre)' },
    { c: '#d7ccc8', l: 'Mitred Edge' }
  ].forEach((item, i) => {
    const ly = PADDING + 28 + i * 20;
    ctx.fillStyle = item.c;
    ctx.fillRect(lx, ly, 14, 14);
    ctx.strokeStyle = '#666';
    ctx.strokeRect(lx, ly, 14, 14);
    ctx.fillStyle = '#333';
    ctx.font = '10px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText(item.l, lx + 20, ly + 11);
  });
  
  // SYNC: Update summary panel slab count to match actual packing result
  const sumSlabsEl = document.getElementById('sumSlabs');
  if (sumSlabsEl) {
    sumSlabsEl.textContent = slabs.length;
  }
}

// ========== EVENTS ==========
canvas.addEventListener('mousedown', e => {
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left, my = e.clientY - rect.top;
  const mm = screenToMm(mx, my);
  
  if (spaceHeld || e.button === 1 || e.button === 2) {
    hideEdgeMenu();
    hideCornerMenu();
    isPanning = true;
    panStart = { x: mx, y: my, ox: offset.x, oy: offset.y };
    canvas.style.cursor = 'grabbing';
    return;
  }
  
  // Check CUTOUTS and UPSTANDS first (they sit on top of edges)
  if (!isDrawing) {
    const hit = findItemAt(mm.x, mm.y);
    // Only intercept if it's a cutout or upstand (not a worktop)
    if (hit && (hit.type === 'cutout' || hit.type === 'upstand')) {
      hideEdgeMenu();
      hideCornerMenu();
      selectItem(hit.type, hit.item.id);
      isDragging = true;
      
      // Different drag offset calculation for different item types
      if (hit.type === 'cutout' && hit.item.type === 'socket') {
        dragStart = { x: 0, y: 0, isSocket: true };
      } else {
        dragStart = { x: mm.x - (hit.item.x || 0), y: mm.y - (hit.item.y || 0) };
      }
      canvas.style.cursor = 'move';
      return;
    }
  }
  
  // Check CORNER click (takes priority over edge clicks)
  if (!isDrawing) {
    const cornerHit = findClickedCorner(mm.x, mm.y);
    if (cornerHit) {
      hideEdgeMenu();
      showCornerMenu(e.clientX, e.clientY, cornerHit.worktop.id, cornerHit.corner, cornerHit.label);
      return;
    }
  }
  
  // Check edge click (for any tool when not drawing)
  if (!isDrawing) {
    const edgeHit = findClickedEdge(mm.x, mm.y);
    if (edgeHit) {
      console.log('Edge detected:', edgeHit.edge, 'on worktop', edgeHit.worktop.id, 'segment:', edgeHit.segment);
      hideCornerMenu();
      // Don't hide - show new menu
      showEdgeMenu(e.clientX, e.clientY, edgeHit.worktop.id, edgeHit.edge, edgeHit.segment);
      return;
    }
  }
  
  // Hide menus when clicking elsewhere on canvas
  hideEdgeMenu();
  hideCornerMenu();
  
  // Check worktops (after edges, so edge menu works)
  if (!isDrawing) {
    const hit = findItemAt(mm.x, mm.y);
    if (hit && hit.type === 'worktop') {
      selectItem(hit.type, hit.item.id);
      isDragging = true;
      dragStart = { x: mm.x - (hit.item.x || 0), y: mm.y - (hit.item.y || 0) };
      canvas.style.cursor = 'move';
      return;
    }
  }
  
  // Drawing
  if (tool === 'worktop' || tool === 'upstand') {
    if (!isDrawing) {
      isDrawing = true;
      let sx = mm.x, sy = mm.y;
      if (activeSnap) { sx = activeSnap.x; sy = activeSnap.y; }
      drawStart = { x: sx, y: sy, endX: sx, endY: sy };
    } else {
      finishDrawing();
    }
  }
});

canvas.addEventListener('mousemove', e => {
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left, my = e.clientY - rect.top;
  const mm = screenToMm(mx, my);
  
  if (isPanning && panStart) {
    offset.x = panStart.ox + (mx - panStart.x);
    offset.y = panStart.oy + (my - panStart.y);
    render();
    return;
  }
  
  if (isDragging && selectedId) {
    if (selectedType === 'worktop') {
      let nx = mm.x - dragStart.x, ny = mm.y - dragStart.y;
      const w = worktops.find(w => w.id === selectedId);
      if (w) {
        // Calculate delta movement
        const deltaX = nx - w.x;
        const deltaY = ny - w.y;
        
        w.x = nx; w.y = ny;
        const snap = findDragSnap(w, 'worktop');
        if (snap) {
          w.x += snap.dx;
          w.y += snap.dy;
          activeSnap = { x: snap.x, y: snap.y };
        } else {
          activeSnap = null;
        }
        
        // Calculate final delta after snap
        const finalDeltaX = w.x - (nx - deltaX);
        const finalDeltaY = w.y - (ny - deltaY);
        
        // Move cutouts with the worktop
        cutouts.forEach(c => {
          if (c.parentId === w.id) {
            c.x += finalDeltaX;
            c.y += finalDeltaY;
          }
        });
        
        // Update attached upstands position when worktop moves
        upstands.forEach(u => {
          if (u.parentId === w.id && !u.isContinuous) {
            u.x += finalDeltaX;
            u.y += finalDeltaY;
            if (u.absoluteX !== undefined) u.absoluteX += finalDeltaX;
            if (u.absoluteY !== undefined) u.absoluteY += finalDeltaY;
          }
        });
      }
    } else if (selectedType === 'upstand') {
      const u = upstands.find(u => u.id === selectedId);
      if (u && !u.parentId) {
        // Only allow dragging free-standing upstands
        u.x = mm.x - dragStart.x;
        u.y = mm.y - dragStart.y;
        activeSnap = null;
      }
    } else if (selectedType === 'cutout') {
      const c = cutouts.find(c => c.id === selectedId);
      if (c && c.type === 'tap') {
        // Tap holes are draggable
        const parent = worktops.find(w => w.id === c.parentId);
        if (parent) {
          // Calculate new position
          let nx = mm.x;
          let ny = mm.y;
          
          // Constrain to parent worktop bounds
          nx = Math.max(parent.x + c.diameter/2, Math.min(parent.x + parent.length - c.diameter/2, nx));
          ny = Math.max(parent.y + c.diameter/2, Math.min(parent.y + parent.depth - c.diameter/2, ny));
          
          c.x = nx;
          c.y = ny;
          activeSnap = null;
          renderProps(); // Update properties panel with new position
        }
      } else if (c && c.type === 'socket') {
        // Sockets on splashbacks are draggable
        const parent = upstands.find(u => u.id === c.parentId);
        if (parent) {
          const pw = worktops.find(w => w.id === parent.parentId);
          const edge = parent.parentEdge || 'back';
          const edgeStart = parent.edgeStart || 0;
          const splashHeight = parent.height;
          const isVertical = (edge === 'left' || edge === 'right');
          
          let spX, spY;
          
          // Get splashback position - use same logic as 2D rendering
          if (parent.isContinuous && parent.absoluteX !== undefined) {
            // Continuous splashback - use absolute position
            if (edge === 'back') {
              spX = parent.absoluteX;
              spY = parent.absoluteY - splashHeight;
            } else if (edge === 'front') {
              spX = parent.absoluteX;
              spY = parent.absoluteY;
            } else if (edge === 'left') {
              spX = parent.absoluteX - splashHeight;
              spY = parent.absoluteY;
            } else { // right
              spX = parent.absoluteX;
              spY = parent.absoluteY;
            }
          } else if (pw) {
            // Non-continuous with parent worktop
            if (edge === 'back') {
              spX = pw.x + edgeStart;
              spY = pw.y - splashHeight;
            } else if (edge === 'front') {
              spX = pw.x + edgeStart;
              spY = pw.y + pw.depth;
            } else if (edge === 'left') {
              spX = pw.x - splashHeight;
              spY = pw.y + edgeStart;
            } else { // right
              spX = pw.x + pw.length;
              spY = pw.y + edgeStart;
            }
          } else {
            // Fallback
            spX = parent.absoluteX || parent.x || 0;
            spY = parent.absoluteY || parent.y || (edge === 'back' ? -splashHeight : 0);
          }
          
          // Calculate centerX/centerY based on orientation
          let centerX, centerY;
          
          if (isVertical) {
            // For vertical splashbacks (left/right):
            // centerX runs along the LENGTH (vertical in screen coords)
            // centerY is horizontal distance from worktop edge
            centerX = mm.y - spY;
            centerY = (edge === 'left') 
              ? (splashHeight - (mm.x - spX))
              : (mm.x - spX);
          } else {
            // For horizontal splashbacks (back/front):
            // centerX is from left edge of splashback
            // centerY is from BOTTOM edge of splashback
            centerX = mm.x - spX;
            centerY = splashHeight - (mm.y - spY);
          }
          
          // Constrain to splashback bounds only (NOT worktop joins)
          centerX = Math.max(c.width/2, Math.min(parent.length - c.width/2, centerX));
          centerY = Math.max(c.height/2, Math.min(splashHeight - c.height/2, centerY));
          
          c.centerX = centerX;
          c.centerY = centerY;
          
          activeSnap = null;
          renderProps();
        }
      }
    }
    detectAllJoints();
    render();
    return;
  }
  
  if (isDrawing && drawStart) {
    let ex = mm.x, ey = mm.y;
    const snap = findSnapPoint(ex, ey);
    if (snap) { 
      // Prefer corner snaps, but also use edge snaps
      if (snap.type === 'corner' || snap.type === 'upstand-corner') {
        ex = snap.x; 
        ey = snap.y;
      } else if (snap.type === 'edge-x' || snap.type === 'upstand-edge-x') {
        ex = snap.x;
      } else if (snap.type === 'edge-y' || snap.type === 'upstand-edge-y' || snap.type === 'back-edge') {
        ey = snap.y;
      }
      activeSnap = { x: ex, y: ey }; 
    } else {
      activeSnap = null;
    }
    drawStart.endX = ex;
    drawStart.endY = ey;
    render();
    return;
  }
  
  activeSnap = findSnapPoint(mm.x, mm.y);
  render();
});

canvas.addEventListener('mouseup', () => {
  if (isPanning) { isPanning = false; canvas.style.cursor = 'crosshair'; }
  if (isDragging) { 
    isDragging = false; 
    canvas.style.cursor = 'crosshair'; 
    detectAllJoints(); 
    checkAndSplitUpstands(); // Check if splashback was dropped on upstand
    updateSummary(); 
  }
});

canvas.addEventListener('dblclick', e => {
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left, my = e.clientY - rect.top;
  const mm = screenToMm(mx, my);
  
  // Check if double-clicked on a worktop, upstand, or cutout
  const hit = findItemAt(mm.x, mm.y);
  if (hit && hit.type === 'worktop') {
    showWorktopEditModal(hit.item.id);
  } else if (hit && hit.type === 'upstand') {
    // Check if it's a cill - show simpler modal
    if (hit.item.isWindowCill) {
      showCillEditModal(hit.item.id);
    } else {
      showUpstandSplitModal(hit.item.id);
    }
  } else if (hit && hit.type === 'cutout') {
    showCutoutEditModal(hit.item.id);
  } else {
    clearSelection();
  }
});
canvas.addEventListener('contextmenu', e => { e.preventDefault(); if (isDrawing) { isDrawing = false; drawStart = null; render(); } });

canvas.addEventListener('wheel', e => {
  e.preventDefault();
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left, my = e.clientY - rect.top;
  const f = e.deltaY > 0 ? 0.9 : 1.1;
  const os = scale;
  scale = Math.max(0.05, Math.min(0.8, scale * f));
  offset.x = mx - (mx - offset.x) * (scale / os);
  offset.y = my - (my - offset.y) * (scale / os);
  updateZoom();
  render();
});

function finishDrawing() {
  if (!drawStart) return;
  const minX = Math.min(drawStart.x, drawStart.endX);
  const minY = Math.min(drawStart.y, drawStart.endY);
  const w = Math.abs(drawStart.endX - drawStart.x);
  const h = Math.abs(drawStart.endY - drawStart.y);
  
  if (w > 50 || h > 50) {
    saveHistory();
    if (tool === 'worktop') {
      const worktopLen = Math.round(Math.max(w, 200));
      const worktopDepth = Math.round(Math.max(h, 200));
      
      // Validate against slab size (3200x1600 default)
      const maxDim = Math.max(SLAB_W, SLAB_H);
      const minDim = Math.min(SLAB_W, SLAB_H);
      
      // Check if worktop can fit on slab (in either orientation)
      const canFitNormal = worktopLen <= SLAB_W && worktopDepth <= SLAB_H;
      const canFitRotated = worktopLen <= SLAB_H && worktopDepth <= SLAB_W;
      
      if (!canFitNormal && !canFitRotated) {
        alert(`‚ö†Ô∏è Worktop too large!\n\nDrawn size: ${worktopLen}mm √ó ${worktopDepth}mm\nMax slab size: ${SLAB_W}mm √ó ${SLAB_H}mm\n\nPlease draw a smaller worktop or use multiple pieces with joints.`);
        isDrawing = false;
        drawStart = null;
        activeSnap = null;
        render();
        return;
      }
      
      const worktopNum = worktops.length + 1;
      worktops.push({
        id: nextId++, name: `Worktop ${worktopNum}`,
        x: minX, y: minY,
        length: worktopLen, depth: worktopDepth,
        joints: { back: [], front: [], left: [], right: [] }, edgeTypes: {},
        cornerRadii: { tl: 0, tr: 0, br: 0, bl: 0 }  // Top-left, top-right, bottom-right, bottom-left
      });
      detectAllJoints();
    } else if (tool === 'upstand') {
      const vertical = h > w;
      const len = Math.round(vertical ? h : w);
      const ht = prompt('Height (mm) - 100 for upstand, 300+ for splash:', '100');
      if (ht) {
        const height = parseInt(ht) || 100;
        const isSplash = height > 150;
        
        // Try to find which worktop edge this is near
        let foundParent = null;
        let foundEdge = null;
        let foundStart = 0;
        const tolerance = 100;
        
        worktops.forEach(wt => {
          // Check back edge
          if (Math.abs(minY - wt.y) < tolerance && 
              minX >= wt.x - 50 && minX <= wt.x + wt.length + 50) {
            foundParent = wt;
            foundEdge = 'back';
            foundStart = Math.max(0, minX - wt.x);
          }
          // Check front edge
          else if (Math.abs(minY - (wt.y + wt.depth)) < tolerance &&
              minX >= wt.x - 50 && minX <= wt.x + wt.length + 50) {
            foundParent = wt;
            foundEdge = 'front';
            foundStart = Math.max(0, minX - wt.x);
          }
          // Check left edge
          else if (Math.abs(minX - wt.x) < tolerance &&
              minY >= wt.y - 50 && minY <= wt.y + wt.depth + 50) {
            foundParent = wt;
            foundEdge = 'left';
            foundStart = Math.max(0, minY - wt.y);
          }
          // Check right edge
          else if (Math.abs(minX - (wt.x + wt.length)) < tolerance &&
              minY >= wt.y - 50 && minY <= wt.y + wt.depth + 50) {
            foundParent = wt;
            foundEdge = 'right';
            foundStart = Math.max(0, minY - wt.y);
          }
        });
        
        const newUpstand = {
          id: nextId++, 
          x: minX, 
          y: minY,
          length: len, 
          height: height,
          vertical, 
          isSplash
        };
        
        if (foundParent && foundEdge) {
          newUpstand.parentId = foundParent.id;
          newUpstand.parentEdge = foundEdge;
          newUpstand.edgeStart = foundStart;
          
          // For attached upstands, use worktop Y position
          if (foundEdge === 'back') {
            newUpstand.y = foundParent.y;
            newUpstand.absoluteY = foundParent.y;
          } else if (foundEdge === 'front') {
            newUpstand.y = foundParent.y + foundParent.depth;
            newUpstand.absoluteY = foundParent.y + foundParent.depth;
          }
          newUpstand.absoluteX = minX;
        }
        
        upstands.push(newUpstand);
        
        // If splashback, check if it should split existing upstands
        if (isSplash) {
          renderLists();
          checkAndSplitUpstands();
        }
      }
    }
    renderLists();
    updateSummary();
  }
  isDrawing = false;
  drawStart = null;
  activeSnap = null;
  render();
}

document.addEventListener('keydown', e => {
  // Don't handle keys if typing in an input
  if (e.target.matches('input, textarea, select')) return;
  
  if (e.code === 'Space') { e.preventDefault(); spaceHeld = true; canvas.style.cursor = 'grab'; }
  if ((e.ctrlKey || e.metaKey) && e.key === 'z') { e.preventDefault(); undo(); }
  if (e.key === 'r' || e.key === 'R') rotateSelected();
  if ((e.key === 'Delete' || e.key === 'Backspace') && !e.target.matches('input')) deleteSelected();
  if (e.key === 'Escape') { if (isDrawing) { isDrawing = false; drawStart = null; render(); } else { hideEdgeMenu(); hideCornerMenu(); clearSelection(); } }
  
  // Arrow keys for panning (2D view) or rotating (3D view)
  if (currentView === '2d') {
    if (e.key === 'ArrowLeft') { e.preventDefault(); panView(-100, 0); }
    if (e.key === 'ArrowRight') { e.preventDefault(); panView(100, 0); }
    if (e.key === 'ArrowUp') { e.preventDefault(); panView(0, -100); }
    if (e.key === 'ArrowDown') { e.preventDefault(); panView(0, 100); }
    // +/- for zoom
    if (e.key === '+' || e.key === '=') { e.preventDefault(); zoomIn(); }
    if (e.key === '-' || e.key === '_') { e.preventDefault(); zoomOut(); }
  } else if (currentView === '3d') {
    if (e.key === 'ArrowLeft') { e.preventDefault(); rotate3D(-1, 0); }
    if (e.key === 'ArrowRight') { e.preventDefault(); rotate3D(1, 0); }
    if (e.key === 'ArrowUp') { e.preventDefault(); rotate3D(0, 1); }
    if (e.key === 'ArrowDown') { e.preventDefault(); rotate3D(0, -1); }
    if (e.key === '+' || e.key === '=') { e.preventDefault(); zoom3D(0.8); }
    if (e.key === '-' || e.key === '_') { e.preventDefault(); zoom3D(1.25); }
  }
});

document.addEventListener('keyup', e => {
  if (e.code === 'Space') { spaceHeld = false; canvas.style.cursor = 'crosshair'; }
});

document.addEventListener('click', e => {
  // Don't hide if clicking on menu or canvas, or if menu was just opened
  if (e.target.closest('.edge-menu')) return;
  if (e.target.closest('#canvasContainer')) return;
  if (edgeMenuJustOpened || cornerMenuJustOpened) return;
  hideEdgeMenu();
  hideCornerMenu();
});

// ========== GENERATE QUOTE ==========
// Capture 3D views from multiple camera angles
// Capture 2D view as image
function capture2DView() {
  try {
    // Switch to 2D if not already
    const wasIn2D = currentView === '2d';
    if (!wasIn2D) {
      switchView('2d');
    }
    
    // Save current state
    const savedSelectedId = selectedId;
    const savedSelectedType = selectedType;
    const savedScale = scale;
    const savedOffset = { x: offset.x, y: offset.y };
    
    // Deselect everything for clean capture
    selectedId = null;
    selectedType = null;
    
    // Calculate bounds for all elements
    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
    const VISUAL_DEPTH = 80;
    
    worktops.forEach(w => {
      minX = Math.min(minX, w.x);
      maxX = Math.max(maxX, w.x + w.length);
      minY = Math.min(minY, w.y);
      maxY = Math.max(maxY, w.y + w.depth);
    });
    
    upstands.forEach(u => {
      const parent = worktops.find(w => w.id === u.parentId);
      if (parent && u.parentEdge) {
        if (u.parentEdge === 'back') {
          minX = Math.min(minX, parent.x);
          maxX = Math.max(maxX, parent.x + u.length);
          minY = Math.min(minY, parent.y - VISUAL_DEPTH);
        } else if (u.parentEdge === 'front') {
          minX = Math.min(minX, parent.x);
          maxX = Math.max(maxX, parent.x + u.length);
          maxY = Math.max(maxY, parent.y + parent.depth + VISUAL_DEPTH);
        }
      }
    });
    
    // Calculate design dimensions
    const designWidth = maxX - minX;
    const designHeight = maxY - minY;
    
    if (designWidth <= 0 || designHeight <= 0 || !isFinite(designWidth) || !isFinite(designHeight)) {
      zoomFit();
      render();
      const dataUrl = canvas.toDataURL('image/png');
      selectedId = savedSelectedId;
      selectedType = savedSelectedType;
      return dataUrl;
    }
    
    // Calculate optimal scale to fit the design with padding
    const padding = 150;
    const fitScale = Math.min(
      (canvas.width - padding * 2) / designWidth,
      (canvas.height - padding * 2) / designHeight
    );
    
    // Use a reasonable scale range
    scale = Math.max(0.03, Math.min(0.25, fitScale));
    
    // Center the design
    const centerX = (minX + maxX) / 2;
    const centerY = (minY + maxY) / 2;
    offset.x = canvas.width / 2 - centerX * scale;
    offset.y = canvas.height / 2 - centerY * scale;
    
    // Render
    render();
    
    // Capture
    const dataUrl = canvas.toDataURL('image/png');
    
    // Restore state
    selectedId = savedSelectedId;
    selectedType = savedSelectedType;
    scale = savedScale;
    offset.x = savedOffset.x;
    offset.y = savedOffset.y;
    
    // Restore view
    if (!wasIn2D) {
      switchView('3d');
    } else {
      render();
    }
    
    return dataUrl;
  } catch (e) {
    console.error('Error capturing 2D view:', e);
    return null;
  }
}

async function capture3DViews() {
  return new Promise((resolve) => {
    try {
      const wasIn3D = currentView === '3d';
      const originalPosition = camera ? camera.position.clone() : null;
      
      // Switch to 3D view if needed
      if (!wasIn3D) {
        switchView('3d');
      }
      
      // Wait for 3D to fully render (including textures)
      setTimeout(() => {
        try {
          if (!renderer || !scene || !camera) {
            console.warn('3D not initialized, resolving with empty array');
            resolve([]);
            return;
          }
          
          // Ensure scene is fully rendered with textures
          render3D();
          
          // Wait a bit more for textures to load
          setTimeout(() => {
            try {
              const views = [];
              
              // Calculate design bounds to position camera appropriately
              let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
              worktops.forEach(w => {
                minX = Math.min(minX, w.x);
                maxX = Math.max(maxX, w.x + w.length);
                minY = Math.min(minY, w.y);
                maxY = Math.max(maxY, w.y + w.depth);
              });
              upstands.forEach(u => {
                minX = Math.min(minX, u.absoluteX || 0);
                maxX = Math.max(maxX, (u.absoluteX || 0) + (u.isVertical ? 20 : u.length));
                minY = Math.min(minY, u.absoluteY || 0);
                maxY = Math.max(maxY, (u.absoluteY || 0) + (u.isVertical ? u.length : 20));
              });
              
              const designWidth = maxX - minX || 3000;
              const designDepth = maxY - minY || 600;
              const designSize = Math.max(designWidth, designDepth);
              
              // Scale camera distances based on design size
              const baseDistance = Math.max(2000, designSize * 0.8);
              const topHeight = Math.max(3000, designSize * 1.0);
              
              console.log('Design size for 3D capture:', designSize, 'Base distance:', baseDistance);
              
              // Define camera angles: [name, x, y, z] - scaled to design
              const cameraAngles = [
                ['Isometric', baseDistance * 0.9, baseDistance * 0.7, baseDistance * 0.9],
                ['Front', 0, baseDistance * 0.5, baseDistance * 1.4],
                ['Top', 0, topHeight, 50],  // Top-down view
                ['Left Side', -baseDistance * 1.4, baseDistance * 0.5, 0],
                ['Right Side', baseDistance * 1.4, baseDistance * 0.5, 0]
              ];
              
              // Capture each angle (use JPEG for smaller file size)
              cameraAngles.forEach(([name, x, y, z]) => {
                camera.position.set(x, y, z);
                camera.lookAt(0, 0, 0);
                renderer.render(scene, camera);
                
                try {
                  const dataUrl = renderer.domElement.toDataURL('image/jpeg', 0.7);
                  views.push({ name, image: dataUrl });
                  console.log('Captured:', name);
                } catch (e) {
                  console.error('Failed to capture', name, e);
                }
              });
              
              // Restore original camera position
              if (originalPosition) {
                camera.position.copy(originalPosition);
                camera.lookAt(0, 0, 0);
                renderer.render(scene, camera);
              }
              
              // Switch back to 2D if we were there
              if (!wasIn3D) {
                switchView('2d');
              }
              
              // Add any custom captures the user made
              if (customCaptures.length > 0) {
                console.log('Adding', customCaptures.length, 'custom captures');
                views.push(...customCaptures);
              }
              
              console.log('Total captured views:', views.length);
              resolve(views);
            } catch (e) {
              console.error('Error in capture loop:', e);
              resolve([]);
            }
          }, 300);
        } catch (e) {
          console.error('Error after 3D init:', e);
          resolve([]);
        }
      }, 600);
    } catch (e) {
      console.error('Error in capture3DViews:', e);
      resolve([]);
    }
  });
}

async function generateQuote() {
  // Check if there are any worktops
  if (worktops.length === 0) {
    alert('Please add at least one worktop before generating a quote.');
    return;
  }
  
  // Check if material is selected
  if (!selectedMaterial || !MATERIAL_COLORS[selectedMaterial]) {
    alert('Please select a material before generating a quote.');
    return;
  }
  
  // IMPORTANT: Calculate slab layout to get accurate slab count
  // This ensures slabs are calculated even if user never visited Slab Layout tab
  renderSlabLayout();
  
  // IMPORTANT: Save design state immediately before navigating away
  // This ensures all positions (including taps) are preserved
  saveDesignState();
  console.log('Design saved before generating quote');
  
  // Debug: log tap positions
  cutouts.filter(c => c.type === 'tap').forEach(t => {
    console.log('Tap before quote:', t.id, 'x:', t.x, 'y:', t.y);
  });
  
  // Show loading indicator
  const btn = document.getElementById('generateQuoteBtn');
  const originalText = btn?.innerHTML;
  if (btn) btn.innerHTML = '‚è≥ Capturing views...';
  
  // Capture 2D view first (cleaner without selection)
  const render2dView = capture2DView();
  console.log('Captured 2D view:', render2dView ? 'success' : 'failed');
  
  // Capture 3D views from multiple angles
  const render3dViews = await capture3DViews();
  console.log('Captured', render3dViews.length, '3D views');
  
  if (btn) btn.innerHTML = originalText;
  
  const mat = MATERIAL_COLORS[selectedMaterial];
  
  // Material type mapping
  const materialTypes = {
    'SIL': 'Quartz', 'DEK': 'Sintered Stone', 'GLO': 'Quartz',
    'MOD': 'Quartz', 'COS': 'Quartz', 'CQS': 'Quartz',
    'ART': 'Quartz', 'NLQ': 'Quartz', 'NAT': 'Natural Stone', 'HOR': 'Quartz',
    'HSP': 'Porcelain'
  };
  
  const brandNames = {
    'SIL': 'Silestone', 'DEK': 'Dekton', 'GLO': 'Global Granite',
    'MOD': 'Modern Quartz', 'COS': 'Cosy Stone', 'CQS': 'Classic Quartz',
    'ART': 'Artemis Stone', 'NLQ': 'Nile Quartz', 'NAT': 'Natural Stone', 'HOR': 'Horizon Stone',
    'HSP': 'Horizon Porcelain'
  };
  
  // Collect worktop data WITH positions and splits
  const worktopData = worktops.map((w, i) => ({
    id: w.id,
    name: w.name || `Piece ${i + 1}`,
    length: w.length,
    depth: w.depth,
    x: w.x,
    y: w.y,
    edgeTypes: w.edgeTypes || {},
    joints: w.joints || {},
    cornerRadii: w.cornerRadii || { tl: 0, tr: 0, br: 0, bl: 0 },
    splits: w.splits || [],
    stepout: w.stepout || null
  }));
  
  // Collect ALL upstands/splashbacks together (they render the same in 3D)
  const upstandData = upstands.filter(u => !u.isWindowCill).map(u => ({
    name: u.name || (u.isSplash ? 'Splashback' : 'Upstand'),
    length: u.length,
    height: u.height || 100,
    x: u.x || 0,
    y: u.y || 0,
    absoluteX: u.absoluteX,
    absoluteY: u.absoluteY,
    vertical: u.vertical || false,
    parentEdge: u.parentEdge || 'back',
    isContinuous: u.isContinuous || false,
    isSplash: u.isSplash || false,
    autoSplitPos: u.autoSplitPos || null // Include auto-split position
  }));
  
  // Empty - we combined them above
  const splashbackData = [];
  
  const windowCillData = upstands.filter(u => u.isWindowCill).map(c => {
    const parent = worktops.find(w => w.id === c.parentId);
    return {
      name: c.name || 'Window Cill',
      length: c.length,
      depth: c.depth || 200,
      height: c.height || 300,
      overhang: c.overhang || 20,
      x: c.x || 0,
      y: c.y || 0,
      absoluteX: c.absoluteX,
      absoluteY: c.absoluteY,
      parentEdge: c.parentEdge || 'back',
      edgeStart: c.edgeStart || 0,
      // Parent worktop info for positioning
      parentX: parent?.x || 0,
      parentY: parent?.y || 0,
      parentLength: parent?.length || 3000,
      parentDepth: parent?.depth || 600
    };
  });
  
  // Collect cutouts from global cutouts array (not w.cutouts)
  const cutoutsList = [];
  
  // Track counts for included items
  let sinkCount = 0, drainerCount = 0, hobCount = 0, tapCount = 0, socketCount = 0;
  
  cutouts.forEach(c => {
    if (c.type === 'socket') {
      // Socket cutouts - on splashbacks
      socketCount++;
      const parentSplash = upstands.find(u => u.id === c.parentId);
      cutoutsList.push({
        type: 'socket',
        name: `Socket Cutout (${c.width}√ó${c.height}mm)`,
        width: c.width,
        height: c.height,
        centerX: c.centerX,
        centerY: c.centerY,
        parentId: c.parentId,
        included: true,  // Sockets are included
        price: 0
      });
    } else {
      // Find parent worktop
      const parent = worktops.find(w => w.id === c.parentId);
      if (parent) {
        // Determine if included or extra
        let included = false;
        let price = 0;
        
        if (c.type === 'undermount_sink' || c.type === 'overmount_sink' || c.type === 'sink_with_drainers') {
          sinkCount++;
          included = sinkCount <= 1;  // First sink included
          price = included ? 0 : 150;
        } else if (c.type === 'drainer' || c.type === 'recess_drainer') {
          drainerCount++;
          included = drainerCount <= 1;  // First drainer included
          price = included ? 0 : 75;
        } else if (c.type === 'hob' || c.type === 'recess_hob') {
          hobCount++;
          included = hobCount <= 1;  // First hob included
          price = included ? 0 : 100;
        } else if (c.type === 'tap') {
          tapCount++;
          included = tapCount <= 1;  // First tap included
          price = included ? 0 : 35;
        }
        
        // Determine display name - 80mm+ taps are "Pop-up Socket"
        let displayName = CUTOUT_PRICES[c.type]?.name || c.type;
        if (c.type === 'tap' && c.diameter >= 80) {
          displayName = 'Pop-up Socket';
        }
        
        // For drainers, add side info to name - use clickedSide (what user selected)
        if ((c.type === 'drainer' || c.type === 'recess_drainer') && c.clickedSide) {
          const sideLabel = c.clickedSide === 'left' ? 'Left' : c.clickedSide === 'right' ? 'Right' : 'Both';
          displayName = `${displayName} (${sideLabel})`;
        }
        
        cutoutsList.push({
          type: c.type,
          name: displayName,
          absoluteX: c.x || 0,
          absoluteY: c.y || 0,
          width: c.width || c.diameter || 35,
          height: c.length || c.height || c.diameter || 35,
          worktopX: parent.x || 0,
          worktopY: parent.y || 0,
          included: included,
          price: price,
          side: c.clickedSide || c.side || null  // Use clickedSide for display
        });
      }
    }
  });
  
  // Collect edge profiles
  const edgesList = [];
  worktops.forEach(w => {
    if (w.edgeTypes) {
      Object.entries(w.edgeTypes).forEach(([key, val]) => {
        // Parse key - handle both normal edges (front_0_3000) and stepout edges (stepout_bottom_0_620)
        const parts = key.split('_');
        let edge, start, end;
        if (parts[0] === 'stepout') {
          edge = parts[0] + '_' + parts[1]; // e.g., 'stepout_bottom'
          start = parts[2];
          end = parts[3];
        } else {
          edge = parts[0];
          start = parts[1];
          end = parts[2];
        }
        const length = (parseInt(end) - parseInt(start)) / 1000;
        
        if (val.type === 'profile') {
          edgesList.push({
            type: val.profileKey,
            name: val.profileName,
            length: length,
            price: val.pricePerMeter || 0,
            included: val.pricePerMeter === 0
          });
        } else if (val.type === 'mitred_edge') {
          edgesList.push({
            type: 'mitred_edge',
            name: `Mitred Edge (${val.height}mm)`,
            length: length,
            height: val.height,
            price: val.pricePerMeter || 66.67,
            included: false
          });
        } else if (val.type === 'dropdown') {
          edgesList.push({
            type: 'dropdown',
            name: 'Dropdown',
            length: length,
            height: val.height,
            price: 0,
            included: true,
            // Position data for 3D
            edge: edge,
            startMm: parseInt(start),
            endMm: parseInt(end),
            worktopX: w.x,
            worktopY: w.y,
            worktopLength: w.length,
            worktopDepth: w.depth,
            stepout: w.stepout || null
          });
        }
      });
    }
  });
  
  // Calculate slabs required
  const slabsRequired = parseInt(document.getElementById('sumSlabs')?.textContent) || 1;
  console.log('Slabs required for quote:', slabsRequired);
  
  // Get fabrication prices based on material type
  const fabPrices = getFabricationPrices(mat.brand);
  
  // Get profit values from admin inputs if manually set
  const profit1stEl = document.getElementById('profit1stSlab');
  const profitAddEl = document.getElementById('profitAddSlab');
  const profit1st = (profit1stEl && profit1stEl.dataset.manuallySet === 'true') 
    ? parseFloat(profit1stEl.value) || fabPrices.firstSlab 
    : fabPrices.firstSlab;
  const profitPerSqFt = (profitAddEl && profitAddEl.dataset.manuallySet === 'true') 
    ? parseFloat(profitAddEl.value) || fabPrices.additionalSlabPerSqFt 
    : fabPrices.additionalSlabPerSqFt;
  
  // Calculate sq ft on additional slabs from the rendered slab layout
  // We need to read this from the last slab layout calculation
  let additionalSlabsSqFt = 0;
  const slabCanvasEl = document.getElementById('canvasSlab');
  console.log('=== SLAB DATA DEBUG ===');
  console.log('slabCanvasEl found:', !!slabCanvasEl);
  console.log('_lastSlabData:', slabCanvasEl?._lastSlabData);
  if (slabCanvasEl && slabCanvasEl._lastSlabData) {
    additionalSlabsSqFt = slabCanvasEl._lastSlabData.additionalSlabsSqFt || 0;
    console.log('additionalSlabsSqFt from slab data:', additionalSlabsSqFt);
  } else {
    console.log('WARNING: No slab data found!');
  }
  
  // Get material pricing - check custom slab price first
  const customSlabPriceEl = document.getElementById('customSlabPrice');
  const customSlabPrice = customSlabPriceEl ? parseFloat(customSlabPriceEl.value) || 0 : 0;
  
  const matPricing = MATERIAL_PRICING[selectedMaterial];
  const slabPrice = customSlabPrice > 0 ? customSlabPrice : (matPricing ? 
    (worktopThickness === 30 && matPricing.price30slab ? matPricing.price30slab : matPricing.price20slab) || 0 
    : 0);
  const tier = matPricing ? matPricing.tier : (mat.tier || 1);
  
  // Build quote data object (images stored separately to avoid localStorage limits)
  // Check if custom material is active
  const useCustomMaterial = customMaterial.active && customMaterial.name;
  
  const quoteData = {
    quoteNumber: 'PSW-' + new Date().getFullYear() + '-' + String(Math.floor(Math.random() * 9000) + 1000),
    date: new Date().toISOString(),
    material: useCustomMaterial ? {
      key: 'custom',
      name: customMaterial.name,
      brand: 'Custom',
      brandCode: 'CUS',
      type: customMaterial.type.charAt(0).toUpperCase() + customMaterial.type.slice(1),  // Capitalize
      materialType: customMaterial.type,
      tier: 0,  // No tier for custom
      thickness: customMaterial.thickness,
      textureId: null,
      css: '#d4a574',  // Default brown for custom stone
      roughness: 0.3,
      slabPrice: customMaterial.slabPrice || slabPrice,
      isCustom: true,
      customImage: customMaterial.imageData || null,  // Include image for summary page
      customImageName: customMaterial.imageName || ''
    } : {
      key: selectedMaterial,
      name: mat.name,
      brand: brandNames[mat.brand] || mat.brand,
      brandCode: mat.brand,  // For cropping logic
      type: mat.brand === 'NAT' ? (mat.type || 'Natural Stone') : (materialTypes[mat.brand] || 'Stone'),
      materialType: fabPrices.type,  // quartz, dekton, or natural_stone - for pricing
      tier: tier,
      thickness: worktopThickness,
      textureId: mat.textureId || null,
      css: mat.css || '#e8e8e8',
      roughness: mat.roughness || 0.3,
      slabPrice: slabPrice  // Material cost per slab (internal use only)
    },
    worktops: worktopData,
    upstands: upstandData,
    splashbacks: splashbackData,
    windowCills: windowCillData,
    cutouts: cutoutsList,
    edges: edgesList,
    dropdowns: edgesList.filter(e => e.type === 'dropdown').map(e => ({ length: e.length * 1000, height: e.height })),
    pricing: {
      materialPerSlab: slabPrice,             // Material cost per slab (internal)
      firstSlab: profit1st,                   // Fixed first slab profit
      additionalSlabPerSqFt: profitPerSqFt,   // ¬£ per sq ft on additional slabs
      additionalSlabsSqFt: additionalSlabsSqFt, // Total sq ft on slabs 2+
      slabsUsed: slabsRequired,
      // Include what's in the base price for reference
      included: {
        sinks: INCLUDED_IN_BASE.sinks,
        hobs: INCLUDED_IN_BASE.hobs,
        drainers: INCLUDED_IN_BASE.drainers,
        taps: INCLUDED_IN_BASE.taps,
        edges: INCLUDED_IN_BASE.edgeProfile
      }
    },
    customer: {
      name: '',
      email: '',
      phone: '',
      address: ''
    },
    // Slab layout - pre-packed from designer for consistency
    slabLayoutData: getPackedSlabLayout()
    // Note: render3dViews removed - images too large for localStorage
    // Quote summary will use interactive 3D instead
  };
  
  // Helper function to get fully packed slab layout (matches renderSlabLayout exactly)
  function getPackedSlabLayout() {
    const slabWInput = document.getElementById('slabWidthInput');
    const slabHInput = document.getElementById('slabHeightInput');
    const SLAB_W = slabWInput ? parseInt(slabWInput.value) || 3200 : 3200;
    const SLAB_H = slabHInput ? parseInt(slabHInput.value) || 1600 : 1600;
    
    // Collect pieces (same as renderSlabLayout)
    const pieces = [];
    
    worktops.forEach(w => {
      if (w.splits && w.splits.length > 0) {
        const verticalSplits = w.splits.filter(s => s.direction === 'vertical').sort((a, b) => a.position - b.position);
        const horizontalSplits = w.splits.filter(s => s.direction === 'horizontal').sort((a, b) => a.position - b.position);
        
        if (verticalSplits.length > 0) {
          let prevPos = 0;
          verticalSplits.forEach((split, i) => {
            pieces.push({ name: `${w.name || 'Worktop'} (${i+1})`, width: split.position - prevPos, height: w.depth, type: 'worktop', color: '#e3f2fd' });
            prevPos = split.position;
          });
          pieces.push({ name: `${w.name || 'Worktop'} (${verticalSplits.length+1})`, width: w.length - prevPos, height: w.depth, type: 'worktop', color: '#e3f2fd' });
        } else if (horizontalSplits.length > 0) {
          let prevPos = 0;
          horizontalSplits.forEach((split, i) => {
            pieces.push({ name: `${w.name || 'Worktop'} (${i+1})`, width: w.length, height: split.position - prevPos, type: 'worktop', color: '#e3f2fd' });
            prevPos = split.position;
          });
          pieces.push({ name: `${w.name || 'Worktop'} (${horizontalSplits.length+1})`, width: w.length, height: w.depth - prevPos, type: 'worktop', color: '#e3f2fd' });
        }
      } else {
        let pw = w.length;
        let ph = w.depth;
        let isLShape = false;
        
        if (w.stepout) {
          isLShape = true;
          const isVertical = w.depth > w.length;
          if (isVertical) {
            pw = w.length + w.stepout.depth;
          } else {
            ph = w.depth + w.stepout.depth;
          }
        }
        
        const fits = (pw <= SLAB_W && ph <= SLAB_H) || (ph <= SLAB_W && pw <= SLAB_H);
        pieces.push({
          name: isLShape ? `${w.name} (L)` : w.name,
          width: pw,
          height: ph,
          type: 'worktop',
          color: isLShape ? '#d4e6f1' : '#e3f2fd',
          error: !fits,
          isLShape: isLShape,
          stepout: w.stepout || null
        });
      }
    });
    
    upstands.forEach(u => {
      const ph = u.isWindowCill ? (u.depth || 200) : u.height;
      if (u.length >= 10 && ph >= 10) {
        if (u.isWindowCill) {
          pieces.push({ name: 'Cill', width: u.length, height: ph, type: 'cill', color: '#fff3e0' });
        } else if (u.isSplash) {
          pieces.push({ name: 'Splash', width: u.length, height: ph, type: 'splash', color: '#e0f7fa' });
        } else {
          pieces.push({ name: 'Upstand', width: u.length, height: ph, type: 'upstand', color: '#e8f5e9' });
        }
      }
    });
    
    worktops.forEach(w => {
      if (w.edgeTypes) {
        Object.entries(w.edgeTypes).forEach(([k, v]) => {
          if (v.type === 'dropdown') {
            const [edge, s, e] = k.split('_');
            pieces.push({ name: 'Dropdown', width: parseInt(e) - parseInt(s), height: v.height, type: 'dropdown', color: '#f3e5f5' });
          } else if (v.type === 'mitred_edge') {
            const [edge, s, e] = k.split('_');
            pieces.push({ name: 'Mitred Edge', width: parseInt(e) - parseInt(s), height: v.height, type: 'mitred_edge', color: '#d7ccc8' });
          }
        });
      }
    });
    
    if (pieces.length === 0) return { slabs: [], slabW: SLAB_W, slabH: SLAB_H };
    
    // Sort by area descending
    const sortedPieces = [...pieces].sort((a, b) => (b.width * b.height) - (a.width * a.height));
    
    // Pack into slabs (same algorithm as renderSlabLayout)
    const slabs = [];
    
    function createSlab() {
      return { freeRects: [{ x: 0, y: 0, w: SLAB_W, h: SLAB_H }], pieces: [] };
    }
    
    function rectsOverlap(a, b) {
      return !(a.x >= b.x + b.w || a.x + a.w <= b.x || a.y >= b.y + b.h || a.y + a.h <= b.y);
    }
    
    function findBestRect(slab, pw, ph) {
      let bestScore = Infinity;
      let bestRect = null;
      let bestRotated = false;
      
      for (const rect of slab.freeRects) {
        // Try normal orientation
        if (pw <= rect.w && ph <= rect.h) {
          // Score = how much space is wasted, prefer tighter fits
          let score = (rect.w - pw) + (rect.h - ph);
          
          // Strong penalty if piece would be taller than wide (vertical)
          if (ph > pw) {
            score += 500000;
          }
          
          if (score < bestScore) {
            bestScore = score;
            bestRect = rect;
            bestRotated = false;
          }
        }
        // Try rotated
        if (ph <= rect.w && pw <= rect.h && pw !== ph) {
          // After rotation: width=ph, height=pw
          let score = (rect.w - ph) + (rect.h - pw);
          
          // Strong penalty if rotated piece would be taller than wide
          if (pw > ph) {
            score += 500000;
          }
          
          if (score < bestScore) {
            bestScore = score;
            bestRect = rect;
            bestRotated = true;
          }
        }
      }
      return bestRect ? { rect: bestRect, rotated: bestRotated } : null;
    }
    
    function pruneRects(rects) {
      const result = [];
      for (let i = 0; i < rects.length; i++) {
        let dominated = false;
        for (let j = 0; j < rects.length; j++) {
          if (i !== j) {
            const a = rects[i], b = rects[j];
            if (b.x <= a.x && b.y <= a.y && b.x + b.w >= a.x + a.w && b.y + b.h >= a.y + a.h) {
              dominated = true;
              break;
            }
          }
        }
        if (!dominated && rects[i].w > 0 && rects[i].h > 0) result.push(rects[i]);
      }
      return result;
    }
    
    function placePiece(slab, rect, pw, ph, rotated) {
      const actualW = rotated ? ph : pw;
      const actualH = rotated ? pw : ph;
      const placed = { x: rect.x, y: rect.y, w: actualW, h: actualH, rotated: rotated };
      
      const newRects = [];
      for (const freeRect of slab.freeRects) {
        if (rectsOverlap(freeRect, placed)) {
          if (placed.x + placed.w < freeRect.x + freeRect.w) {
            newRects.push({ x: placed.x + placed.w, y: freeRect.y, w: freeRect.x + freeRect.w - (placed.x + placed.w), h: freeRect.h });
          }
          if (placed.x > freeRect.x) {
            newRects.push({ x: freeRect.x, y: freeRect.y, w: placed.x - freeRect.x, h: freeRect.h });
          }
          if (placed.y + placed.h < freeRect.y + freeRect.h) {
            newRects.push({ x: freeRect.x, y: placed.y + placed.h, w: freeRect.w, h: freeRect.y + freeRect.h - (placed.y + placed.h) });
          }
          if (placed.y > freeRect.y) {
            newRects.push({ x: freeRect.x, y: freeRect.y, w: freeRect.w, h: placed.y - freeRect.y });
          }
        } else {
          newRects.push(freeRect);
        }
      }
      slab.freeRects = pruneRects(newRects);
      return placed;
    }
    
    function tryPlacePiece(slab, pw, ph) {
      const best = findBestRect(slab, pw, ph);
      if (!best) return null;
      return placePiece(slab, best.rect, pw, ph, best.rotated);
    }
    
    sortedPieces.forEach(piece => {
      if (piece.error) {
        const newSlab = createSlab();
        newSlab.pieces.push({ ...piece, x: 0, y: 0, pw: piece.width, ph: piece.height, rotated: false });
        slabs.push(newSlab);
        return;
      }
      
      let placed = null;
      let placedSlab = null;
      
      for (let slab of slabs) {
        placed = tryPlacePiece(slab, piece.width, piece.height);
        if (placed) {
          placedSlab = slab;
          break;
        }
      }
      
      if (!placed) {
        const newSlab = createSlab();
        placed = tryPlacePiece(newSlab, piece.width, piece.height);
        if (placed) {
          placedSlab = newSlab;
          slabs.push(newSlab);
        } else {
          newSlab.pieces.push({ ...piece, x: 0, y: 0, pw: piece.width, ph: piece.height, rotated: false, error: true });
          slabs.push(newSlab);
          return;
        }
      }
      
      placedSlab.pieces.push({
        ...piece,
        x: placed.x,
        y: placed.y,
        pw: placed.w,
        ph: placed.h,
        rotated: placed.rotated
      });
    });
    
    // Return slabs without freeRects (not needed for rendering)
    return {
      slabs: slabs.map(s => ({ pieces: s.pieces })),
      slabW: SLAB_W,
      slabH: SLAB_H
    };
  }
  
  // Store quote data in localStorage
  try {
    const jsonData = JSON.stringify(quoteData);
    console.log('Quote data size:', (jsonData.length / 1024).toFixed(1), 'KB');
    localStorage.setItem('primeWorktopsQuote', jsonData);
    console.log('Quote data saved to localStorage');
  } catch (e) {
    console.error('Failed to save quote data:', e);
    alert('Error saving quote data.');
    return;
  }
  
  // Capture slab layout canvas as image
  // First ensure it's rendered (even if tab not visible)
  let slabLayoutImage = null;
  const slabCanvas = document.getElementById('canvasSlab');  // Correct ID
  if (slabCanvas) {
    // Force render the slab layout
    renderSlabLayout();
    
    // Check canvas has content
    if (slabCanvas.width > 0 && slabCanvas.height > 0) {
      try {
        slabLayoutImage = slabCanvas.toDataURL('image/png');
        console.log('Slab layout captured, size:', (slabLayoutImage.length / 1024).toFixed(1), 'KB', 'dimensions:', slabCanvas.width, 'x', slabCanvas.height);
      } catch (e) {
        console.warn('Could not capture slab layout:', e);
      }
    } else {
      console.warn('Slab canvas has no dimensions:', slabCanvas.width, 'x', slabCanvas.height);
    }
  } else {
    console.warn('Slab canvas element not found');
  }
  
  // Store images separately in sessionStorage (clears when tab closes)
  const imageData = {
    render3dViews: render3dViews || [],
    render2dView: render2dView || null,
    slabLayoutImage: slabLayoutImage
  };
  
  try {
    sessionStorage.setItem('primeWorktopsImages', JSON.stringify(imageData));
    console.log('Images saved to sessionStorage: 3D views:', render3dViews?.length || 0, ', 2D:', render2dView ? 'yes' : 'no', ', Slab:', slabLayoutImage ? 'yes (' + (slabLayoutImage.length / 1024).toFixed(1) + 'KB)' : 'no');
  } catch (e) {
    console.warn('Could not save images to sessionStorage:', e);
  }
  
  // Open quote summary page
  console.log('Opening quote summary page...');
  
  // Use direct navigation to avoid popup blockers
  // Store a flag that quote was generated
  localStorage.setItem('primeWorktopsQuoteReady', 'true');
  
  // Open in same tab - user can use back button to return
  window.location.href = 'quote_summary.html';
}

// ========== AUTO-SAVE DESIGN ==========
function saveDesignState() {
  try {
    // Debug: log socket positions before saving
    cutouts.filter(c => c.type === 'socket').forEach(s => {
      console.log('Saving socket:', s.id, 'centerX:', s.centerX, 'centerY:', s.centerY);
    });
    
    // Debug: log tap positions before saving
    cutouts.filter(c => c.type === 'tap').forEach(t => {
      console.log('Saving tap:', t.id, 'x:', t.x, 'y:', t.y, 'diameter:', t.diameter);
    });
    
    // Strip autoSplitPos from upstands - these are calculated dynamically
    const cleanUpstands = upstands.map(u => {
      const { autoSplitPos, ...rest } = u;
      return rest;
    });
    
    const state = {
      worktops: worktops,
      upstands: cleanUpstands,
      cutouts: cutouts,
      selectedMaterial: selectedMaterial,
      worktopThickness: worktopThickness,
      nextId: nextId,
      savedAt: new Date().toISOString()
    };
    localStorage.setItem('primeWorktopsDesign', JSON.stringify(state));
    console.log('Design auto-saved');
  } catch (e) {
    console.warn('Could not auto-save design:', e);
  }
}

function loadDesignState() {
  try {
    const saved = localStorage.getItem('primeWorktopsDesign');
    if (saved) {
      const state = JSON.parse(saved);
      worktops = state.worktops || [];
      upstands = state.upstands || [];
      cutouts = state.cutouts || [];
      selectedMaterial = state.selectedMaterial || null;
      worktopThickness = state.worktopThickness || 20;
      nextId = state.nextId || 1;
      
      // Clear any saved autoSplitPos - these should be recalculated fresh
      upstands.forEach(u => delete u.autoSplitPos);
      
      // Debug: log socket positions
      cutouts.filter(c => c.type === 'socket').forEach(s => {
        console.log('Loaded socket:', s.id, 'parentId:', s.parentId, 'centerX:', s.centerX, 'centerY:', s.centerY);
      });
      
      // Cleanup orphaned sockets (sockets whose parent upstand no longer exists)
      const orphanedSockets = cutouts.filter(c => 
        c.type === 'socket' && !upstands.find(u => u.id === c.parentId)
      );
      if (orphanedSockets.length > 0) {
        console.warn('Removing', orphanedSockets.length, 'orphaned socket(s):', orphanedSockets.map(s => s.id));
        cutouts = cutouts.filter(c => 
          c.type !== 'socket' || upstands.find(u => u.id === c.parentId)
        );
      }
      
      // Debug: log tap positions
      cutouts.filter(c => c.type === 'tap').forEach(t => {
        console.log('Loaded tap:', t.id, 'x:', t.x, 'y:', t.y, 'diameter:', t.diameter);
      });
      
      console.log('Design loaded from auto-save:', state.savedAt);
      console.log('  Worktops:', worktops.length, 'Upstands:', upstands.length, 'Cutouts:', cutouts.length);
      console.log('  Material:', selectedMaterial);
      
      // Update UI
      if (selectedMaterial && MATERIAL_COLORS[selectedMaterial]) {
        const mat = MATERIAL_COLORS[selectedMaterial];
        document.getElementById('materialSearch').value = mat.name || '';
        
        // Update material preview swatch
        const previewEl = document.getElementById('materialPreview');
        if (previewEl) {
          if (mat.textureId) {
            previewEl.style.backgroundImage = `url('https://lh3.googleusercontent.com/d/${mat.textureId}=s200')`;
          }
          previewEl.style.backgroundColor = mat.css || '#e8e8e8';
        }
        
        // Show and update the selected material bar
        const bar = document.getElementById('selectedMaterialBar');
        const thumb = document.getElementById('selectedMatThumb');
        const nameEl = document.getElementById('selectedMatName');
        const brandEl = document.getElementById('selectedMatBrand');
        const tierEl = document.getElementById('selectedMatTier');
        const thickEl = document.getElementById('selectedMatThickness');
        
        if (bar && thumb && nameEl) {
          bar.style.display = 'block';
          nameEl.textContent = mat.name;
          
          const brandNames = {
            'SIL': 'Silestone', 'DEK': 'Dekton', 'GLO': 'Global Granite',
            'MOD': 'Modern Quartz', 'COS': 'Cosy Stone', 'CQS': 'Classic Quartz',
            'ART': 'Artemis Stone', 'NLQ': 'Nile Quartz', 'NAT': 'Natural Stone', 'HOR': 'Horizon Stone'
          };
          const materialTypes = {
            'SIL': 'Quartz', 'DEK': 'Sintered Stone', 'GLO': 'Quartz',
            'MOD': 'Quartz', 'COS': 'Quartz', 'CQS': 'Quartz',
            'ART': 'Quartz', 'NLQ': 'Quartz', 'NAT': 'Natural Stone', 'HOR': 'Porcelain'
          };
          const matType = mat.brand === 'NAT' ? (mat.type || 'Natural Stone') : (materialTypes[mat.brand] || 'Stone');
          if (brandEl) brandEl.textContent = `${brandNames[mat.brand] || mat.brand} ‚Ä¢ ${matType}`;
          
          const pricing = MATERIAL_PRICING[selectedMaterial];
          const tier = pricing ? pricing.tier : (mat.tier || 1);
          if (tierEl) tierEl.textContent = '¬£'.repeat(tier);
          if (thickEl) thickEl.textContent = worktopThickness + 'mm';
          
          // Thumbnail with cropping for watermarks
          const needsCrop = mat.brand === 'GLO' || mat.brand === 'MOD' || mat.brand === 'ART' || mat.brand === 'NAT' || mat.brand === 'CQS';
          if (mat.textureId) {
            thumb.style.backgroundImage = `url('https://lh3.googleusercontent.com/d/${mat.textureId}=s100')`;
            thumb.style.backgroundSize = needsCrop ? '300%' : 'cover';
            thumb.style.backgroundPosition = 'center';
          } else {
            thumb.style.backgroundImage = 'none';
            thumb.style.backgroundColor = mat.css || '#ccc';
          }
        }
        
        // Reload the texture for 3D view
        loadMaterialTexture(selectedMaterial, () => {
          console.log('Material texture reloaded for:', selectedMaterial);
        });
      }
      document.getElementById('thicknessSelect').value = worktopThickness;
      
      // Center the view after a short delay to let canvas initialize
      setTimeout(() => {
        zoomFit();
        render();
        renderLists();
        updateSummary();
      }, 100);
      
      return true;
    }
  } catch (e) {
    console.warn('Could not load saved design:', e);
  }
  return false;
}

function clearDesignState() {
  if (confirm('Clear saved design? This will start fresh.')) {
    localStorage.removeItem('primeWorktopsDesign');
    worktops = [];
    upstands = [];
    cutouts = [];
    selectedId = null;
    selectedType = null;
    nextId = 1;
    
    // Reset slab warning state
    slabOptimizationSuggestions = [];
    hasShownSlabWarning = false;
    lastKnownSlabCount = 0;
    sessionStorage.setItem('hasShownSlabWarning', 'false');
    sessionStorage.setItem('lastKnownSlabCount', '0');
    
    // Hide warning panel
    const warningDiv = document.getElementById('slabWarning');
    if (warningDiv) warningDiv.style.display = 'none';
    
    renderLists();
    render();
    updateSummary();
    alert('Design cleared.');
  }
}

// Auto-save on changes (debounced)
let saveTimeout = null;
function triggerAutoSave() {
  if (saveTimeout) clearTimeout(saveTimeout);
  saveTimeout = setTimeout(saveDesignState, 1000); // Save 1 second after last change
}

// Hook into existing functions that modify the design
const originalSaveHistory = saveHistory;
saveHistory = function() {
  originalSaveHistory();
  triggerAutoSave();
};

// Init - load materials first, then design
(async function init() {
  // First load materials
  const autoLoaded = await autoLoadPricingJSON();
  if (!autoLoaded) {
    restoreMaterialsFromStorage(); // Fall back to sessionStorage if auto-load fails
  }
  
  // Then load saved design (which may reference materials)
  loadDesignState();
  
  // Restore custom material settings (persists across page navigation)
  restoreCustomMaterial();
  
  // Update UI
  updateCurrentMaterialDisplay();
  updateZoom();
  renderLists();
  render();
  updateSummary();
  updateTierStylePreview();
  updateTierFilterButtons();
  
  // Enable slab warnings after page has loaded (prevents popup on initial load)
  setTimeout(enableSlabWarnings, 1000);
  
  // Check if admin was previously unlocked (persists across page navigation)
  if (adminUnlocked) {
    const slabTab = document.getElementById('slabLayoutTab');
    if (slabTab) slabTab.style.display = 'block';
    
    const btn = document.getElementById('adminTabBtn');
    if (btn) {
      btn.textContent = 'üîì Admin ‚úì';
      btn.style.background = '#e8f5e9';
      btn.style.borderColor = '#1e4d3a';
    }
  }
})();
</script>
</body>
</html>
